[{"uri":"https://xtls.github.io/documents/level-0/ch01-preface/","title":"【第1章】前言啰嗦篇","tags":[],"description":"小小白白话文","content":"1.1 这篇文档是写给谁的？  一句话：写给 ①零基础 ②希望学习自建VPS 的新人。\n1.2 这篇文档不是写给谁的？ 包括但不限于：各路大神大能、懒得自己折腾的小白、已经会折腾的高手、确定要用机场的土豪、确定要用一键脚本的逍遥派\u0026hellip;\u0026hellip; 总之只要有技术基础、或不愿不想自建的同学，您直接关闭本文即可，因为这篇文章大概是入不了您的法眼的，更可能会让您生一肚子闲气，那多划不来。\n1.3 郑重声明及其他声明   郑重声明： 鄙人技术奇菜无比，故本文必然挂一漏万破绽百出。您若发现问题还请温柔提醒，莫要人参公鸡。\n   免责声明： 本文内容请您自行判断是否可信可靠可用，若您根据本文内容建立和使用VPS服务器时出了任何问题和不良结果，鄙人概不负责。\n   啰嗦声明： 基于本文【零基础用户】的目标受众，许多内容会尽力详尽说明，所以语言偏啰嗦，请做好心理准备。\n   1.4 为什么自建是个难题？ 要回答这个问题，就需要稍微多说一点背景信息了。\n一、科学上网这件事\n科学上网这件事情，说来已经发展了近二十年（震惊!!!.jpg）。最初，自己稍微动动手即可（改改host、连一下ssh）、后来需要找一个网页代理，再后来需要写一个私有协议(比如Shadowsocks)等等。\n随着GFW技术这十几年来不断的迭代升级，若要完成【自己动手科学上网】这个目标，需要做的事情已经包括但不限于：\n1. 了解Linux系统基本命令 2. 了解网络传输协议 3. 有技术和经济能力完成VPS购买及管理 4. 有技术和经济能力完成域名购买及管理 5. 有技术能力完成TLS证书申请 等等。  这就让【自建VPS科学上网】这个曾经简单的行为逐渐变成了令新人望而生畏的挑战。\n二、零基础用户的无奈\n零基础的非技术用户，如果完成上面这一连串的操作，势必要学习大量的知识，但稍微搜索之后，新人只怕会更加迷茫：大量的信息散布在互联网的各个角落：博客、问答网站、群组、论坛、GitHub、Telegram、YouTube 等等等等）。这些信息纷乱复杂、水平良莠不齐、甚至可能互相矛盾。基本上就是不把新人彻底弄晕誓不罢休。\n面对这些杂乱无章的信息，新人突然就从【信息匮乏】变成了【信息过剩】。若是几番连蒙带猜的折腾以失败告终（大概率如此）的话，他的积极性势必大受挫折。在这个过程中，若他又恰好去了一些不太友好的地方去求助，恐怕还要雪上加霜的被嘲讽一番：“这么菜，用机场不就行了，瞎折腾什么啊！”、“先去学会Linux再回来问吧”。\n这时候，大概也只有一声“呵呵”可以表达心情了。\n1.5 “用机场不就行了？” 首先，我想反问一下那些冷嘲热讽的人：“用机场”真的就是万灵药吗？\n其次，我认为“不懂”和“不想懂”是有本质区别的。态度恶劣的巨婴伸手党自然惹人厌烦，但真心自学却不得要领的人不该受到无端的白眼和歧视，也正是这样恶劣而压抑新人环境促使我写下此文。那么闲话少说，我们来看看机场的优劣究竟如何：\n一、“机场“的优势\n所谓“机场”，就是“线路提供商”。他负责完成1.4提到的那一串技术操作和管理，用户则付费获得使用权。所以，它的优点至少有：\n 用户操作简单：扫码操作、一键添加规则等 线路选择多：可解锁不同国家、地区的网络服务；比如iplc等专线服务、游戏加速服务等 接入节点多：所以抵抗节点封锁的能力强一些，封了一个就换下一个  二、“机场”的风险\n“方便”这枚硬币的另一面就是“风险”，基于“机场”的技术特点和市场情况，它的风险至少有：\n “机场”可完全获得用户信息：用户在网上的所有痕迹，都【必然】经过且【非常可能】长期存储在其服务器上，这些记录无法受到任何具备法律效力的用户隐私协议的约束（窥视、记录你的一举一动） “机场”缺乏市场管理：不可避免存在着以欺诈为目标的恶意商家（主动跑路） “机场”面临监管压力：大机场相对有保障的同时，也无法避免树大招风。2020年间，已经有几个大机场停运、跑路的事件发生，用户的正常使用受到严重干扰（被动跑路） “机场”技术水平难以确定：线路质量良莠不齐，挂羊头卖狗肉的现象屡见不鲜（速度慢、掉线多、连不上）  1.6 那么你到底要不要自建呢？ 现在，你已经看到了机场的优势和风险，要用什么，就请各位充分思考并自行决定。毕竟，最适合你的方案才是最好的方案。\n  如果决定使用机场的话，现在，你可以关闭本文了。\n  如果你决定自建，那就请继续阅读后面的章节吧！！\n  总之，本文的目标就是成为零基础用户的知识起点，提供对每一步充分的讲解和演示，清清楚楚（甚至婆婆妈妈、絮絮叨叨、啰啰嗦嗦）的协助新人完成【从输入第一条命令开始，完成VPS服务器部署，并成功在客户端完成科学上网】的全程。并在这个过程中帮助新人逐步接触和熟悉Linux的基础操作，为之后的进一步自学打下基础。\n1.7 题外啰嗦几句   墙外的信息泥沙俱下，请务必学会理性、独立的思辨，不要随意站队，不要轻信猎奇的信息。\n  衷心希望大家获得更顺畅的网络后，可以获取更新鲜的知识、更丰富的娱乐、接触更美好的世界、结交更多志同道合的朋友，但不要成为任何有不可告人目的之人的替罪羊。\n  你的互联网身份依然是你的身份，绝对的匿名化是极为困难的，所以请务必遵守你个人所在地区和IP所在地区的相关法律法规。无论何时，自我保护都是最基本的底线。\n  1.8 你的进度 PROGRESS⬛⬜⬜⬜⬜⬜⬜⬜ 12.5%\n "},{"uri":"https://xtls.github.io/config/outbound-protocols/blackhole/","title":"Blackhole","tags":[],"description":"Project X 的文档.","content":"Blackhole（黑洞）是一个出站数据协议，它会阻碍所有数据的出站，配合 路由配置 一起使用，可以达到禁止访问某些网站的效果。\nOutboundConfigurationObject  { \u0026#34;response\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; } }  response: ResponseObject\n 配置黑洞的响应数据。\nBlackhole 会在收到待转发数据之后，发送指定的响应数据，然后关闭连接，待转发的数据将被丢弃。 如不指定此项，Blackhole 将直接关闭连接。\n\nResponseObject  { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }  type: \u0026ldquo;http\u0026rdquo; | \u0026ldquo;none\u0026rdquo;\n 当 type 为 \u0026quot;none\u0026quot;（默认值）时，Blackhole 将直接关闭连接。\n当 type 为 \u0026quot;http\u0026quot; 时，Blackhole 会发回一个简单的 HTTP 403 数据包，然后关闭连接。\n"},{"uri":"https://xtls.github.io/about/","title":"Project X","tags":[],"description":"Project X 的文档.","content":" Project X originates from XTLS protocol, provides a set of network tools such as Xray-core and Xray-flutter.\n Xray-core 是 v2ray-core 的超集，含更好的整体性能和 XTLS 等一系列增强，且完全兼容 v2ray-core 的功能及配置。  只有一个可执行文件，含 ctl 的功能，run 为默认指令 配置上完全兼容，环境变量和 API 对应要改为以 XRAY_ 开头 全平台开放了裸协议的 ReadV 提供完整的 VLESS \u0026amp; Trojan XTLS 支持，均有 ReadV 提供了 XTLS 多种流控模式, 性能一骑绝尘! “配置兼容，整体更好”\n    Xray-flutter 是一个优雅的跨平台图形界面工具.In progress   开发者   It doesn’t matter who we are, what matters is that we will keep riding and not look back. 帮助Xray变得更强  欢迎帮助Xray变得更强！\n 🖥️ 帮助开发和测试 Xray, 提交高质量的 Pull request. 📩 在Github issues或讨论区提交建设性或有意义的issue/讨论. 📝 写下您的使用心得并提交至 Xray 的文档网站. 💬 在Telegram群帮助群友/灌水. \u0026hellip;事实上,每一份给予 Xray 的正能量都会让Xray变得更强大   Telegram    Project X 交流群\n 交流群可在底线之上随便水，不要撕逼，没有滥权。 有问题尽管随便问，知道的尽量回答。 禁政治，禁NSFW    Project X 频道\n 发布Project X的最新资讯     致谢   感谢所有人的支持！ 感谢各类脚本、Docker 镜像、客户端支持\u0026hellip;感谢所有帮忙完善生态的大佬们！ 感谢为 Xray 网站和文档添砖加瓦的朋友们. 感谢提出有意义的建议和意见的朋友们. 感谢Telegram群每一位帮助群友的朋友们.   License  Mozilla Public License Version 2.0 Stargazers over time  Project X 的 GitHub 主仓库 Xray-core 已获 1800+ stars；Project X 群人数破2500，频道订阅数 1000\n\n"},{"uri":"https://xtls.github.io/config/transports/tcp/","title":"TCP","tags":[],"description":"Project X 的文档.","content":"TCP 传输模式是目前推荐使用的传输模式之一.\n可以和各种协议有多种组合模式.\nTcpObject  TcpObject 对应传输配置的 tcpSettings 项。\n{ \u0026#34;acceptProxyProtocol\u0026#34;: false, \u0026#34;header\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; } }  acceptProxyProtocol: true | false\n 仅用于 inbound，指示是否接收 PROXY protocol。\nPROXY protocol 专用于传递请求的真实来源 IP 和端口，若你不了解它，请先忽略该项。\n常见的反代软件（如 HAProxy、Nginx）都可以配置发送它，VLESS fallbacks xver 也可以发送它。\n填写 true 时，最底层 TCP 连接建立后，请求方必须先发送 PROXY protocol v1 或 v2，否则连接会被关闭。\n默认值为 false。\nheader: NoneHeaderObject | HttpHeaderobject\n 数据包头部伪装设置，默认值为 NoneHeaderObject。\nTIP\nHTTP 伪装无法被其它 HTTP 服务器（如 Nginx）分流，但可以被 VLESS fallbacks path 分流。\n \nNoneHeaderObject  不进行伪装\n{ \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }  type: \u0026ldquo;none\u0026rdquo;\n 指定不进行伪装\n\nHttpHeaderObject  HTTP 伪装配置必须在对应的入站出站连接上同时配置，且内容必须一致。\n{ \u0026#34;type\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;request\u0026#34;: {}, \u0026#34;response\u0026#34;: {} }  type: \u0026ldquo;http\u0026rdquo;\n 指定进行 HTTP 伪装\nrequest: HTTPRequestObject\n HTTP 请求\nresponse: HTTPResponseObject\n HTTP 响应\n\nHTTPRequestObject  { \u0026#34;version\u0026#34;: \u0026#34;1.1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;path\u0026#34;: [\u0026#34;/\u0026#34;], \u0026#34;headers\u0026#34;: { \u0026#34;Host\u0026#34;: [\u0026#34;www.baidu.com\u0026#34;, \u0026#34;www.bing.com\u0026#34;], \u0026#34;User-Agent\u0026#34;: [ \u0026#34;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36\u0026#34;, \u0026#34;Mozilla/5.0 (iPhone; CPU iPhone OS 10_0_2 like Mac OS X) AppleWebKit/601.1 (KHTML, like Gecko) CriOS/53.0.2785.109 Mobile/14A456 Safari/601.1.46\u0026#34; ], \u0026#34;Accept-Encoding\u0026#34;: [\u0026#34;gzip, deflate\u0026#34;], \u0026#34;Connection\u0026#34;: [\u0026#34;keep-alive\u0026#34;], \u0026#34;Pragma\u0026#34;: \u0026#34;no-cache\u0026#34; } }  version: string\n HTTP 版本，默认值为 \u0026quot;1.1\u0026quot;。\nmethod: string\n HTTP 方法，默认值为 \u0026quot;GET\u0026quot;。\npath: [ string ]\n 路径，一个字符串数组。默认值为 [\u0026quot;/\u0026quot;]。当有多个值时，每次请求随机选择一个值。\nheaders: map{ string, [ string ]}\n HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是一个数组。\n每次请求会附上所有的键，并随机选择一个对应的值。默认值见上方示例。\n\nHTTPResponseObject  { \u0026#34;version\u0026#34;: \u0026#34;1.1\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;200\u0026#34;, \u0026#34;reason\u0026#34;: \u0026#34;OK\u0026#34;, \u0026#34;headers\u0026#34;: { \u0026#34;Content-Type\u0026#34;: [\u0026#34;application/octet-stream\u0026#34;, \u0026#34;video/mpeg\u0026#34;], \u0026#34;Transfer-Encoding\u0026#34;: [\u0026#34;chunked\u0026#34;], \u0026#34;Connection\u0026#34;: [\u0026#34;keep-alive\u0026#34;], \u0026#34;Pragma\u0026#34;: \u0026#34;no-cache\u0026#34; } }  version: string\n HTTP 版本，默认值为 \u0026quot;1.1\u0026quot;。\nstatus: string\n HTTP 状态，默认值为 \u0026quot;200\u0026quot;。\nreason: string\n HTTP 状态说明，默认值为 \u0026quot;OK\u0026quot;。\nheaders: map {string, [ string ]}\n HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是一个数组。\n每次请求会附上所有的键，并随机选择一个对应的值。默认值见上方示例。\n"},{"uri":"https://xtls.github.io/develop/protocols/vless/","title":"VLESS 协议","tags":[],"description":"Project X 的文档.","content":"VLESS 是一个无状态的轻量传输协议，可以作为 Xray 客户端和服务器之间的桥梁。\n\nIn progress\n"},{"uri":"https://xtls.github.io/qa/start/","title":"下载和安装中的问题","tags":[],"description":"Project X 的文档.","content":" Q: 我想自己下载安装包, 可是release好多文件, 我要下载哪一个呢?请先使用谷歌搜索您的设备型号, 确认您设备使用的架构, 然后下载对应的版本.  Q: 我在VPS上运行了脚本, 好像安装好了, 可是似乎没反应?/系统服务不能启动?/我也不知道有没有安装成功?使用命令 \u0026lsquo;journalctl -u xray\u0026rsquo; 查看 xray 的相关日志。\n或者\n终端命令行中执行 \u0026lsquo;xray run -c 您的config.json文件路径\u0026rsquo; 来查看相关信息\n Q: 配置文件在哪个目录。谢谢!这位同学你可真的是不看文档, 不过因为你很有礼貌, 我可以告诉你在这里有所有文件的安装位置\n "},{"uri":"https://xtls.github.io/guide/install/","title":"下载安装","tags":[],"description":"Project X 的文档.","content":"平台支持  Xray 在以下平台中可用：\n Windows 7 及之后版本（x86 / amd64 / arm32）； macOS 10.10 Yosemite 及之后版本（amd64）； Linux 2.6.23 及之后版本（x86 / amd64 / arm / arm64 / mips64 / mips / ppc64 / s390x / riscv64）；  包括但不限于 Debian 7 / 8、Ubuntu 12.04 / 14.04 及后续版本、CentOS 7 / 8、Arch Linux 等；   FreeBSD (x86 / amd64)； OpenBSD (x86 / amd64)； Dragonfly BSD (amd64)；  \n下载 Xray  预编译的二进制 ZIP 格式压缩包可在 Github Releases 中找到。\n下载对应平台的压缩包，解压后即可使用。\n\n验证安装包  Xray 提供两种验证方式：\n ZIP 压缩包的 SHA1 / SHA256 摘要: In progress 可复现构建：In progress  \nWindows 安装方式  在 Github Releases 下载适用于 Windows 平台的 ZIP 压缩包，解压后可得到可执行文件 xray.exe，然后通过命令行带参数运行 即可 通过 Scoop 包管理器安装：In progress 通过 Chocolatey 包管理器安装：In progress  \nmacOS 安装方式  在 Github Releases 下载适用于 macOS 平台的 ZIP 压缩包，解压后可得到可执行文件 xray，然后通过命令行带参数运行 即可 通过 Homebrew 包管理器安装：In progress  \nLinux 安装方式  安装脚本    Linux Script\n Xray-install Xray-script    One Click\n ProxySU Xray-agent    Magisk\n Xray4Magisk Xray_For_Magisk    Linux 发行版包管理器  Linux 发行版 Xray 包（可通过发行版相应的包管理器安装）：\n Debian：In progress Arch Linux：In progress  Linuxbrew 包管理器  In progress\n\nDocker 安装方式   teddysun/xray Xray-docker  Docker image 的文件结构   /etc/xray/config.json：配置文件 /usr/bin/xray：Xray 主程序 /usr/local/share/xray/geoip.dat：IP 数据文件 /usr/local/share/xray/geosite.dat：域名数据文件  \n更多更多\u0026hellip;  您可以点击 传送至众多大佬集结区的任意门 获取更多资源\nFAQ In progress\n"},{"uri":"https://xtls.github.io/about/new/","title":"大史记","tags":[],"description":"Project X 的文档.","content":"2021.01.05   文档网站正在悄悄的进行着某些神秘的变化。。。，🙊🙊🙊  \n2021.01.03   文档仓库第一个PR。🎉\n透明代理（TProxy）配置教程  ，感谢@BioniCosmos tg群突破2500。  \n2021.01.01  【祝大家新年快乐，嗨皮牛耶！】🎆🎇🎆\nv1.2.0  🎁在元旦的最后几分钟，v1.2.0它来了，带着周五必更的惯例，带着各位贡献大佬的心血以及 @rprxx 的黑眼圈，不负众望的来了!\n 圣诞礼物v1.1.5后的元旦礼物🎁，游戏玩家大福利，全面 FullCone。 （UDP还会继续增强！） 如果你已经拆过圣诞礼物，这次还有比圣诞礼物更精美的包装和小糖果哦。（同样不用问，更新品尝就对了） （不，下面不是广告，是里程碑。） Xray 是有史以来第一个不受限制的多协议平台：只需 Xray 即可解决问题，无需借力其它实现。  一人扛起了所有！支持各大主流协议！ 一骑绝尘的性能! 日趋完善的功能! 可怕的生命力与社区亲和力！   Xray 将继续保持前行！ 因此 Xray 需要更多的英雄！！！ PS：请品，请细品release notes每一句。似乎有一个小秘密小彩蛋 （啊，有人敲门\u0026hellip;我一会和你们说）  \n2020.12.29 透明代理的游戏玩家利好！ Xray-core tproxy 入站， socks出站 UDP FullCone 测试版, TG群火热测试中\n\n2020.12.25  圣诞节快乐！\nv1.1.5   游戏玩家的圣诞礼物！你可以用xray爽快的打游戏啦！因为有了 SS/trojan UDP fullcone 你可以用你喜欢的格式写配置文件了，比如yaml，比如toml\u0026hellip; （VLESS 的 UDP fullcone和更多增强很快就到！） 无须再担心证书验证被墙，OCSP stapling 已经上线! kirin带来了一大波 脚本更新.脚本在此 还有更多美味小樱桃！（不用问，更新品尝就对了）  \n2020.12.24 因为某些不可描述的原因，Xray 的文档网站已在发布日前偷跑上线。\n网址为：没错你正在看的就是\n大家可以查阅各种内容也欢迎纠错/提出建议（可发往文档github仓库的issue区）\n文档网站需要不断完善和增加内容，以及完善设计。\n因此更欢迎大家一起为文档建设添砖加瓦。\n文档的仓库\n仓库的readme中有简略教程说明如何帮助xray改进文档网站.\n欢迎大家查看，纠错，修改，增加心得。\n\n2020.12.23 Xray-core Shadowsocks UDP FullCone 测试版, TG群火热测试中\n\n2020.12.21   Project X 群人数 2000+ 群消息(含游戏群) 日均破万  \n2020.12.18  v1.1.4   更低的启动内占用和内存使用优化 随意定制的 TLS 提高你的SSL评级 支持 XTLS 入站的 Splice 以及支持 trojan 的 XTLS 还有在您路由器上使用的Splice最佳使用模式建议  \n2020.12.17  鉴于日益增长群人数和游戏需求, 开启了TG游戏群\n\n2020.12.15  安装脚本dev分支开启, 持续更新功能中.\n\n2020.12.11  v1.1.3   完整版本的 REDIRECT 透明代理模式. 软路由 splice 流控模式的优化建议.  \n2020.12.06  v1.1.2   流控增加 splice 模式, Linux限定, 性能一骑绝尘. 增强了 API 兼容  \n2020.12.04  增加 splice 模式\n\n2020.11.27   Project X 的 GitHub 主仓库 Xray-core 已获 500+ stars 登上了 GitHub Trending Project X 群人数破千，频道订阅数 500+  \n2020.11.25  v1.0.0  Xray的第一个版本.\n 基于 v2ray-core 修改而来，改动较大 全面增强, 性能卓越, 完全兼容  \n2020.11.23  project X start\n"},{"uri":"https://xtls.github.io/documents/level-0/","title":"小小白白话文","tags":[],"description":"小小白白话文","content":" 这个章节是【从零开始】的基础课，新来的同学好好看好好学哦 Made with ❤️ by @ricuhkaen\n In progress 【第1章】 前言罗嗦篇 - 机场还是自建？这是个问题\n【第2章】 原料准备篇 - 工欲善其事，必先利其器\n【第3章】 远程登录篇 - 一桥飞架南北，天堑变通途\n【第4章】 安全防护篇 - 安全不注意，亲人两行泪 \n【第5章】 网站建设篇  coming soon\n "},{"uri":"https://xtls.github.io/develop/intro/","title":"开发手册","tags":[],"description":"Project X 的文档.","content":" 如果您想帮助 Xray 开发, 请详细阅读本章节中的内容 编译 Xray 支持各种平台, 您可以在多种平台上自行进行交叉编译.\n请点击编译以查看具体编译相关内容\n 设计思路 Xray 内核提供了一个平台，在其之上可以进二次开发 这个章节阐述了Xray的设计目标和架构.\n请点击设计思路以了解Xray的设计目标和架构.\n 开发规范 这个章节阐述了获取代码,进行开发,提交PR的流程中需要遵循的准则, 以及相关的编码规范\n请点击开发规范查看Xray开发中应遵循的准则.\n  \n协议详解 Xray 用到了很多种协议, 您可以通过各种途径获得协议的详细描述.\n请点击协议详解以查看相关协议的详细剖析\n  "},{"uri":"https://xtls.github.io/config/log/","title":"日志配置","tags":[],"description":"Project X 的文档.","content":"日志配置，控制 Xray输出日志的方式.\nXray 有两种日志, 访问日志和错误日志, 你可以分别配置两种日志的输出方式.\nLogObject  LogObject 对应配置文件的 log 项。\n{ \u0026#34;log\u0026#34;: { \u0026#34;access\u0026#34;: \u0026#34;文件地址\u0026#34;, \u0026#34;error\u0026#34;: \u0026#34;文件地址\u0026#34;, \u0026#34;loglevel\u0026#34;: \u0026#34;warning\u0026#34; } }  access: string\n 访问日志的文件地址，其值是一个合法的文件地址，如\u0026quot;/var/log/Xray/access.log\u0026quot;（Linux）或者\u0026quot;C:\\\\Temp\\\\Xray\\\\_access.log\u0026quot;（Windows）。当此项不指定或为空值时，表示将日志输出至 stdout。\n 特殊值none，即关闭 access log。  error: string\n 错误日志的文件地址，其值是一个合法的文件地址，如\u0026quot;/var/log/Xray/error.log\u0026quot;（Linux）或者\u0026quot;C:\\\\Temp\\\\Xray\\\\_error.log\u0026quot;（Windows）。当此项不指定或为空值时，表示将日志输出至 stdout。\n 特殊值none，即关闭 error log。  loglevel: \u0026ldquo;debug\u0026rdquo; | \u0026ldquo;info\u0026rdquo; | \u0026ldquo;warning\u0026rdquo; | \u0026ldquo;error\u0026rdquo; | \u0026ldquo;none\u0026rdquo;\n error 日志的级别, 指示 error 日志需要记录的信息. 默认值为 \u0026quot;warning\u0026quot;。\n \u0026quot;debug\u0026quot;：调试程序时用到的输出信息。同时包含所有 \u0026quot;info\u0026quot; 内容。 \u0026quot;info\u0026quot;：运行时的状态信息等，不影响正常使用。同时包含所有 \u0026quot;warning\u0026quot; 内容。 \u0026quot;warning\u0026quot;：发生了一些并不影响正常运行的问题时输出的信息，但有可能影响用户的体验。同时包含所有 \u0026quot;error\u0026quot; 内容。 \u0026quot;error\u0026quot;：Xray 遇到了无法正常运行的问题，需要立即解决。 \u0026quot;none\u0026quot;：不记录任何内容。  "},{"uri":"https://xtls.github.io/develop/intro/compile/","title":"编译","tags":[],"description":"Project X 的文档.","content":"前序工作  Xray 使用 Golang 作为主要编程语言。\n 下载 Golang: Downloads 安装 Golang: install  important请使用 Golang 1.15 以上版本。\n \n编译  拉取 Xray 源代码和依赖  在安装了git的环境下, 只需要执行以下命令即可clone一份完整的Xray-core代码:\ngit clone https://github.com/XTLS/Xray-core.git \n注意事项  在无法正常访问 Google 的网络环境，依赖可能无法被正常拉取，可以通过各种手段代理解决.\n比如可以通过设置 GOPROXY：\ngo env -w GOPROXY=https://goproxy.io,direct \n手工编译  important本小节的命令需要在 Xray 项目根目录内运行。\n 在 Linux 环境下, 只需执行以下命令, 即可在当前目录下生成刚构建的 xray 可执行文件。\nCGO_ENABLED=0 go build -o xray -trimpath -ldflags \u0026#34;-s -w -buildid=\u0026#34; ./main \n交叉编译  构建其他 CPU 架构、其他系统（Windows/macOS）的可执行文件需要设置 GOOS 和 GOARCH 两个环境变量为目标平台/架构.\n可以参考 Golang 相关文档 比如Building Windows Go programs on Linux。\n如下面代码即可以构建可运行在 Windows 64 位系统的 xray.exe 可执行文件：\nCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -o xray.exe -trimpath -ldflags \u0026#34;-s -w -buildid=\u0026#34; ./main  TIP\n执行 go tool dist list 可以查看所有支持的系统与架构。 某些架构还需要控制其它环境变量，如 arm 的 GOARM，用于设置运行时 CPU 浮点协处理器的版本。\n "},{"uri":"https://xtls.github.io/documents/level-0/ch02-preparation/","title":"【第2章】原料准备篇","tags":[],"description":"小小白白话文","content":"这一章比较特殊，因为涉及到金钱交易行为，本文基于项目的中立立场，不做具体的推荐。我能做的，是告诉你具体需要准备哪些东西。\n2.1 获取一台VPS 你需要获取一台健康的、IP没有被墙的VPS，并在管理后台做下面这些基础准备：\n 在VPS的后台安装 Debian 10 64bit 系统 小本本记下VPS的IP地址（本文会用 \u0026quot;100.200.300.400\u0026quot; 来表示，注意： 这是一个故意写错的非法IP，请替换成你的真实IP） 小本本记下VPS的SSH远程登陆端口(Port) 小本本记下SSH远程登录的用户名和密码  购买VPS是一个比较复杂的事情，建议先去学习一下相关知识，选择适合自己的经济能力和线路需求的即可。另外可以选择薅一些国际大厂的羊毛（比如甲骨文和谷歌提供的永久免费或限时免费的套餐）。总之，务必量力而行。\n关于选择 Debian 10 作为操作系统，这里稍微多说一句：不管你在网上听说了什么，不管哪个大神告诉你XXX版的Linux更好、XXX版的Linux更牛，这些Linux的派系之争跟现在的你半毛钱关系也没有！使用 Debian 10 足以让你的VPS服务器在安全、稳健运行的同时得到足够的优化（如cloud专用内核、及时的bbr支持等）。等你对Linux熟悉之后，再回头去尝试其他的Linux发行版也不迟。\n2.2 获取一个心仪的域名 你需要获取一个域名、并在DNS设置中添加一条A记录，指向你VPS的IP地址\n 请选择靠谱的国际域名服务商。选择一些常见的域名后缀就行，注意不要用 .cn 后缀。 在DNS设置中，添加一条指向你VPS的IP地址的A记录（A记录的名字可以随便起，本文会用 \u0026quot;a-name\u0026quot; 来表示。完整的域名则会用 \u0026quot;二级域名.你的域名.com\u0026quot; 或者 \u0026quot;a-name.yourdomain.com\u0026quot; 来表示，注意： 这不是一个真实可用的网址，请替换成你的真实网址）。效果如下图：  2.3 你本地电脑上需要安装的软件  SSH远程登录工具 (Windows: PuTTY, macOS/Linux: Terminal) 远程文件拷贝工具（Windows: WinSCP, macOS/Linux: Terminal） 靠谱的文本编辑器 (Windows/macOS/Linux: VSCode)  2.4 你的进度 如果上面的原材料你都准备好了的话，你已经拿到了开启新世界大门的钥匙。那还等什么，然我们快点进入下一章，走进这扇门吧！\nPROGRESS⬛⬛⬜⬜⬜⬜⬜⬜ 25%\n "},{"uri":"https://xtls.github.io/config/api/","title":"API接口","tags":[],"description":"Project X 的文档.","content":"API接口配置提供了一些基于 gRPC的 API 接口供远程调用。\n可以通过api配置模块开启接口. 当api配置开启时，Xray 会自建一个出站代理， 须手动将所有的 API 入站连接通过 路由规则配置 指向这一出站代理。\n请参考本节中的相关配置\n大多数用户并不会用到此 API，新手可以直接忽略这一项。\n ApiObject  ApiObject 对应配置文件的 api 项。\n{ \u0026#34;api\u0026#34;: { \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34;, \u0026#34;services\u0026#34;: [ \u0026#34;HandlerService\u0026#34;, \u0026#34;LoggerService\u0026#34;, \u0026#34;StatsService\u0026#34; ] } }  tag: string\n 出站代理标识。\nservices: [string]\n 开启的 API 列表，可选的值见 API 列表。\n\n相关配置  可以在 inbounds 配置中增加一个 api 的 inbound\n\u0026#34;inbounds\u0026#34;: [ { \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 10085, \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34; }, \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; } ] 在路由配置中增加针对api inbound的路由规则\n\u0026#34;routing\u0026#34;: { \u0026#34;settings\u0026#34;: { \u0026#34;rules\u0026#34;: [ { \u0026#34;inboundTag\u0026#34;: [ \u0026#34;api\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;api\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; } ] }, \u0026#34;strategy\u0026#34;: \u0026#34;rules\u0026#34; } \n支持的 API 列表  HandlerService 一些对于入站出站代理进行修改的 API，可用的功能如下：\n 添加一个新的入站代理； 添加一个新的出站代理； 删除一个现有的入站代理； 删除一个现有的出站代理； 在一个入站代理中添加一个用户（仅支持 VMess、VLESS、Trojan）； 在一个入站代理中删除一个用户（仅支持 VMess、VLESS、Trojan）；  LoggerService 支持对内置 Logger 的重启，可配合 logrotate 进行一些对日志文件的操作。\nStatsService 内置的数据统计服务，详见 统计信息。\n"},{"uri":"https://xtls.github.io/config/outbound-protocols/dns/","title":"DNS","tags":[],"description":"Project X 的文档.","content":"DNS 是一个出站协议，主要用于拦截和转发 DNS 查询。\n此出站协议只能接收 DNS 流量（包含基于 UDP 和 TCP 协议的查询），其它类型的流量会导致错误。\n在处理 DNS 查询时，此出站协议会将 IP 查询（即 A 和 AAAA）转发给内置的 DNS 服务器。其它类型的查询流量将被转发至它们原本的目标地址。\nOutboundConfigurationObject  { \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;1.1.1.1\u0026#34;, \u0026#34;port\u0026#34;: 53 }  network: \u0026ldquo;tcp\u0026rdquo; | \u0026ldquo;udp\u0026rdquo;\n 修改 DNS 流量的传输层协议，可选的值有 \u0026quot;tcp\u0026quot; 和 \u0026quot;udp\u0026quot;。当不指定时，保持来源的传输方式不变。\naddress: address\n 修改 DNS 服务器地址。当不指定时，保持来源中指定的地址不变。\nport: number\n 修改 DNS 服务器端口。当不指定时，保持来源中指定的端口不变。\n\nDNS配置实例  In progress\n"},{"uri":"https://xtls.github.io/config/inbound-protocols/dokodemo/","title":"Dokodemo door","tags":[],"description":"Project X 的文档.","content":"Dokodemo door（任意门）可以监听一个本地端口，并把所有进入此端口的数据发送至指定服务器的一个端口，从而达到端口映射的效果。\nInboundConfigurationObject  { \u0026#34;address\u0026#34;: \u0026#34;8.8.8.8\u0026#34;, \u0026#34;port\u0026#34;: 53, \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;timeout\u0026#34;: 0, \u0026#34;followRedirect\u0026#34;: false, \u0026#34;userLevel\u0026#34;: 0 }  address: address\n 将流量转发到此地址。可以是一个 IP 地址，形如 \u0026quot;1.2.3.4\u0026quot;，或者一个域名，形如 \u0026quot;xray.com\u0026quot;。字符串类型。\n当 followRedirect（见下文）为 true 时，address 可为空。\nport: number\n 将流量转发到目标地址的指定端口，范围 [1, 65535]，数值类型。必填参数。\nnetwork: \u0026ldquo;tcp\u0026rdquo; | \u0026ldquo;udp\u0026rdquo; | \u0026ldquo;tcp,udp\u0026rdquo;\n 可接收的网络协议类型。比如当指定为 \u0026quot;tcp\u0026quot; 时，仅会接收 TCP 流量。默认值为 \u0026quot;tcp\u0026quot;。\ntimeout: number\n 连接空闲的时间限制。单位为秒。默认值为 300。处理一个连接时，如果在 timeout 时间内，没有任何数据被传输，则中断该连接。\nfollowRedirect: true | false\n 当值为 true 时，dokodemo-door 会识别出由 iptables 转发而来的数据，并转发到相应的目标地址。\n可参考 传输配置 中的 tproxy 设置。\nuserLevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n\n透明代理配置样例  此部分请参考透明代理（TProxy）配置教程。\n"},{"uri":"https://xtls.github.io/develop/protocols/vmess/","title":"VMess 协议","tags":[],"description":"Project X 的文档.","content":"VMess 是一个加密传输协议，可以作为 Xray 客户端和服务器之间的桥梁。\n\n版本  当前版本号为 1。\n\n依赖  底层协议  VMess 是一个基于 TCP 的协议，所有数据使用 TCP 传输。\n\n用户 ID  ID 等价于 UUID，是一个 16 字节长的随机数，它的作用相当于一个令牌（Token）。 一个 ID 形如：de305d54-75b4-431b-adb2-eb6b9e546014，几乎完全随机，可以使用任何的 UUID 生成器来生成，比如这个。\n用户 ID 可在配置文件中指定。\n\n函数   MD5: MD5 函数  输入参数为任意长度的 byte 数组 输出为一个 16 byte 的数组   HMAC: HMAC 函数  输入参数为：  H：散列函数 K：密钥，任意长度的 byte 数组 M：消息，任意长度的 byte 数组     Shake: SHA3-Shake128 函数  输入参数为任意长度的字符串 输出为任意长度的字符串    \n通讯过程  VMess 是一个无状态协议，即客户端和服务器之间不需要握手即可直接传输数据，每一次数据传输对之前和之后的其它数据传输没有影响。\nVMess 的客户端发起一次请求，服务器判断该请求是否来自一个合法的客户端。如验证通过，则转发该请求，并把获得的响应发回给客户端。\nVMess 使用非对称格式，即客户端发出的请求和服务器端的响应使用了不同的格式。\n\n客户端请求     16 字节 X 字节 余下部分     认证信息 指令部分 数据部分    \n认证信息  认证信息是一个 16 字节的哈希（hash）值，它的计算方式如下：\n H = MD5 K = 用户 ID (16 字节) M = UTC 时间，精确到秒，取值为当前时间的前后 30 秒随机值(8 字节, Big Endian) Hash = HMAC(H, K, M)  \n指令部分  指令部分经过 AES-128-CFB 加密：\n Key：MD5(用户 ID + []byte(\u0026lsquo;c48619fe-8f02-49e0-b9e9-edf763e17e21\u0026rsquo;)) IV：MD5(X + X + X + X)，X = []byte(认证信息生成的时间) (8 字节, Big Endian)     1 字节 16 字节 16 字节 1 字节 1 字节 4 位 4 位 1 字节 1 字节 2 字节 1 字节 N 字节 P 字节 4 字节     版本号 Ver 数据加密 IV 数据加密 Key 响应认证 V 选项 Opt 余量 P 加密方式 Sec 保留 指令 Cmd 端口 Port 地址类型 T 地址 A 随机值 校验 F    选项 Opt 细节：（当某一位为 1 时，表示该选项启用）\n   0 1 2 3 4 5 6 7     X X X X X M R S    其中：\n 版本号 Ver：始终为 1； 数据加密 IV：随机值； 数据加密 Key：随机值； 响应认证 V：随机值； 选项 Opt：  S (0x01)：标准格式的数据流（建议开启）； R (0x02)：客户端期待重用 TCP 连接（Xray 2.23+ 弃用）；  只有当 S 开启时，这一项才有效；   M (0x04)：开启元数据混淆（建议开启）；  只有当 S 开启时，这一项才有效； 当其项开启时，客户端和服务器端需要分别构造两个 Shake 实例，分别为 RequestMask = Shake(请求数据 IV), ResponseMask = Shake(响应数据 IV)。   X：保留   余量 P：在校验值之前加入 P 字节的随机值； 加密方式：指定数据部分的加密方式，可选的值有：  0x00：AES-128-CFB； 0x01：不加密； 0x02：AES-128-GCM； 0x03：ChaCha20-Poly1305；   指令 Cmd：  0x01：TCP 数据； 0x02：UDP 数据；   端口 Port：Big Endian 格式的整型端口号； 地址类型 T：  0x01：IPv4 0x02：域名 0x03：IPv6   地址 A：  当 T = 0x01 时，A 为 4 字节 IPv4 地址； 当 T = 0x02 时，A 为 1 字节长度（L） + L 字节域名； 当 T = 0x03 时，A 为 16 字节 IPv6 地址；   校验 F：指令部分除 F 外所有内容的 FNV1a hash；  \n数据部分  当 Opt(S) 开启时，数据部分使用此格式。实际的请求数据被分割为若干个小块，每个小块的格式如下。服务器校验完所有的小块之后，再按基本格式的方式进行转发。\n   2 字节 L 字节     长度 L 数据包    其中：\n 长度 L：Big Endian 格式的整型，最大值为 2^14；  当 Opt(M) 开启时，L 的值 = 真实值 xor Mask。Mask = (RequestMask.NextByte() \u0026laquo; 8) + RequestMask.NextByte()；   数据包：由指定的加密方式加密过的数据包；  在传输结束之前，数据包中必须有实际数据，即除了长度和认证数据之外的数据。当传输结束时，客户端必须发送一个空的数据包，即 L = 0（不加密） 或认证数据长度（有加密），来表示传输结束。\n按加密方式不同，数据包的格式如下：\n 不加密：  L 字节：实际数据；   AES-128-CFB：整个数据部分使用 AES-128-CFB 加密  4 字节：实际数据的 FNV1a hash； L - 4 字节：实际数据；   AES-128-GCM：Key 为指令部分的 Key，IV = count (2 字节) + IV (10 字节)。count 从 0 开始递增，每个数据包加 1；IV 为 指令部分 IV 的第 3 至第 12 字节。  L - 16 字节：实际数据； 16 字节：GCM 认证信息   ChaCha20-Poly1305：Key = MD5(指令部分 Key) + MD5(MD5(指令部分 Key))，IV = count (2 字节) + IV (10 字节)。count 从 0 开始递增，每个数据包加 1；IV 为 指令部分 IV 的第 3 至第 12 字节。  L - 16 字节：实际数据； 16 字节：Poly1305 认证信息    \n服务器应答  应答头部数据使用 AES-128-CFB 加密，IV 为 MD5(数据加密 IV)，Key 为 MD5(数据加密 Key)。实际应答数据视加密设置不同而不同。\n   1 字节 1 字节 1 字节 1 字节 M 字节 余下部分     响应认证 V 选项 Opt 指令 Cmd 指令长度 M 指令内容 实际应答数据    其中：\n 响应认证 V：必须和客户端请求中的响应认证 V 一致； 选项 Opt：  0x01：服务器端准备重用 TCP 连接（Xray 2.23+ 弃用）；   指令 Cmd：  0x01：动态端口指令   实际应答数据：  如果请求中的 Opt(S) 开启，则使用标准格式，否则使用基本格式。 格式均和请求数据相同。  当 Opt(M) 开启时，长度 L 的值 = 真实值 xor Mask。Mask = (ResponseMask.NextByte() \u0026laquo; 8) + ResponseMask.NextByte()；      \n动态端口指令     1 字节 2 字节 16 字节 2 字节 1 字节 1 字节     保留 端口 Port 用户 ID AlterID 用户等级 有效时间 T    其中：\n 端口 Port：Big Endian 格式的整型端口号； 有效时间 T：分钟数；  客户端在收到动态端口指令时，服务器已开放新的端口用于通信，这时客户端可以将数据发往新的端口。在 T 分钟之后，这个端口将失效，客户端必须重新使用主端口进行通信。\n\n注释   为确保向前兼容性，所有保留字段的值必须为 0。  "},{"uri":"https://xtls.github.io/config/transports/websocket/","title":"WebSocket","tags":[],"description":"Project X 的文档.","content":"使用标准的 WebSocket 来传输数据。\nWebSocket 连接可以被其它 HTTP 服务器（如 Nginx）分流，也可以被 VLESS fallbacks path 分流。\nTIP\nWebsocket 会识别 HTTP 请求的 X-Forwarded-For 头来覆写流量的源地址，优先级高于 PROXY protocol。\n WebSocketObject WebSocketObject 对应传输配置的 wsSettings 项。\n{ \u0026#34;acceptProxyProtocol\u0026#34;: false, \u0026#34;path\u0026#34;: \u0026#34;/\u0026#34;, \u0026#34;headers\u0026#34;: { \u0026#34;Host\u0026#34;: \u0026#34;xray.com\u0026#34; } }  acceptProxyProtocol: true | false\n 仅用于 inbound，指示是否接收 PROXY protocol。\nPROXY protocol 专用于传递请求的真实来源 IP 和端口，若你不了解它，请先忽略该项。\n常见的反代软件（如 HAProxy、Nginx）都可以配置发送它，VLESS fallbacks xver 也可以发送它。\n填写 true 时，最底层 TCP 连接建立后，请求方必须先发送 PROXY protocol v1 或 v2，否则连接会被关闭。\npath string\n WebSocket 所使用的 HTTP 协议路径，默认值为 \u0026quot;/\u0026quot;。\nheaders: map {string: string}\n 自定义 HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是字符串。\n默认值为空。\n"},{"uri":"https://xtls.github.io/documents/level-1/","title":"入门技巧","tags":[],"description":"Project X 的文档.","content":" 这个章节是入门级的Xray使用心得分享, 如果您想掌握Xray的使用技巧, 可以从这里开始  Xray的工作模式\n 本文介绍了 Xray 的两种基本工作模式和基本原理\n"},{"uri":"https://xtls.github.io/develop/protocols/","title":"协议详解","tags":[],"description":"Project X 的文档.","content":" 这个章节包含了 Xray 中所使用协议的详细剖析 \n vless\n VLESS 是一个无状态的轻量传输协议，可以作为 Xray 客户端和服务器之间的桥梁。 VMess\n VMess 是一个加密传输协议，可以作为 Xray 客户端和服务器之间的桥梁。 Mux.Cool\n Mux.Cool 协议是一个多路复用传输协议，用于在一条已建立的数据流中传输多个各自独立的数据流。 mKCP\n mKCP 是流式传输协议，由 KCP 协议修改而来，可以按顺序传输任意的数据流。\n"},{"uri":"https://xtls.github.io/guide/","title":"快速入门","tags":[],"description":"Project X 的文档.","content":" 这个章节将告诉您如何用最简单的方式获得Xray,并且开始使用Xray. 下载安装 Xray支持各种平台,并且您可以从多种渠道和方式获得Xray的各种版本.\n请点击如何下载安装Xray以获取Xray\n 配置运行 下载并安装Xray后，只需对他进行配置即可使用.\n请点击如何配置运行Xray以学习最简单的配置方式.\n 命令参数 Xray有多种命令和参数可用,因此变得灵活和强大.\n请点击Xray的命令参数查看Xray的更多命令和参数用法.\n  \n使用文档 您正在查看的是 Project X 的文档网站. 您可以了解更多网站的使用方式, 或是帮助我们改进文档质量.\n请点击使用文档进一步查看相关内容\n    "},{"uri":"https://xtls.github.io/develop/intro/design/","title":"设计思路","tags":[],"description":"Project X 的文档.","content":"设计目标   Xray 内核提供了一个平台，支持必要的网络代理功能，在其之上可以进二次开发，以提供更好的用户体验； 以跨平台为首要原则，以减少二次开发的成本；  \n架构  内核分为三层：应用层、代理层和传输层。\n每一层内包含数个模块，模块间互相独立，同类型的模块可无缝替换。\n\n应用层  应用层包含一些代理层中常用的功能，这些功能被抽象出来，以便在不同的代理模块中复用。\n应用层的模块应为纯软件实现，与硬件或平台相关的技术无关。\n重要模块列表：\n Dispatcher: 用于把入站代理所接收到的数据，传送给出站代理； Router: 路由模块，详见 路由配置； DNS: 内置的 DNS 服务器模块； Proxy Manager: 代理管理器；  \n代理层  代理层分为两部分：入站代理（Inbound Proxy）和出站代理（Outbound Proxy）。\n两部分相互独立，入站代理不依赖于某个特定的出站代理，反之亦然。\n入站代理   实现 proxy.Inbound 接口；  出站代理   实现 proxy.Outbound 接口；  \n传输层  传输层提供一些网络数据传输相关的工具模块。\n"},{"uri":"https://xtls.github.io/documents/level-2/tproxy/","title":"透明代理（TProxy）配置教程","tags":[],"description":"Project X 的文档.","content":"本配置基于TProxy 透明代理的新 V2Ray 白话文教程，加入了 Xray 的新特性，使用 VLESS + XTLS Splice 方案，并将旧教程中默认出站代理的分流方式改为默认出站直连，使用者请按照实际情况进行修改。\n本文中所有配置已在 Raspberry Pi 2B、Ubuntu 20.04 环境下测试成功，如在其它环境中使用请自行调整配置。\n开始之前 请检查您的设备是否有可用的网络连接，且服务端已经配置成功，客户端已经安装完毕。\n需注意的是，目前很多透明代理教程都会将 Linux 系统的 IP 转发打开，但这样会导致 Splice 性能下降。详情请参考大案牍术破案纪实第三篇\u0026ndash;我们是如何破解 Splice 性能下降甚至低于 Direct 之谜的。\n这里我想要补充的是，很多透明代理教程会使用 Netfilter 进行分流，使直连流量直接发出而不经过 Xray，这时必须开启 IP 转发；也有的教程，如本文，会将所有流量导入 Xray 之中，由 Xray 的路由模块进行分流，这时无需开启 IP 转发。\nXray 配置 { \u0026#34;log\u0026#34;: { \u0026#34;loglevel\u0026#34;: \u0026#34;warning\u0026#34;, \u0026#34;error\u0026#34;: \u0026#34;/var/log/xray/error.log\u0026#34;, \u0026#34;access\u0026#34;: \u0026#34;/var/log/xray/access.log\u0026#34; }, \u0026#34;inbounds\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;all-in\u0026#34;, \u0026#34;port\u0026#34;: 12345, \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;tcp,udp\u0026#34;, \u0026#34;followRedirect\u0026#34;: true }, \u0026#34;sniffing\u0026#34;: { \u0026#34;enabled\u0026#34;: true, \u0026#34;destOverride\u0026#34;: [ \u0026#34;http\u0026#34;, \u0026#34;tls\u0026#34; ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;sockopt\u0026#34;: { \u0026#34;tproxy\u0026#34;: \u0026#34;tproxy\u0026#34; } } } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;direct\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;UseIPv4\u0026#34; }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;sockopt\u0026#34;: { \u0026#34;mark\u0026#34;: 2 } } }, { \u0026#34;tag\u0026#34;: \u0026#34;proxy\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;vless\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;服务端域名\u0026#34;, \u0026#34;port\u0026#34;: 443, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;UUID\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-splice\u0026#34;, \u0026#34;encryption\u0026#34;: \u0026#34;none\u0026#34; } ] } ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;xtls\u0026#34;, \u0026#34;sockopt\u0026#34;: { \u0026#34;mark\u0026#34;: 2 } } }, { \u0026#34;tag\u0026#34;: \u0026#34;block\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;blackhole\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;response\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;http\u0026#34; } } }, { \u0026#34;tag\u0026#34;: \u0026#34;dns-out\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;dns\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;8.8.8.8\u0026#34; }, \u0026#34;proxySettings\u0026#34;: { \u0026#34;tag\u0026#34;: \u0026#34;proxy\u0026#34; }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;sockopt\u0026#34;: { \u0026#34;mark\u0026#34;: 2 } } } ], \u0026#34;dns\u0026#34;: { \u0026#34;hosts\u0026#34;: { \u0026#34;服务端域名\u0026#34;: \u0026#34;服务端 IP\u0026#34; }, \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;119.29.29.29\u0026#34;, \u0026#34;port\u0026#34;: 53, \u0026#34;domains\u0026#34;: [ \u0026#34;geosite:cn\u0026#34; ], \u0026#34;expectIPs\u0026#34;: [ \u0026#34;geoip:cn\u0026#34; ] }, { \u0026#34;address\u0026#34;: \u0026#34;223.5.5.5\u0026#34;, \u0026#34;port\u0026#34;: 53, \u0026#34;domains\u0026#34;: [ \u0026#34;geosite:cn\u0026#34; ], \u0026#34;expectIPs\u0026#34;: [ \u0026#34;geoip:cn\u0026#34; ] }, \u0026#34;8.8.8.8\u0026#34;, \u0026#34;1.1.1.1\u0026#34;, \u0026#34;https+local://doh.dns.sb/dns-query\u0026#34; ] }, \u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;IPIfNonMatch\u0026#34;, \u0026#34;rules\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;inboundTag\u0026#34;: [ \u0026#34;all-in\u0026#34; ], \u0026#34;port\u0026#34;: 53, \u0026#34;outboundTag\u0026#34;: \u0026#34;dns-out\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [ \u0026#34;119.29.29.29\u0026#34;, \u0026#34;223.5.5.5\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [ \u0026#34;8.8.8.8\u0026#34;, \u0026#34;1.1.1.1\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;proxy\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:category-ads-all\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;block\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:geolocation-!cn\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;proxy\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [ \u0026#34;geoip:jp\u0026#34;, \u0026#34;geoip:us\u0026#34;, \u0026#34;geoip:sg\u0026#34;, \u0026#34;geoip:hk\u0026#34;, \u0026#34;geoip:tw\u0026#34;, \u0026#34;109.239.140.0/24\u0026#34;, \u0026#34;14.102.250.18\u0026#34;, \u0026#34;14.102.250.19\u0026#34;, \u0026#34;149.154.164.0/22\u0026#34;, \u0026#34;149.154.168.0/22\u0026#34;, \u0026#34;149.154.172.0/22\u0026#34;, \u0026#34;174.142.105.153\u0026#34;, \u0026#34;50.7.31.230\u0026#34;, \u0026#34;67.220.91.15\u0026#34;, \u0026#34;67.220.91.18\u0026#34;, \u0026#34;67.220.91.23\u0026#34;, \u0026#34;69.65.19.160\u0026#34;, \u0026#34;72.52.81.22\u0026#34;, \u0026#34;85.17.73.31\u0026#34;, \u0026#34;91.108.4.0/22\u0026#34;, \u0026#34;91.108.56.0/22\u0026#34;, \u0026#34;91.108.56.0/23\u0026#34;, \u0026#34;108.177.120.94\u0026#34;, \u0026#34;108.177.120.0/24\u0026#34;, \u0026#34;172.217.0.0/16\u0026#34;, \u0026#34;74.125.0.0/16\u0026#34;, \u0026#34;23.246.0.0/18\u0026#34;, \u0026#34;37.77.184.0/21\u0026#34;, \u0026#34;45.57.0.0/17\u0026#34;, \u0026#34;64.120.128.0/17\u0026#34;, \u0026#34;66.197.128.0/17\u0026#34;, \u0026#34;108.175.32.0/20\u0026#34;, \u0026#34;192.173.64.0/18\u0026#34;, \u0026#34;198.38.96.0/19\u0026#34;, \u0026#34;198.45.48.0/20\u0026#34;, \u0026#34;173.245.48.0/20\u0026#34;, \u0026#34;103.21.244.0/22\u0026#34;, \u0026#34;103.22.200.0/22\u0026#34;, \u0026#34;103.31.4.0/22\u0026#34;, \u0026#34;141.101.64.0/18\u0026#34;, \u0026#34;108.162.192.0/18\u0026#34;, \u0026#34;190.93.240.0/20\u0026#34;, \u0026#34;188.114.96.0/20\u0026#34;, \u0026#34;197.234.240.0/22\u0026#34;, \u0026#34;198.41.128.0/17\u0026#34;, \u0026#34;162.158.0.0/15\u0026#34;, \u0026#34;104.16.0.0/12\u0026#34;, \u0026#34;172.64.0.0/13\u0026#34;, \u0026#34;131.0.72.0/22\u0026#34;, \u0026#34;144.220.0.0/16\u0026#34;, \u0026#34;52.124.128.0/17\u0026#34;, \u0026#34;54.230.0.0/16\u0026#34;, \u0026#34;54.239.128.0/18\u0026#34;, \u0026#34;52.82.128.0/19\u0026#34;, \u0026#34;99.84.0.0/16\u0026#34;, \u0026#34;204.246.172.0/24\u0026#34;, \u0026#34;54.239.192.0/19\u0026#34;, \u0026#34;70.132.0.0/18\u0026#34;, \u0026#34;13.32.0.0/15\u0026#34;, \u0026#34;205.251.208.0/20\u0026#34;, \u0026#34;13.224.0.0/14\u0026#34;, \u0026#34;13.35.0.0/16\u0026#34;, \u0026#34;204.246.164.0/22\u0026#34;, \u0026#34;204.246.168.0/22\u0026#34;, \u0026#34;71.152.0.0/17\u0026#34;, \u0026#34;216.137.32.0/19\u0026#34;, \u0026#34;205.251.249.0/24\u0026#34;, \u0026#34;99.86.0.0/16\u0026#34;, \u0026#34;52.46.0.0/18\u0026#34;, \u0026#34;52.84.0.0/15\u0026#34;, \u0026#34;204.246.173.0/24\u0026#34;, \u0026#34;130.176.0.0/16\u0026#34;, \u0026#34;205.251.200.0/21\u0026#34;, \u0026#34;204.246.174.0/23\u0026#34;, \u0026#34;64.252.128.0/18\u0026#34;, \u0026#34;205.251.254.0/24\u0026#34;, \u0026#34;143.204.0.0/16\u0026#34;, \u0026#34;205.251.252.0/23\u0026#34;, \u0026#34;204.246.176.0/20\u0026#34;, \u0026#34;13.249.0.0/16\u0026#34;, \u0026#34;54.240.128.0/18\u0026#34;, \u0026#34;205.251.250.0/23\u0026#34;, \u0026#34;52.222.128.0/17\u0026#34;, \u0026#34;54.182.0.0/16\u0026#34;, \u0026#34;54.192.0.0/16\u0026#34;, \u0026#34;103.2.30.0/23\u0026#34;, \u0026#34;125.209.208.0/20\u0026#34;, \u0026#34;147.92.128.0/17\u0026#34;, \u0026#34;203.104.144.0/21\u0026#34;, \u0026#34;91.108.8.0/22\u0026#34;, \u0026#34;91.108.12.0/22\u0026#34;, \u0026#34;91.108.16.0/22\u0026#34;, \u0026#34;149.154.160.0/20\u0026#34;, \u0026#34;3.123.36.126/32\u0026#34;, \u0026#34;35.157.215.84/32\u0026#34;, \u0026#34;35.157.217.255/32\u0026#34;, \u0026#34;52.58.209.134/32\u0026#34;, \u0026#34;54.93.124.31/32\u0026#34;, \u0026#34;54.162.243.80/32\u0026#34;, \u0026#34;54.173.34.141/32\u0026#34;, \u0026#34;54.235.23.242/32\u0026#34;, \u0026#34;169.45.248.118/32\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;proxy\u0026#34; } ] } }  TIP 本配置会劫持所有发往 53 端口的流量以解决 DNS 污染问题，所以客户端和本机的 DNS 服务器的地址可以随意配置。\n此外，由于内置的 geoip.dat 文件无法完美实现路由分流，故在配置文件中格外添加了一些 IP。\n 策略路由配置 # ip route add local default dev lo table 100 # 添加路由表 100 # ip rule add fwmark 1 table 100 # 为路由表 100 设定规则 Netfilter 配置 注意 nftables 配置与 iptables 配置二选一，不可同时使用。\n nftables #!/usr/sbin/nft -f flush ruleset\ndefine RESERVED_IP = { 10.0.0.0/8, 100.64.0.0/10, 127.0.0.0/8, 169.254.0.0/16, 172.16.0.0/12, 192.0.0.0/24, 224.0.0.0/4, 240.0.0.0/4, 255.255.255.255/32 }\ntable ip xray { chain prerouting { type filter hook prerouting priority mangle; policy accept; ip daddr $RESERVED_IP return ip daddr 192.168.0.0/16 tcp dport != 53 return ip daddr 192.168.0.0/16 udp dport != 53 return ip protocol tcp tproxy to 127.0.0.1:12345 meta mark set 1 ip protocol udp tproxy to 127.0.0.1:12345 meta mark set 1 } chain output { type route hook output priority mangle; policy accept; ip daddr $RESERVED_IP return ip daddr 192.168.0.0/16 tcp dport != 53 return ip daddr 192.168.0.0/16 udp dport != 53 return meta mark 2 return ip protocol tcp meta mark set 1 ip protocol udp meta mark set 1 } } 使用方法 将上述配置写入一个文件（如 nft.conf），之后将该文件赋予可执行权限，最后使用 root 权限执行该文件即可（# ./nft.conf）。\n iptables iptables -t mangle -N XRAY iptables -t mangle -A XRAY -d 10.0.0.0/8 -j RETURN iptables -t mangle -A XRAY -d 100.64.0.0/10 -j RETURN iptables -t mangle -A XRAY -d 127.0.0.0/8 -j RETURN iptables -t mangle -A XRAY -d 169.254.0.0/16 -j RETURN iptables -t mangle -A XRAY -d 172.16.0.0/12 -j RETURN iptables -t mangle -A XRAY -d 192.0.0.0/24 -j RETURN iptables -t mangle -A XRAY -d 224.0.0.0/4 -j RETURN iptables -t mangle -A XRAY -d 240.0.0.0/4 -j RETURN iptables -t mangle -A XRAY -d 255.255.255.255/32 -j RETURN iptables -t mangle -A XRAY -d 192.168.0.0/16 -p tcp ! --dport 53 -j RETURN iptables -t mangle -A XRAY -d 192.168.0.0/16 -p udp ! --dport 53 -j RETURN iptables -t mangle -A XRAY -p tcp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A XRAY -p udp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A PREROUTING -j XRAY iptables -t mangle -N XRAY_SELF iptables -t mangle -A XRAY_SELF -d 10.0.0.0/8 -j RETURN iptables -t mangle -A XRAY_SELF -d 100.64.0.0/10 -j RETURN iptables -t mangle -A XRAY_SELF -d 127.0.0.0/8 -j RETURN iptables -t mangle -A XRAY_SELF -d 169.254.0.0/16 -j RETURN iptables -t mangle -A XRAY_SELF -d 172.16.0.0/12 -j RETURN iptables -t mangle -A XRAY_SELF -d 192.0.0.0/24 -j RETURN iptables -t mangle -A XRAY_SELF -d 224.0.0.0/4 -j RETURN iptables -t mangle -A XRAY_SELF -d 240.0.0.0/4 -j RETURN iptables -t mangle -A XRAY_SELF -d 255.255.255.255/32 -j RETURN iptables -t mangle -A XRAY_SELF -d 192.168.0.0/16 -p tcp ! --dport 53 -j RETURN iptables -t mangle -A XRAY_SELF -d 192.168.0.0/16 -p udp ! --dport 53 -j RETURN iptables -t mangle -A XRAY_SELF -m mark --mark 2 -j RETURN iptables -t mangle -A XRAY_SELF -p tcp -j MARK --set-mark 1 iptables -t mangle -A XRAY_SELF -p udp -j MARK --set-mark 1 iptables -t mangle -A OUTPUT -j XRAY_SELF  配置完成后，将局域网内其它设备的默认网关改为该设备 IP，就可以直接翻墙了。在其它主机和本机皆测试成功后，可进行下一步配置。\n配置永久化与开机自启 nftables 首先将已经编辑好的 nftables 配置文件移动到 /etc 目录下，并重命名为 nftables.conf。然后编辑 /lib/systemd/system/nftables.service。\n[Unit] Description=nftables Documentation=man:nft(8) http://wiki.nftables.org Wants=network-pre.target Before=network-pre.target shutdown.target Conflicts=shutdown.target DefaultDependencies=no [Service] Type=oneshot RemainAfterExit=yes StandardInput=null ProtectSystem=full ProtectHome=true ExecStart=/usr/sbin/nft -f /etc/nftables.conf ; /usr/sbin/ip route add local default dev lo table 100 ; /usr/sbin/ip rule add fwmark 1 table 100 ExecReload=/usr/sbin/nft -f /etc/nftables.conf ExecStop=/usr/sbin/nft flush ruleset ; /usr/sbin/ip route del local default dev lo table 100 ; /usr/sbin/ip rule del table 100\n[Install] WantedBy=sysinit.target 最后 enable 即可。\niptables 关于 iptables 的永久化，建议直接安装 iptables-persistent。\n安装过程中会提示你选择“是否保存配置”，如果已经将 iptables 配置写入系统，那么此时选择“是”即可；如果尚未写入也没有关系，安装完毕后将配置写入，然后执行 netfilter-persistent save 即可（需要 root 权限）。\n之后编辑 /lib/systemd/system/netfilter-persistent.service。\n[Unit] Description=netfilter persistent configuration DefaultDependencies=no Wants=network-pre.target systemd-modules-load.service local-fs.target Before=network-pre.target shutdown.target After=systemd-modules-load.service local-fs.target Conflicts=shutdown.target Documentation=man:netfilter-persistent(8) [Service] Type=oneshot RemainAfterExit=yes ExecStart=/usr/sbin/netfilter-persistent start ; /usr/sbin/ip route add local default dev lo table 100 ; /usr/sbin/ip rule add fwmark 1 table 100 ExecStop=/usr/sbin/netfilter-persistent stop ; /usr/sbin/ip route del local default dev lo table 100 ; /usr/sbin/ip rule del table 100 [Install] WantedBy=multi-user.target  "},{"uri":"https://xtls.github.io/qa/config/","title":"配置和运行时的问题","tags":[],"description":"Project X 的文档.","content":" Q: 为什么windows下只有一个可执行程序? 我想要隐藏执行, 嘤嘤嘤.A1: 方式很多,如: 建立一个hiderun.vbs文件,放在xray.exe同一目录 编辑内容为\nCreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;xray.exe\u0026#34;,0 运行此vbs即可, 然后放个快捷方式到shell:startup里面，就可以开机启动了\n A2: 也可以通过创建window服务/计划任务等方式实现,亦可借助一些专门的后台运行的工具(不太必要)\n A3: CHP (Create Hidden Process)\n A4: 用winsw可以将xray-core添加为Win的系统服务，开机自动运行，不需要手动隐藏窗口。\n A5: 写一个bat开机启动\n@echo off if \u0026#34;%1\u0026#34; == \u0026#34;h\u0026#34; goto begin mshta vbscript:createobject(\u0026#34;wscript.shell\u0026#34;).run(\u0026#34;%~nx0 h\u0026#34;,0)(window.close)\u0026amp;\u0026amp;exit :begin D:/Xray run -c D:/Xray.json ` \n \nQ: 无法用做Tor前置代理 #66关闭 sniffing 再试试.\n \nQ: 如何自定义.dat文件的文件位置?设置环境变量 XRAY_LOCATION_ASSET 的值\n \nQ: 为什么我配置了SSL证书但不可用? 检查证书权限 使用 fullchain 证书   \nQ: 我以前用gfw列表, 我现在用Xray怎么进行分流呢?使用geo*.dat, 并且合理配置路由规则.\n \nQ: 我还是上一题的提问者, 那么我如何使用dat数据文件和配置路由规则达到国内走直连,其他走代理的目的呢?等待好心人写一篇小小白白话文\n \nQ: 如何配置才能在myssl或者ssllibs得到双A+的评价？首先，这不是必需的，即便没有双A+，甚至只有B，也并不意味着不安全。\n你现在可以这样做:\n 前提, 你的证书是ECC证书, 比如你用acme.sh可以这样获取  ./acme.sh --issue -d \u0026#34;your.domain\u0026#34; -w /var/www/html -k ec-256 --cert-file /etc/xray/\u0026#34;your.domain\u0026#34;/\u0026#34;your.domain\u0026#34;.cer --key-file /etc/xray/\u0026#34;your.domain\u0026#34;/\u0026#34;your.domain\u0026#34;.key --fullchain-file /etc/xray/\u0026#34;your.domain\u0026#34;/fullchain.cer --force \n只需简单的在 服务端的 TLS 配置 (streamsettings中的tlsSettings/xtlsSettings) 中加入  \u0026#34;minVersion\u0026#34;: \u0026#34;1.2\u0026#34; 即可在myssl或ssllabs上获得A\n\n然后在回落的网站服务器上开启HSTS,如 Nginx 只需配置  add_header Strict-Transport-Security \u0026#34;max-age=63072000\u0026#34; always; 即可在myssl或ssllabs上获得A+\n \n"},{"uri":"https://xtls.github.io/guide/config/","title":"配置运行","tags":[],"description":"Project X 的文档.","content":"下载并安装 了 Xray 之后，您需要对它进行一下配置。\n为了演示，这里只介绍简单的配置方式.\n如需配置更复杂的功能，请参考更详细的 配置文件 中相关说明。\n\n服务端配置  你需要一台防火墙外的服务器，来运行服务器端的 Xray。配置如下：\n{ \u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 10086, // 服务器监听端口 \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;b831381d-6324-4d53-ad4f-8cda48b30811\u0026#34; } ] } } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34; } ] } 服务器的配置中需要确保 id 和端口与客户端一致，就可以正常连接了。\n\n客户端配置  在你的 PC（或手机）中，需要用以下配置运行 Xray ：\n{ \u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 1080, // SOCKS 代理端口，在浏览器中需配置代理并指向这个端口 \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;socks\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;udp\u0026#34;: true } } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;server\u0026#34;, // 服务器地址，请修改为你自己的服务器 ip 或域名 \u0026#34;port\u0026#34;: 10086, // 服务器端口 \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;b831381d-6324-4d53-ad4f-8cda48b30811\u0026#34; } ] } ] } }, { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;direct\u0026#34; } ], \u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;IPOnDemand\u0026#34;, \u0026#34;rules\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [\u0026#34;geoip:private\u0026#34;], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct\u0026#34; } ] } } 上述配置唯一要更改的地方是你的服务器 IP，配置中已注明。上述配置会把除局域网（比如访问路由器）以外的所有流量转发至你的服务器。\n\n运行   在 Windows 和 macOS 中，配置文件通常是 Xray 同目录下的 config.json 文件。  直接运行 Xray 或 Xray.exe 即可。   在 Linux 中，配置文件通常位于 /etc/Xray/ 或 /usr/local/etc/Xray/ 目录下。  运行 xray run -c /etc/Xray/config.json 或使用 systemd 等工具将 Xray 作为服务在后台运行。    更多详细的说明可以参考 配置文档 和 使用心得。\n"},{"uri":"https://xtls.github.io/documents/level-0/ch03-ssh/","title":"【第3章】远程登录篇","tags":[],"description":"小小白白话文","content":"3.1 远程登录VPS (PuTTY) 首先，鉴于零基础人群中Windows的用户基数最大，所以本文以Windows为例进行展示。\n其次，虽然Windows 10之后的PowerShell和WSL也可以达到很好的SSH操作体验。但是因为并非所有版本的Windows都有最新的组件，故本文还是以老牌的PuTTY为例，进行SSH远程登录的操作详解。（使用其他工具的话、在SSH登陆之后的操作都是一样的）\n下面就跟我一步步操作吧。\n  进入PuTTY的官网，选择适合你操作系统的版本下载。（本文以64位版本为例）\n  安装运行后，将会看到PuTTY的主界面。现在请拿出你上一章记东西的小本本，在下图的对应位置填入你VPS的IP地址(VPS IP)和端口(VPS PORT)。为了方便以后使用时不用重复输入，我们可以保存会话 (Saved Sessions)，未来使用时只要按Load即可一键载入设置。\n  我建议将 Connection 中的 keepalive 设置为 60 秒，防止你一段时间没有操作之后SSH自动断线。另外务必再次保存设置。（对PuTTY的任何设置更新都要再次保存，不然关闭后就会丢失）\n  点击 Open 就会进入SSH连接窗口，对应下图输入用户名与密码，与你的VPS远程主机建立连接。（本文假设默认用户名是 root，另外，在Linux系统输入密码的时候，是不会出现 ****** 这种提示符的（避免密码长度泄漏），不是你的键盘坏掉了哦！）\n  3.2 成功登录SSH！初识命令行界面！   如果你的信息都填写正确，你将会看到类似下图的界面，说明已登录成功：\n这个界面，就等于远程服务器的【桌面】，但它没有你熟悉的图标和鼠标，没有绚丽的色彩，有的只是简单文字，这就是【命令行界面】- Command Line Interface，或者缩写为 CLI。\n接下来的所有操作，都需要你像电影里的黑客一样，在这个命令行界面中完成。也许你会觉得陌生，但请相信我，使用命令行既不可怕，也不神秘。说到底，它只不过是把你习惯的鼠标操作变成了文字指令而已，你说一句，它做一句。\n  现在，你可以稍微观察并熟悉一下命令行环境，这个界面其实已经告诉了你一些有用的信息了，比如系统内核版本（比如图内是 4.19.37-5）、上次登录时间及IP等。当然根据VPS的不同，你看到的界面可能会略有不同。\n  请注意命令行最下面一行，闪动的光标左边，有一串字符。图中显示的是root@vps-server:~#，这一串要怎么理解呢？很简单：\n 现在的用户是 root root 所在的服务器是 vps-server root 现在所在的文件夹是 ~ # 之后是你可以输入命令的地方  前两个很直观，无需多说。第三个是关于Linux的文件夹系统，现在也不需要过于深入，你只需要知道，\u0026quot;~\u0026ldquo;就是【当前用户的大本营】。第四个，提示符#，你也不用管，只需要知道，未来文章中会写一些需要你输入的命令，都会以 \u0026ldquo;#\u0026rdquo; 或者 \u0026ldquo;$\u0026rdquo; 开头，提示你后面是你输入命令的地方。（所以你复制命令的时候，只需要复制后面的内容，不要复制提示符）\n  3.3 第一次更新Linux的软件！   正如你的手机，无论安卓还是iPhone，为了APP及时更新（获取安全补丁和新功能），都会时不时从应用商店获得更新信息，并且提示你有多少个APP可更新，Linux系统也有类似的更新机制，操作的逻辑其实非常相似。所以只要你会更新手机APP，就能学会更新Linux软件！\n  Linux下，每个APP都叫做一个“包” （package）。管理APP的程序自然就叫做“包管理器”（Package Manager）。你可以通过它安装、更新、卸载各种软件、甚至更新Linux系统本身。Linux下的包管理器非常强大，此处按下不表，现在你只需要知道Debian系统的包管理器叫做 apt 即可。接下来，我们就先使用 apt 做一次软件的全面更新，让你熟悉它的基本操作。\n  小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-01 apt update 查询软件更新   cmd-02 apt upgrade 执行软件更新      现在请输入第一条命令，获取更新信息\n# apt update   然后请输入第二条命令，并在询问是否继续安装 (Y/n) 时输入 y 并回车确认，开始安装\n# apt upgrade   完整流程演示如下：\n  3.4 你的进度 恭喜你又迈出了坚实的一步！ 现在，你已经可以通过SSH来登录你的远程服务器了！那登录进去之后，除了升级软件之外，应该再做点什么呢？敬请进入下一章一探究竟吧！\nPROGRESS⬛⬛⬛⬜⬜⬜⬜⬜ 37.5%\n "},{"uri":"https://xtls.github.io/config/transports/domainsocket/","title":"Domain Socket","tags":[],"description":"Project X 的文档.","content":" important推荐写到 inbounds 的 listen 处，传输方式可选 TCP、WebSocket、HTTP/2.\n未来这里的 DomainSocket 可能会被弃用。\n Domain Socket 使用标准的 Unix domain socket 来传输数据。\n它的优势是使用了操作系统内建的传输通道，而不会占用网络缓存。 理论上相比起本地环回网络（local loopback）来说，Domain socket 速度略快一些。\n目前仅可用于支持 Unix domain socket 的平台，如 Linux 和 macOS。在 Windows 10 Build 17036 前不可用。\n如果指定了 domain socket 作为传输方式，在入站出站代理中配置的端口和 IP 地址将会失效，所有的传输由 domain socket 取代。\nDomainSocketObject  DomainSocketObject 对应传输配置的 dsSettings 项。\n{ \u0026#34;path\u0026#34;: \u0026#34;/path/to/ds/file\u0026#34;, \u0026#34;abstract\u0026#34;: false, \u0026#34;padding\u0026#34;: false }  path: string\n 一个合法的文件路径。 important在运行 Xray 之前，这个文件必须不存在。\n abstract: true | false\n 是否为 abstract domain socket，默认值 false。\n padding: true | false\n abstract domain socket 是否带 padding，默认值 false。\n"},{"uri":"https://xtls.github.io/config/outbound-protocols/freedom/","title":"Freedom","tags":[],"description":"Project X 的文档.","content":"Freedom 是一个出站协议，可以用来向任意网络发送（正常的） TCP 或 UDP 数据。\nOutboundConfigurationObject  { \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;redirect\u0026#34;: \u0026#34;127.0.0.1:3366\u0026#34;, \u0026#34;userLevel\u0026#34;: 0 }  domainStrategy: \u0026ldquo;AsIs\u0026rdquo; | \u0026ldquo;UseIP\u0026rdquo; | \u0026ldquo;UseIPv4\u0026rdquo; | \u0026ldquo;UseIPv6\u0026rdquo;\n 在目标地址为域名时, 配置相应的值, Freedom 的行为模式如下:\n \u0026quot;AsIs\u0026quot;: Freedom 通过系统DNS服务器解析获取IP, 向此域名发出连接. \u0026quot;UseIP\u0026quot;、\u0026quot;UseIPv4\u0026quot; 和 \u0026quot;UseIPv6\u0026quot;: Xray 使用内置 DNS 服务器解析获取IP, 向此域名发出连接. 默认值为 \u0026quot;AsIs\u0026quot;。   TIP 1\n当使用 \u0026quot;UseIP\u0026quot; 模式，并且出站连接配置 中指定了 sendThrough 时，Freedom 会根据 sendThrough 的值自动判断所需的 IP 类型，IPv4 或 IPv6。\n TIP 2\n当使用 \u0026quot;UseIPv4\u0026quot; 或 \u0026quot;UseIPv6\u0026quot; 模式时，Freedom 会只使用对应的 IPv4 或 IPv6 地址。当 sendThrough 指定了不匹配的本地地址时，将导致连接失败。\n redirect: address_port\n Freedom 会强制将所有数据发送到指定地址（而不是 inbound 指定的地址）。\n其值为一个字符串，样例：\u0026quot;127.0.0.1:80\u0026quot;，\u0026quot;:1234\u0026quot;。\n当地址不指定时，如 \u0026quot;:443\u0026quot;，Freedom 不会修改原先的目标地址。 当端口为 0 时，如 \u0026quot;xray.com: 0\u0026quot;，Freedom 不会修改原先的端口。\nuserLevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n"},{"uri":"https://xtls.github.io/config/inbound-protocols/http/","title":"HTTP","tags":[],"description":"Project X 的文档.","content":"HTTP 协议。\nimportanthttp 协议没有对传输加密，不适宜经公网中传输，更容易成为被人用作攻击的肉鸡。\nhttp inbound 更有意义的用法是在局域网或本机环境下监听，为其他程序提供本地服务。\n TIP 1\nhttp proxy 只能代理 tcp 协议，udp 系的协议均不能通过。\n TIP 2\n在 Linux 中使用以下环境变量即可在当前 session 使用全局 HTTP 代理（很多软件都支持这一设置，也有不支持的）。\n export http_proxy=http://127.0.0.1:8080/ (地址须改成你配置的 HTTP 入站代理地址) export https_proxy=$http_proxy   InboundConfigurationObject  { \u0026#34;timeout\u0026#34;: 0, \u0026#34;accounts\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; } ], \u0026#34;allowTransparent\u0026#34;: false, \u0026#34;userLevel\u0026#34;: 0 }  timeout: number\n 连接空闲的时间限制。单位为秒。默认值为 300, 0 表示不限时。\n处理一个连接时，如果在 timeout 时间内，没有任何数据被传输，则中断该连接。\naccounts: [AccountObject]\n 一个数组，数组中每个元素为一个用户帐号。默认值为空。\n当 accounts 非空时，HTTP 代理将对入站连接进行 Basic Authentication 验证。\nallowTransparent: true | false\n 当为 true 时，会转发所有 HTTP 请求，而非只是代理请求。\nTIP\n若配置不当，开启此选项会导致死循环。\n userLevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n\nAccountObject  { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; }  user: string\n 用户名，字符串类型。必填。\npass: string\n 密码，字符串类型。必填。\n"},{"uri":"https://xtls.github.io/develop/protocols/muxcool/","title":"Mux.Cool 协议","tags":[],"description":"Project X 的文档.","content":"Mux.Cool 协议是一个多路复用传输协议，用于在一条已建立的数据流中传输多个各自独立的数据流。\n\n版本  当前版本是 1 Beta。\n\n依赖  底层协议  Mux.Cool 必须运行在一个已建立的可靠数据流之上。\n\n通讯过程  一个 Mux.Cool 连接中可传输若干个子连接，每个子连接有一个独立的 ID 和状态。传输过程由帧（Frame）组成，每一帧用于传输一个特定的子连接的数据。\n\n客户端行为  当有连接需求时并且没有现有可用的连接时，客户端向服务器发起一个新连接，以下称为“主连接”。\n 一个主连接可用于发送若干个子连接。客户端可自主决定主连接可承载的子连接数量。 对于一个新的子连接，客户端必须发送状态New以通知服务器建立子连接，然后使用状态Keep来传送数据。 当子连接结束时，客户端发送End状态来通知服务器关闭子连接。 客户端可自行决定何时关闭主连接，但必须确定服务器也同时保持连接。 客户端可使用 KeepAlive 状态来避免服务器关闭主连接。  \n服务器端行为  当服务器端接收到新的子连接时，服务器应当按正常的连接来处理。\n 当收到状态End时，服务器端可以关闭对目标地址的上行连接。 在服务器的响应中，必须使用与请求相同的 ID 来传输子连接的数据。 服务器不能使用New状态。 服务器可使用 KeepAlive 状态来避免客户端关闭主连接。  \n传输格式  Mux.Cool 使用对称传输格式，即客户端和服务器发送和接收相同格式的数据。\n\n帧格式     2 字节 L 字节 X 字节     元数据长度 L 元数据 额外数据    \n元数据  元数据有若干种类型，由状态 S 来区分。所有类型的元数据都包含 ID 和 Opt 两项，其含义为：\n ID: 子连接的唯一标识 Opt:  D(0x01): 有额外数据    当选项 Opt(D) 开启时，额外数据格式如下：\n   2 字节 L 字节     长度 L 数据    \n新建子连接 (New)     2 字节 1 字节 1 字节 1 字节 2 字节 1 字节 X 字节     ID 0x01 选项 Opt 网络类型 N 端口 地址类型 T 地址 A    其中：\n 网络类型 N：  0x01：TCP，表示当前子连接的流量应当以 TCP 的方式发送至目标。 0x02：UDP，表示当前子连接的流量应当以 UDP 的方式发送至目标。   地址类型 T：  0x01：IPv4 0x02：域名 0x03：IPv6   地址 A：  当 T = 0x01 时，A 为 4 字节 IPv4 地址； 当 T = 0x02 时，A 为 1 字节长度（L） + L 字节域名； 当 T = 0x03 时，A 为 16 字节 IPv6 地址；    在新建子连接时，若 Opt(D) 开启，则这一帧所带的数据需要被发往目标主机。\n\n保持子连接 (Keep)     2 字节 1 字节 1 字节     ID 0x02 选项 Opt    在保持子连接时，若 Opt(D) 开启，则这一帧所带的数据需要被发往目标主机。\n\n关闭子连接 (End)     2 字节 1 字节 1 字节     ID 0x03 选项 Opt    在保持子连接时，若 Opt(D) 开启，则这一帧所带的数据需要被发往目标主机。\n\n保持连接 (KeepAlive)     2 字节 1 字节 1 字节     ID 0x04 选项 Opt    在保持连接时:\n 若 Opt(D) 开启，则这一帧所带的数据必须被丢弃。 ID 可为随机值。  \n应用  Mux.Cool 协议与底层协议无关，理论上可以使用任何可靠的流式连接来传输 Mux.Cool 的协议数据。\n在目标导向的协议如 Shadowsocks 和 VMess 协议中，连接建立时必须包含一个指定的地址。\n为了保持兼容性，Mux.Cool 协议指定地址为“v1.mux.cool”。即当主连接的目标地址与之匹配时，则进行 Mux.Cool 方式的转发，否则按传统方式进行转发。\n"},{"uri":"https://xtls.github.io/config/dns/","title":"内置DNS服务器","tags":[],"description":"Project X 的文档.","content":"DNS 服务器  如果为 Xray 配置了 DNS 服务器模块，主要有两大用途：\n  在路由阶段, 解析域名为 IP, 并且根据域名解析得到的 IP 进行规则匹配以分流. 是否解析域名及分流和路由配置模块中\u0026quot;domainStrategy\u0026quot;的值有关, 只有在设置以下两种值时,才会使用内置 DNS 服务器进行 DNS 查询:\n \u0026ldquo;IPIfNonMatch\u0026rdquo;, 请求一个域名时，进行路由里面的 domain 进行匹配，若无法匹配到结果，则对这个域名使用内置 DNS 服务器进行 DNS 查询，并且使用查询返回的 IP 地址再重新进行 IP 路由匹配。 \u0026ldquo;IPOnDemand\u0026rdquo;, 当匹配时碰到任何基于 IP 的规则，将域名立即解析为 IP 进行匹配。    解析目标地址进行连接。\n 如 在 freedom 协议的 outbound 中，将domainStrategy 设置为 UseIP, 由此 outbound 发出的请求, 会先将域名通过内置服务器解析成 IP, 然后进行连接    TIP 1\n内置 DNS 服务器所发出的 DNS 查询请求，会自动根据路由配置进行转发。\n TIP 2\n只支持最基本的 IP 查询（A 和 AAAA 记录）。\n \nDNS 处理流程  DNS 服务器配置模块可以配置多个DNS服务器, 并且指定优先匹配列表.\n 查询的域名与某个 DNS 服务器指定的域名列表匹配时，Xray 会优先使用这个 DNS 服务器进行查询 无匹配时, 按从上往下的顺序进行查询 只返回匹配 expectIPs 的 IP 列表。  DNS 服务器的处理流程示意图如下：\n\nDnsObject  DnsObject 对应配置文件的 dns 项。\n{ \u0026#34;dns\u0026#34;: { \u0026#34;hosts\u0026#34;: { \u0026#34;baidu.com\u0026#34;: \u0026#34;127.0.0.1\u0026#34; }, \u0026#34;servers\u0026#34;: [ \u0026#34;8.8.8.8\u0026#34;, \u0026#34;8.8.4.4\u0026#34;, { \u0026#34;address\u0026#34;: \u0026#34;1.2.3.4\u0026#34;, \u0026#34;port\u0026#34;: 5353, \u0026#34;domains\u0026#34;: [\u0026#34;domain:xray.com\u0026#34;], \u0026#34;expectIPs\u0026#34;: [\u0026#34;geoip:cn\u0026#34;] }, \u0026#34;localhost\u0026#34; ], \u0026#34;clientIp\u0026#34;: \u0026#34;1.2.3.4\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;dns_inbound\u0026#34; } }  hosts: map{string: address}\n 静态 IP 列表，其值为一系列的 \u0026ldquo;域名\u0026rdquo;: \u0026ldquo;地址\u0026rdquo;。其中地址可以是 IP 或者域名。在解析域名时，如果域名匹配这个列表中的某一项:\n 当该项的地址为 IP 时，则解析结果为该项的 IP 当该项的地址为域名时，会使用此域名进行 IP 解析，而不使用原始域名。  域名的格式有以下几种形式：\n 纯字符串：当此字符串完整匹配目标域名时，该规则生效。例如 \u0026ldquo;xray.com\u0026rdquo; 匹配\u0026quot;xray.com\u0026quot; 但不匹配\u0026quot;www.xray.com\u0026quot;。 正则表达式：由 \u0026quot;regexp:\u0026quot; 开始，余下部分是一个正则表达式。当此正则表达式匹配目标域名时，该规则生效。例如 \u0026ldquo;regexp:\\\\.goo.*\\\\.com$\u0026rdquo; 匹配\u0026quot;www.google.com\u0026quot;或 \u0026ldquo;fonts.googleapis.com\u0026rdquo;，但不匹配 \u0026ldquo;google.com\u0026rdquo;。 子域名 (推荐)：由 \u0026quot;domain:\u0026quot; 开始，余下部分是一个域名。当此域名是目标域名或其子域名时，该规则生效。例如 \u0026ldquo;domain:xray.com\u0026rdquo; 匹配\u0026quot;www.xray.com\u0026quot;、\u0026ldquo;xray.com\u0026rdquo;，但不匹配\u0026quot;xray.com\u0026quot;。 子串：由 \u0026quot;keyword:\u0026quot; 开始，余下部分是一个字符串。当此字符串匹配目标域名中任意部分，该规则生效。比如 \u0026ldquo;keyword:sina.com\u0026rdquo; 可以匹配\u0026quot;sina.com\u0026quot;、\u0026ldquo;sina.com.cn\u0026rdquo; 和\u0026quot;www.sina.com\u0026quot;，但不匹配 \u0026ldquo;sina.cn\u0026rdquo;。 预定义域名列表：由 \u0026quot;geosite:\u0026quot; 开头，余下部分是一个名称，如 geosite:google 或者 geosite:cn。名称及域名列表参考 预定义域名列表。  servers: [string | ServerObject ]\n 一个 DNS 服务器列表，支持的类型有两种：DNS 地址（字符串形式）和 ServerObject 。\n当它的值是一个 DNS IP 地址时，如 \u0026quot;8.8.8.8\u0026quot;，Xray 会使用此地址的 53 端口进行 DNS 查询。\n当值为 \u0026quot;localhost\u0026quot; 时，表示使用本机预设的 DNS 配置。\n当值是 \u0026quot;https://host:port/dns-query\u0026quot; 的形式，如 \u0026quot;https://dns.google/dns-query\u0026quot;，Xray 会使用 DNS over HTTPS (RFC8484, 简称 DOH) 进行查询。有些服务商拥有 IP 别名的证书，可以直接写 IP 形式，比如 https://1.1.1.1/dns-query。也可使用非标准端口和路径，如 \u0026quot;https://a.b.c.d:8443/my-dns-query\u0026quot;\n当值是 \u0026quot;https+local://host:port/dns-query\u0026quot; 的形式，如 \u0026quot;https+local://dns.google/dns-query\u0026quot;，Xray 会使用 DOH本地模式 进行查询，即 DOH 请求不会经过 Routing/Outbound 等组件，直接对外请求，以降低耗时。一般适合在服务端使用。也可使用非标端口和路径。\nTIP 1\n当使用 localhost 时，本机的 DNS 请求不受 Xray 控制，需要额外的配置才可以使 DNS 请求由 Xray 转发。\n TIP 2\n不同规则初始化得到的 DNS 客户端会在 Xray 启动日志中以 info 级别体现，比如 local DOH、remote DOH 和 udp 等模式。\n clientIp: string\n 用于 DNS 查询时通知服务器以指定IP位置。不能是私有地址。\ntag: string\n 由内置 DNS 发出的查询流量，除 localhost 和 DOHL_ 模式外，都可以用此标识在路由使用 inboundTag 进行匹配。\n\nServerObject  { \u0026#34;address\u0026#34;: \u0026#34;1.2.3.4\u0026#34;, \u0026#34;port\u0026#34;: 5353, \u0026#34;domains\u0026#34;: [ \u0026#34;domain:xray.com\u0026#34; ], \u0026#34;expectIPs\u0026#34;: [ \u0026#34;geoip:cn\u0026#34; ] }  address: address\n 一个 DNS 服务器列表，支持的类型有两种：DNS 地址（字符串形式）和 ServerObject 。\n当它的值是一个 DNS IP 地址时，如 \u0026ldquo;8.8.8.8\u0026rdquo;，Xray 会使用此地址的 53 端口进行 DNS 查询。\n当值为 \u0026ldquo;localhost\u0026rdquo; 时，表示使用本机预设的 DNS 配置。\n当值是 \u0026ldquo;https://host:port/dns-query\u0026rdquo; 的形式，如 \u0026ldquo;https://dns.google/dns-query\u0026quot;，Xray 会使用 DNS over HTTPS (RFC8484, 简称 DOH) 进行查询。有些服务商拥有 IP 别名的证书，可以直接写 IP 形式，比如 https://1.1.1.1/dns-query。也可使用非标准端口和路径，如 \u0026ldquo;https://a.b.c.d:8443/my-dns-query\u0026rdquo;\n当值是 \u0026ldquo;https+local://host:port/dns-query\u0026rdquo; 的形式，如 \u0026ldquo;https+local://dns.google/dns-query\u0026rdquo;，Xray 会使用 DOH本地模式 进行查询，即 DOH 请求不会经过 Routing/Outbound 等组件，直接对外请求，以降低耗时。一般适合在服务端使用。也可使用非标端口和路径。\n  port: number\n DNS 服务器端口，如 53。此项缺省时默认为 53。当使用 DOH 模式该项无效，非标端口应在 URL 中指定。\ndomains: [string]\n 一个域名列表，此列表包含的域名，将优先使用此服务器进行查询。域名格式和 路由配置 中相同。\nexpectIPs:[string]\n 一个 IP 范围列表，格式和 路由配置 中相同。\n当配置此项时，Xray DNS 会对返回的 IP 的进行校验，只返回包含 expectIPs 列表中的地址。\n如果未配置此项，会原样返回 IP 地址。\n"},{"uri":"https://xtls.github.io/guide/command/","title":"命令参数","tags":[],"description":"Project X 的文档.","content":" TIP\nXray 使用 go 风格的命令及参数\n 获取基本命令  您可以运行 xray help 来获得所有 xray 最基础的用法, 以及可用的命令及说明.\nXray is a platform for building proxies. Usage: xray \u0026lt;command\u0026gt; [arguments] The commands are: run Run Xray with config, the default command version Show current version of Xray api Call an API in an Xray process tls TLS tools uuid Generate new UUIDs Use \u0026#34;xray help \u0026lt;command\u0026gt;\u0026#34; for more information about a command. \nxray run  使用方法:\nxray run [-c config.json] [-confdir dir] Run Xray with config, the default command.\nThe -config=file, -c=file flags set the config files for Xray. Multiple assign is accepted.\nThe -confdir=dir flag sets a dir with multiple json config\nThe -format=json flag sets the format of config files. Default \u0026ldquo;json\u0026rdquo;.\nThe -test flag tells Xray to test config files only, without launching the server\n\nxray version  使用方法:\nxray version Version prints the build information for Xray executables.\n\nxray api  使用方法:\nxray api \u0026lt;command\u0026gt; [arguments] The commands are:\n restartlogger Restart the logger stats Get statistics statsquery Query statistics statssys Get system statistics adi Add inbounds ado Add outbounds rmi Remove inbounds rmo Remove outbounds  \nxray tls  使用方法:\nxray tls \u0026lt;command\u0026gt; [arguments] The commands are:\n cert Generate TLS certificates ping Ping the domain with TLS handshake  \nxray uuid  使用方法:\nxray uuid Generate new UUIDs.\n\n当-config没有指定时，Xray 将先后尝试从以下路径加载config.json:\n 工作目录（Working Directory） 环境变量中Xray.location.asset所指定的路径   "},{"uri":"https://xtls.github.io/develop/intro/guide/","title":"开发规范","tags":[],"description":"Project X 的文档.","content":"基本  版本控制  project X 的代码被托管在github上:\n xray 核心 xray-core xray-flutter xray-flutter 安装脚本 Xray-install 数据文件 Xray-rules-dat 配置模板 Xray-examples xray文档 XTLS.github.io  您可以使用 Git 来获取代码.\n 分支（Branch）  本项目的主干分支为 main, main 分支也是发布时所使用的代码分支, 因此需要确保 master 在任一时刻都是可编译可使用的。\n如果需要开发新的功能\n 请新开分支进行开发, 在开发完成并且经过充分测试后, 合并回主干分支. 新开分支如没有必要再存在时, 可以去除.   发布（Release）  In progress\n 建立尝鲜版本和稳定版本两个发布通道  临时版本, 主要用于特定情况的测试(比如从分支build的), 于TG群内/issue回复等渠道 发布特定版本 尝鲜版本可以为daily build , 用于尝鲜和获得即时反馈和再改进. 稳定版本为定时更新(比如周更), 合并稳定的修改并发布.     引用其它项目   Golang  产品代码建议使用 Golang 标准库和 golang.org/x/ 下的库； 如需引用其它项目，请事先创建 issue 讨论；   其它  不违反双方的协议，且对项目有帮助的工具，都可以使用。     开发流程  写代码之前  发现任何问题，或对项目有任何想法，请创建 Issue 讨论以减少重复劳动和消耗在代码上的时间。\n 修改代码   Golang  请参考 Effective Go； 每一次 push 之前，请运行：go fmt ./... 和 go fmt -s -l -e -w $(find . -type f -name \u0026quot;*.go\u0026quot; ! -name \u0026quot;*.pb.go\u0026quot;)； 每一次 push 之前，请确保测试通过：go test ./...； 提交 pull request 之前，请确保新增代码有超过 70% 的代码覆盖率（code coverage）；   其它  请注意代码的可读性。     Pull Request   提交 PR 之前，请先运行 git pull https://github.com/xray/xray-core.git 以确保 merge 可顺利进行； 一个 PR 只做一件事，如有对多个 bug 的修复，请对每一个 bug 提交一个 PR； 由于 Golang 的特殊需求（Package path），Go 项目的 PR 流程和其它项目有所不同 ,建议流程如下：  先 Fork 本项目，创建自己的 github.com/your/Xray-core 仓库； 克隆自己的 Xray 仓库到本地：git clone https://github.com/your/Xray-core.git； 基于 main 分支创建新的分支； 在自行创建的分支上作修改并提交修改(commit)； 在推送(push)修改完成的分支到自己的仓库前，先切换到 main 分支，运行 git pull https://github.com/v2fly/Xray-core.git 拉取最新的远端代码； 如果上一步拉取得到了新的远端代码，则切换到之前自己创建的分支，运行 git rebase master 执行分支合并操作。如遇到文件冲突，则需要解决冲突； 上一步处理完毕后，就可以把自己创建的分支推送到自己的仓库：git push -u origin your-branch 最后，把自己仓库的新推送的分支往 xtls/Xray-core 的 main 分支发 PR 即可； 请在 PR 的标题和正文中，完整表述此次 PR 解决的问题 / 新增的功能 / 代码所做的修改的用意等； 耐心等待开发者的回应。    对代码的修改  功能性问题  请提交至少一个测试用例（Test Case）来验证对现有功能的改动。\n性能相关  请提交必要的测试数据来证明现有代码的性能缺陷，或是新增代码的性能提升。\n新功能   如果新增功能对已有功能不影响，请提供可以开启/关闭的开关（如 flag），并使新功能保持默认关闭的状态； 大型新功能（比如增加一个新的协议）开发之前，请先提交一个 issue，讨论完毕之后再进行开发。  其它  视具体情况而定。\n Xray 编码规范  以下内容适用于 Xray 中的 Golang 代码。\n代码结构  Xray-core ├── app // 应用模块 │ ├── router // 路由 ├── common // 公用代码 ├── proxy // 通讯协议 │ ├── blackhole │ ├── dokodemo-door │ ├── freedom │ ├── socks │ ├── vmess ├── transport // 传输模块 编码规范  基本与 Golang 官方所推荐做法一致，有一些例外。写在这里以方便大家熟悉 Golang。\n命名   文件和目录名尽量使用单个英文单词，比如 hello.go；  如果实在没办法，则目录使用连接线／文件名使用下划线连接两个（或多个单词），比如 hello-world/hello_again.go； 测试代码使用 _test.go 结尾；   类型使用 Pascal 命名法，比如 ConnectionHandler；  对缩写不强制小写，即 HTML 不必写成 Html；   公开成员变量也使用 Pascal 命名法； 私有成员变量使用 小驼峰式命名法 ，如 privateAttribute ； 为了方便重构，方法建议全部使用 Pascal 命名法；  完全私有的类型放入 internal 。     内容组织   一个文件包含一个主要类型，及其相关的私有函数等； 测试相关的文件，如 Mock 等工具类，放入 testing 子目录。  "},{"uri":"https://xtls.github.io/qa/performance/","title":"性能相关的问题","tags":[],"description":"Project X 的文档.","content":" Q: 我是瓜瓜, 我想问 Xray 是不是最快的?是.\n Q: 什么工具或协议组合最快啊?/我应该用什么工具协议组合啊?个人自建上网,首先考虑安全性和伪装性,然后选择能满足自己需求的最高性能组合\n上网速率的高低, 体感的快慢, 根本的决定因素是线路 因此所有的选择跟你的实际环境息息相关,有时候需要一些特殊手段处理, 比如\n 比如低质量的线路可用使用CF加速. 比如晚上高峰期严重丢包的情况下, 可用使用mkcp(上限很低), 让线路尽量跑的更流畅一些.  在通常的环境下, 各种工具/协议组合的性能的高低, 可以参考Xray性能对比测试\n Q: mac和win 使用splice是不是无解了？ Windows 提供了 TransmitFile，但似乎不能用于两个 TCP 对接 Windows 10 有 WSL  WSL 1 使用 Splice 性能捉急. 不清楚 WSL 2 会不会带来额外拷贝开销，需要更多勇士尝试并反馈.   macOS暂无计划   Q: 有无xtls+splice+ws的计划？XTLS 原理上不支持 WS\n不带 TLS 的 WS 理论上可以支持类似 XTLS 的东西，目前没有实现它的计划\n或者 看看这里\n \n"},{"uri":"https://xtls.github.io/config/","title":"配置文件","tags":[],"description":"Project X 的文档.","content":" 这个章节将告诉您所有的 Xray 配置细节,掌握这些内容,在您手中 Xray 将发挥更大威力. 概述  Xray 的配置文件为 json 格式, 客户端和服务端的配置格式没有区别, 只是实际的配置内容不一样。\n形式如下:\n{ \u0026#34;log\u0026#34;: {}, \u0026#34;api\u0026#34;: {}, \u0026#34;dns\u0026#34;: {}, \u0026#34;routing\u0026#34;: {}, \u0026#34;policy\u0026#34;: {}, \u0026#34;inbounds\u0026#34;: [], \u0026#34;outbounds\u0026#34;: [], \u0026#34;transport\u0026#34;: {}, \u0026#34;stats\u0026#34;: {}, \u0026#34;reverse\u0026#34;: {} }  TIP\n如果你刚接触 Xray, 您可以先点击查看快速入门中的配置运行, 学习最基本的配置方式, 然后查看本章节内容以掌握所有 Xray 的配置方式.\n \n模块说明   log:LogObject\n 日志配置，控制 Xray输出日志的方式. api:ApiObject\n 提供了一些API接口供远程调用。 dns: DnsObject\n 内置的 DNS 服务器. 如果没有配置此项，则使用系统的 DNS 设置。 routing: RoutingObject\n 路由功能。可以设置规则分流数据从不同的outbound发出. policy: PolicyObject\n 本地策略，可以设置不同的用户等级和对应的策略设置。 inbounds: [ InboundObject ]\n 一个数组，每个元素是一个入站连接配置。 outbounds: [ OutboundObject ]\n 一个数组，每个元素是一个出站连接配置。 transport: TransportObject\n 用于配置 Xray 其它服务器建立和使用网络连接的方式。 stats: StatsObject\n 用于配置流量数据的统计。 reverse: ReverseObject\n 反向代理。可以把服务器端的流量向客户端转发，即逆向流量转发\n"},{"uri":"https://xtls.github.io/documents/level-0/ch04-security/","title":"【第4章】安全防护篇","tags":[],"description":"小小白白话文","content":"4.1 为什么要做安全防护 Linux服务器的安全防护是一个纷繁复杂的巨大课题。无数的网站、APP、服务、甚至线下基础设施都建立在Linux的基石之上，这背后牵涉到巨大的经济利益和商业价值，当然也就就意味着黑灰产有巨大的攻击动力。但是这些服务时如此重要、根本不允许出现重大的安全漏洞。于是无数的运维专业人员都在安全攻防的战场上拼搏努力，这才让大家能享受到基本稳定的现代化数字生活。\n现在，你拥有了一台VPS，并且将会敞开他的数据访问渠道来达到流量转发的目标，那就相当于你已经置身于安全攻防战场的第一线、直面所有风险。但与此同时，新人由于知识和信息的不足，看待安全问题是总是难免两极分化：要么觉得轻如鸿毛和自己没有半点关系，要么觉得重于泰山甚至惶惶不可终日。\n  对于前者，我的建议是：安全无小事，尽量多查一些安全方面的信息，免得自己真的受了损失才后悔莫及\n  对于后者，我的建议是：不用紧张，我们的服务器仍不具有太高的价值、一般不会吸引到高水平的攻击，需要面对的基本都是一些自动化脚本的恶意扫描和登录尝试，跟着本文做一些基础的防护即可\n  4.2 具体的风险到底是什么 就像我们在《远程登录篇》配置的一样，任何人只需要知道【IP地址】+【端口】+【用户名】+【密码】这四个要素，就能登录你的VPS服务器。那很显然，这四要素的安全就是我们要防护的底线。我们来逐一分析：\n  【IP地址】：恶意脚本会随机尝试和扫描IP段，可以简单认为是公开信息、无法隐藏\n  【端口】：如果使用默认端口，那么【端口 = 22】\n  【用户名】：如果使用默认用户，那么【用户名 = root】\n  【密码】：密码不存在默认值，一定是由VPS后台随机生成或由你自行设置的。也就是说，如果你的服务器都是默认设置，则四要素中的三个已经是已知的，那么你整个服务器的安全，就全部寄托在一串小小的密码上了。这时有几种情况：\n  如果你用了VPS管理后台随机生成密码，它一般包含随机的十几个大小写混杂的字母和符号，相对比较安全\n  如果你为了好记、把密码改成了类似123456这种超弱的密码，破解你的VPS服务器可谓不费吹灰之力\n  如果你为了好记、把密码改成了比较复杂、但在别的地方用过的密码，其实也并不安全。你要明白黑客手里有作弊器，比如说密码表，包含数万、数十万、数百万甚至更多曾经泄漏的真实密码）\n    但你要明白，没有哪个黑客真的要坐在电脑前一次一次的尝试你的密码，全部的攻击尝试都是恶意脚本自动进行的，它会24小时不眠不休的工作。也许每天你酣睡之时，你的服务器都在经受着一轮又一轮的冲击。\n一旦密码被成功撞破，意味着你的四要素全部被攻击者掌握，恶意脚本就会快速登录服务器、获取服务器的最高 root 控制权、安装部署它的恶意服务，然后就可以用你的服务器来24小时做各种坏事（比如挖矿、传播病毒、发送垃圾邮件、欺诈邮件、做BT中继、甚至暗网公众节点等等等等）。如果恶意脚本比较克制，其实可以做到相当的隐蔽性。而新人一般也不会去观察留意VPS的登录记录、进程变化、CPU占用变化、流量变化等指标，你其实就很难发现自己被黑了。直到你的VPS服务商封禁你的账号、或者收到律师函为止。\n  别忘了，你获得VPS时大概率需要使用真实的支付信息，你登录各种网站、社交平台时也会留下你的IP地址，这些都与你的身份有直接或者间接的关系。于是，一旦这些坏事发生，它们就不可避免的与你产生了关联。\n  4.3 我们要做的安全防护有哪些 基于上述分析，我们要做的，自然就是对【端口】、【用户名】、【密码】这三要素进行加强，来降低被攻破的风险：\n 【端口】：将SSH远程登录端口修改为【非22端口】 （4.4） 【用户名】：建立【非root】的新用户、并禁用root用户SSH远程登录 （4.5、4.6） 【密码】：SSH启用RSA密钥验证登录、同时禁用密码验证登录 （4.7）  记得按顺序来，别把自己锁在门外了。\n4.4 将SSH远程登录端口修改为非22端口 现在，我们来解决【端口 = 22】的问题。（注意：有些VPS服务商，默认的端口已经是非22端口，那么你可以忽略这一步，当然也可以跟着本文改成别的端口）\n  小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-03 nano 文本编辑器   cmd-04 systemctl restart 重启某个服务      小小白白Linux基础配置文件\n   编号 配置文件位置 文件说明     conf-01 /etc/ssh/sshd_config SSH远程登录程序设置      我们要做的第一件事，当然就是【用nano这个文本编辑器打开SSH远程登录程序设置】，在Windows下，你会【找到文件并双击】，在Linux下该怎么办呢？仔细看看上面的命令说明，是不是就很简单了？没错，就是：\n# nano /etc/ssh/sshd_config   文件打开后，你就进入了nano的界面，稍微观察一下，你会发现，它把重要的快捷键都显示在屏幕下方了（下图红框内），直接开卷考试、不用死记硬背，是不是很贴心呢？\n  我们要做的第二件事，是【在打开的文件中找到Port这一项，并修改它的端口】。Port后面的数字就是SSH的端口，一般建议把它改成一个大于1024小于65535的整数（本文以9753为例）。请结合nano的快捷键，想一下该怎么操作呢？果然，你又说对了！就是：\n 使用 ctrl+w 进入搜索模式，然后输入 Port 22 并回车 删除 22 并改成 9753 说明：如果这一行开头有个#，证明这一行【不生效】（被注释掉了），你可像我一样在文件最后写一个不带#的，或者把#删掉就好。    注意： 本文以9753为例，就意味着随着本文的发布，这个端口会变成一个不大不小的特征，也许会被攻击者优先尝试、也许被GFW干扰、阻断。所以我强烈建议你用一个自己想到的其他端口，毕竟，你有6万多个端口可以自由选择。\n  我们要做的第三件事，是【保存文件并退出】\n 如果第3步你有仔细观察，就会发现保存并不是常见的 ctrl+s。 正确的快捷键：保存是 ctrl+o + 回车，退出是 ctrl+x    我们最后要做的事，是【重启ssh服务，使变更生效】\n# systemctl restart ssh   完整流程演示如下：\n  修改 PuTTY 配置\n现在新的端口已经生效，下次使用PuTTY登录时就要用9753了。所以现在请到PuTTY的设置中修改端口号码，然后保存Session。嗯，你应该知道去哪里改了吧？（如果不知道的话，要重读前面的内容了哦！）\n  4.5 建立非root的新用户 第二步，我们来解决【用户名 = root】的问题。\n首先你要理解， Linux系统中的root，不仅仅是一个管理员账号那么简单。它是整个系统的【根基】、是系统的主宰、至高无上的神。一旦root账号出现安全问题，整个系统都只能任人鱼肉、无处可逃。那么就跟随我进行操作吧：\n  小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-05 adduser 给系统新增用户   cmd-06 apt install 安装某个软件   cmd-07 visudo 修改sudo权限设置专用编辑器      我们要做的第一件事，是【新增一个用户并设定登录密码】，名字你可以随便起，我这里以vpsadmin为例：\n# adduser vpsadmin 执行命令后，根据提示操作即可。请务必设置一个用户密码（别忘记设置密码时你时看不到 ****** 的）。之后系统会询问你一些用户的附加信息，这些就可以无视，一路回车即可。\n  注意： 本文以vpsadmin为例，就意味着随着本文的发布，这个用户名也会变成一个不大不小的特征，也许会被攻击者优先尝试。所以和端口一样，我强烈建议你用一个自己想到的其他用户名。\n  完整流程演示如下：\n  我们要做的第二件事，是【安装sudo功能】（sudo 就是在关键时刻，让普通账户临时获得 root 的神力，战力全开拯救世界）\n# apt update \u0026amp;\u0026amp; apt install sudo 聪明的你大概已经发现，这一行命令其实是两个命令。前一半 apt update 你之前已经见过并且用过了，是去服务器刷新软件版本信息。后面的 apt install 就是这一次要用到的【安装命令】。两条连接在一起，就是让系统去【刷新可用的最新软件，然后安装最新版的sudo程序】。 \u0026amp;\u0026amp; 则是把两个命令连起来执行的意思。\n  我们要做的第三件事，是【把vpsadmin用户加入sudo名单里，让他有资格借用root的神力】\n# visudo 在 User Priviledge Specification 下加入一行 vpsadmin ALL=(ALL) NOPASSWD: ALL 即可。\n  注意： 我要特别说明的是NOPASSWD这个设置，它的意思是vpsadmin用户临时使用root权限时，不用额外输入密码。这与一般的安全建议相反。我之所以如此推荐，是因为很多新人不顾危险坚持使用root账号就是因为用root时不用重复输入密码、觉得轻松。“两害相权取其轻”，我认为【直接用root用户的风险】大于【使用sudo时不用输密码的风险】，所以做了以上的建议。\n如果你希望遵守传统习惯、每次使用sudo时需要输入密码，那么这一行改成 vpsadmin ALL=(ALL:ALL) ALL 即可。\n  完整流程演示如下：\n  4.6 禁用root用户SSH远程登录   现在你已经逐渐熟悉Linux了，所以这次换你思考，我们要做的第一件事是什么呢？没错，还是【用nano编辑器打开SSH远程登录程序设置】，什么，你想不起来怎么操作了？那去复习一下上面的内容再回来吧！\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip; 正确答案：\n# nano /etc/ssh/sshd_config   找到PermitRootLogin Yes这一项，然后把它后面的设定值改为no即可。还记得怎么操作吗？\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip; 正确答案：\n 使用 ctrl+w 进入搜索模式，然后输入 PermitRootLogin 并回车 删除 yes 并改成 no    保存文件并退出。还记得怎么操作吗？\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip; 正确答案：\n 保存是 ctrl+o，然后 回车 确认 退出是 ctrl+x    重启ssh服务，让变更生效。还记得\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip; 算了直接公布正确答案：\n# systemctl restart ssh   完整流程演示如下：\n  下次通过PuTTY远程SSH登录的时候，root用户已无法连接，用户名就要换成vpsadmin了！方便起见，我们可以在PuTTY中把vpsadmin设置成默认登录用户名。（啰嗦君：别忘了保存Session）\n  4.7 使用RSA密钥登录并禁用密码登录 第三步，我们来解决【密码】可能被撞破的问题。\n前面我说过，黑客并不是很蠢的用穷举法破解你的密码，而是会用一些比如“密码表”的作弊手段。除非你用的是随机生成的超长密码（比如借助1Password，或者macOS的keychain等密码管理工具），否则很容易中招。\n超长随机密码虽然安全性有所提高，但是基本上无法记忆，手动输入也十分麻烦易错。为了解决这个困境，我们可以直接弃用【密码验证】方式，改用更安全的【密钥验证】。\n所谓的【密钥验证】，就是生成【一对】相关联的密钥文件（公钥和私钥），然后把【公钥】上传到VPS备用。每次登录时，SSH会将【公钥】和【私钥】进行匹配，若验证是正确的【密钥对】，则验证通过。（换言之，你无需记忆和输入复杂的密码，只要保护好【私钥】这个文件不外泄即可）\n那我们现在就来配置【密钥验证】吧！\n  运行PuTTYgen (PuTTY密钥生成器)。位置是 开始菜单 \u0026ndash;\u0026gt; 所有程序 \u0026ndash;\u0026gt; PuTTY (64-bit) \u0026ndash;\u0026gt; PuTTYgen\n  点击Generate开始生成（在界面空白处乱晃鼠标增加随机数）   你可以给私钥设置密码，增加一层安全性\n  点击 Save public key 保存公钥，文件名为 id_rsa.pub\n  点击 Save private key 保存私钥，文件名为 id_rsa (PuTTY私钥自带.ppk后缀)\n  最重要的，将上方红框内的内容，向下滚动全部复制出来并保存，文件名为 authorized_keys。（用vscode保存，默认会变成带txt后缀的文本文件，这没关系，之后上传VPS时我们会把后缀名去掉）     将公钥上传至VPS的vpsadmin用户下\n  这一步就需要用到之前准备的WinSCP了。\n  去官网下载并安装，会提示你导入PuTTY的设置，当然一键导入啦！   如果没有提示导入或者你已经提前安装好了，那按照下图进行配置即可   WinSCP左边的目录就是本地电脑上的文件夹和文件，请定位到密钥所在的文件夹\n  WinSCP右边的目录则是VPS服务器上的文件夹和文件，默认就在 /home/vpsadmin/ 文件夹，此时在请点击右下角 X hidden 来显示隐藏文件   在右边（VPS中）点击右键并新建文件夹，起名.ssh （注意有一个.）   将【公钥】authorized_keys上传到.ssh文件夹内   在上传时，将【公钥】从 authorized_keys.txt 改名为 authorized_keys（去掉.txt这个后缀名）   完整流程演示如下：     在VPS端设置SSH启用RSA密钥验证登录、同时禁用密码验证登录\n  小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-08 sudo 用root权限运行某个命令   cmd-09 chmod 修改目标文件/文件夹的权限      SSH远程连接到VPS上（PuTTY）\n  修改 authorized_keys 文件权限为 600 （仅所有者可读可写）\n$ chmod 600 ~/.ssh/authorized_keys   修改 SSH 配置。这个我们已经用了很多次，但现在我们已经从无所不能的root变成了普通用户vpsadmin，此时的我们是没有权限直接编辑SSH配置的。这时候就需要使用sudo命令了：\n$ sudo nano /etc/ssh/sshd_config   找到(ctrl+w) PasswordAuthentication 改成 no\n  找到(ctrl+w) PubkeyAuthentication 改成 yes，然后保存(ctrl+o)退出(ctrl+x)\n  重启SSH服务。（啰嗦君：别忘了现在需要使用sudo来获得权限）\n$ sudo systemctl restart ssh   完整流程如下：\n    VPS端已经设置好了公钥，现在要给PuTTY指定私钥位置供登录时使用（啰嗦君：别忘了保存Session）\n  至此，【密钥登录】已成功开启、【密码验证】已成功关闭、并且还给PuTTY保存了默认的登录用户名和私钥。未来使用PuTTY登录时，载入VPS-SERVER配置后，点击Open就可以一键登录了。\n如果你给私钥设置了密码保护，登录时当然还需要输入这个密码才能使用密钥，如下图：\n  4.8 你的进度 到这里为止，你的VPS已经完成了【端口】、【用户名】、【密码】这三要素的基本安全保障，虽然远称不上固若金汤，但一般的恶意脚本应该已经无法对你造成伤害了！\n现在我们终于有了一个安全的系统基础，下一章，我们就可以开始逐步安装配置Xray需要的基础设施了！（什么基础设施呢？一个网页，一张证书）\nPROGRESS⬛⬛⬛⬛⬜⬜⬜⬜ 50%\n "},{"uri":"https://xtls.github.io/config/outbound-protocols/http/","title":"HTTP","tags":[],"description":"Project X 的文档.","content":"HTTP 协议。\nimportanthttp 协议没有对传输加密，不适宜经公网中传输，更容易成为被人用作攻击的肉鸡。\nhttp inbound 更有意义的用法是在局域网或本机环境下监听，为其他程序提供本地服务。\n TIP\nhttp proxy 只能代理 tcp 协议，udp 系的协议均不能通过。\n OutboundConfigurationObject  { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;192.168.108.1\u0026#34;, \u0026#34;port\u0026#34;: 3128, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; } ] } ] }  TIP\n目前 HTTP 协议 ounbound 中 streamSettings 设置 security 和 tlsSettings 是生效的。\n servers: [ ServerObject ]\n HTTP 服务器列表，其中每一项是一个服务器配置，若配置多个，循环使用 (RoundRobin)。\n\nServerObject  { \u0026#34;address\u0026#34;: \u0026#34;192.168.108.1\u0026#34;, \u0026#34;port\u0026#34;: 3128, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; } ] }  address: string\n HTTP 代理服务器地址，必填。\nport: int\n HTTP 代理服务器端口，必填。\nuser: [AccountObject]\n 一个数组，数组中每个元素为一个用户帐号。默认值为空。\n\nAccountObject  { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; }  user: string\n 用户名，字符串类型。必填。\npass: string\n 密码，字符串类型。必填。\n"},{"uri":"https://xtls.github.io/config/transports/mkcp/","title":"mKCP","tags":[],"description":"Project X 的文档.","content":"mKCP 使用 UDP 来模拟 TCP 连接。\nmKCP 牺牲带宽来降低延迟。传输同样的内容，mKCP 一般比 TCP 消耗更多的流量。\nTIP\n请确定主机上的防火墙配置正确\n KcpObject  KcpObject 对应传输配置的 kcpSettings 项。\n{ \u0026#34;mtu\u0026#34;: 1350, \u0026#34;tti\u0026#34;: 20, \u0026#34;uplinkCapacity\u0026#34;: 5, \u0026#34;downlinkCapacity\u0026#34;: 20, \u0026#34;congestion\u0026#34;: false, \u0026#34;readBufferSize\u0026#34;: 1, \u0026#34;writeBufferSize\u0026#34;: 1, \u0026#34;header\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }, \u0026#34;seed\u0026#34;: \u0026#34;Password\u0026#34; }  mtu: number\n 最大传输单元（maximum transmission unit）\n请选择一个介于 576 - 1460 之间的值。\n默认值为 1350。\ntti: number\n 传输时间间隔（transmission time interval），单位毫秒（ms），mKCP 将以这个时间频率发送数据。\n请选译一个介于 10 - 100 之间的值。\n默认值为 50。\nuplinkCapacity: number\n 上行链路容量，即主机发出数据所用的最大带宽，单位 MB/s，注意是 Byte 而非 bit。\n可以设置为 0，表示一个非常小的带宽。\n默认值 5。\ndownlinkCapacity: number\n 下行链路容量，即主机接收数据所用的最大带宽，单位 MB/s，注意是 Byte 而非 bit。\n可以设置为 0，表示一个非常小的带宽。\n默认值 20。\nTIP\nuplinkCapacity 和 downlinkCapacity 决定了 mKCP 的传输速度。\n以客户端发送数据为例，客户端的 uplinkCapacity 指定了发送数据的速度，而服务器端的 downlinkCapacity 指定了接收数据的速度。两者的值以较小的一个为准。\n推荐把 downlinkCapacity 设置为一个较大的值，比如 100，而 uplinkCapacity 设为实际的网络速度。当速度不够时，可以逐渐增加 uplinkCapacity 的值，直到带宽的两倍左右。\n congestion: true | false\n 是否启用拥塞控制。\n开启拥塞控制之后，Xray 会自动监测网络质量，当丢包严重时，会自动降低吞吐量；当网络畅通时，也会适当增加吞吐量。\n默认值为 false\nreadBufferSize: number\n 单个连接的读取缓冲区大小，单位是 MB。\n默认值为 2。\nwriteBufferSize: number\n 单个连接的写入缓冲区大小，单位是 MB。\n默认值为 2。\nTIP\nreadBufferSize 和 writeBufferSize 指定了单个连接所使用的内存大小。\n在需要高速传输时，指定较大的 readBufferSize 和 writeBufferSize 会在一定程度上提高速度，但也会使用更多的内存。\n在网速不超过 20MB/s 时，默认值 1MB 可以满足需求；超过之后，可以适当增加 readBufferSize 和 writeBufferSize 的值，然后手动平衡速度和内存的关系。\n header: HeaderObject\n 数据包头部伪装设置\nseed: string\n 可选的混淆密码，使用 AES-128-GCM 算法混淆流量数据，客户端和服务端需要保持一致。\n本混淆机制不能用于保证通信内容的安全，但可能可以对抗部分封锁。 TIP\n目前测试环境下开启此设置后没有出现原版未混淆版本的封端口现象\n \nHeaderObject  { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }  type: string\n 伪装类型，可选的值有：\n \u0026quot;none\u0026quot;：默认值，不进行伪装，发送的数据是没有特征的数据包。 \u0026quot;srtp\u0026quot;：伪装成 SRTP 数据包，会被识别为视频通话数据（如 FaceTime）。 \u0026quot;utp\u0026quot;：伪装成 uTP 数据包，会被识别为 BT 下载数据。 \u0026quot;wechat-video\u0026quot;：伪装成微信视频通话的数据包。 \u0026quot;dtls\u0026quot;：伪装成 DTLS 1.2 数据包。 \u0026quot;wireguard\u0026quot;：伪装成 WireGuard 数据包。（并不是真正的 WireGuard 协议）  \n鸣谢   @skywind3000 发明并实现了 KCP 协议。 @xtaci 将 KCP 由 C 语言实现翻译成 Go。 @xiaokangwang 测试 KCP 与 Xray 的整合并提交了最初的 PR。  \n对 KCP 协议的改进  更小的协议头  原生 KCP 协议使用了 24 字节的固定头部，而 mKCP 修改为数据包 18 字节，确认（ACK）包 16 字节。更小的头部有助于躲避特征检查，并加快传输速度。\n另外，原生 KCP 的单个确认包只能确认一个数据包已收到，也就是说当 KCP 需要确认 100 个数据已收到时，它会发出 24 * 100 = 2400 字节的数据。其中包含了大量重复的头部数据，造成带宽的浪费。mKCP 会对多个确认包进行压缩，100 个确认包只需要 16 + 2 + 100 * 4 = 418 字节，相当于原生的六分之一。\n确认包重传  原生 KCP 协议的确认（ACK）包只发送一次，如果确认包丢失，则一定会导致数据重传，造成不必要的带宽浪费。而 mKCP 会以一定的频率重发确认包，直到发送方确认为止。单个确认包的大小为 22 字节，相比起数据包的 1000 字节以上，重传确认包的代价要小得多。\n连接状态控制  mKCP 可以有效地开启和关闭连接。当远程主机主动关闭连接时，连接会在两秒钟之内释放；当远程主机断线时，连接会在最多 30 秒内释放。\n原生 KCP 不支持这个场景。\n"},{"uri":"https://xtls.github.io/develop/protocols/mkcp/","title":"mKCP 协议","tags":[],"description":"Project X 的文档.","content":"mKCP 是流式传输协议，由 KCP 协议修改而来，可以按顺序传输任意的数据流。\n\n版本  mKCP 没有版本号，不保证版本之间兼容性。\n\n依赖  底层协议  mKCP 是一个基于 UDP 的协议，所有通讯使用 UDP 传输。\n\n函数   fnv: FNV-1a 哈希函数  输入参数为任意长度的字符串； 输入出一个 32 位无符号整数；    \n通讯过程   mKCP 将数据流拆成若干个数据包进行发送。一个数据流有一个唯一标识，用以区分不同的数据流。数据流中的每一个数据包都携带了同样的标识。 mKCP 没有握手过程，当收到一个数据包时，根据其携带的数据流的标识来判断是否为新的通话，或是正在进行中的通话。 每一个数据包中包含若干个片段（Segment），片段分为三类：数据（Data）、确认（ACK）、心跳（Ping）。每个片段需要单独处理。  \n数据格式  数据包     4 字节 2 字节 L 字节     认证信息 A 数据长度 L 片段部分    其中：\n 认证信息 A = fnv(片段部分），big endian； 片段部分可能包含多个片段；  \n数据片段     2 字节 1 字节 1 字节 4 字节 4 字节 4 字节 2 字节 Len 字节     标识 Conv 指令 Cmd 选项 Opt 时间戳 Ts 序列号 Sn 未确认序列号 Una 长度 Len 数据    其中：\n 标识 Conv: mKCP 数据流的标识 指令 Cmd: 常量 0x01 选项 Opt: 可选的值有：  0x00: 空选项 0x01: 对方已发出所有数据   时间戳 Ts: 当前片段从远端发送出来时的时间，big endian 序列号 Sn: 该数据片段时数据流中的位置，起始片段的序列号为 0，之后每个新片段按顺序加 1 未确认序列号 Una: 远端主机正在发送的，且尚未收到确认的最小的 Sn  \n确认片段     2 字节 1 字节 1 字节 4 字节 4 字节 4 字节 2 字节 Len * 4 字节     标识 Conv 指令 Cmd 选项 Opt 窗口 Wnd 下一接收序列号 Sn 时间戳 Ts 长度 Len 已收到的序列号    其中：\n 标识 Conv: mKCP 数据流的标识 指令 Cmd: 常量 0x00 选项 Opt: 同上 窗口 Wnd: 远端主机可以接收的最大序列号 下一接收序列号 Sn: 远端主机未收到的数据片段中的最小序列号 时间戳 Ts: 远端主机最新收到的数据片段的时间戳，可用于计算延迟 已收到的序列号: 每个 4 字节，表示此序列号的数据已经确认收到  注释：\n 远程主机期待收到序列号 [Sn, Wnd) 范围内的数据  \n心跳片段     2 字节 1 字节 1 字节 4 字节 4 字节 4 字节     标识 Conv 指令 Cmd 选项 Opt 未确认序列号 Una 下一接收序列号 Sn 延迟 Rto    其中：\n 标识 Conv: mKCP 数据流的标识 指令 Cmd: 可选的值有  0x02: 远端主机强行终止会话 0x03: 正常心跳   选项 Opt: 同上 未确认序列号 Una: 同数据片段的 Una 下一接收序列号 Sn: 同确认片段的 Sn 延迟 Rto: 远端主机自己计算出的延迟  "},{"uri":"https://xtls.github.io/config/inbound-protocols/socks/","title":"Socks","tags":[],"description":"Project X 的文档.","content":"标准 Socks 协议实现，兼容 Socks 4、Socks 4a 和 Socks 5。\nimportantsocks 协议没有对传输加密，不适宜经公网中传输\nsocks inbound 更有意义的用法是在局域网或本机环境下监听，为其他程序提供本地服务。\n InboundConfigurationObject { \u0026#34;auth\u0026#34;: \u0026#34;noauth\u0026#34;, \u0026#34;accounts\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; } ], \u0026#34;udp\u0026#34;: false, \u0026#34;ip\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;userLevel\u0026#34;: 0 }  auth: \u0026ldquo;noauth\u0026rdquo; | \u0026ldquo;password\u0026rdquo;\n Socks 协议的认证方式，支持 \u0026quot;noauth\u0026quot; 匿名方式和 \u0026quot;password\u0026quot; 用户密码方式。\n默认值为 \u0026quot;noauth\u0026quot;。\naccounts: [ AccountObject ]\n 一个数组，数组中每个元素为一个用户帐号。\n此选项仅当 auth 为 password 时有效。\n默认值为空。\nudp: true | false\n 是否开启 UDP 协议的支持。\n默认值为 false。\nip: address\n 当开启 UDP 时，Xray 需要知道本机的 IP 地址。\n默认值为 \u0026quot;127.0.0.1\u0026quot;。\nuserLevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n\nAccountObject  { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; }  user: string\n 用户名，字符串类型。必填。\npass: string\n 密码，字符串类型。必填。\n"},{"uri":"https://xtls.github.io/documents/level-1/work/","title":"Xray的工作模式","tags":[],"description":"Project X 的文档.","content":"单服务器模式  与其它的网络代理工具一样，你需要一台配置了 Xray 的服务器，然后在自己的设备上安装并配置 Xray 客户端，然后即可流畅地访问互联网。\nmermaid.initialize({startOnLoad:true}); graph LR; A(PC) -.- B(防火墙); B -.- C(墙外网站); A -- D(Xray/VPS); D -- C; A -- E(墙内网站);  一个 Xray 服务器可同时支持多台设备使用不同的代理协议访问。同时，经过合理的配置，Xray 可以识别并区分需要代理以及不需要代理的流量，直连的流量不需要绕路。\n\n桥接模式  如果你不想在每一台设备上都配置路由，你也可以设置一台中转服务器，用于接收客户端发来的所有流量，然后在服务器中进行转发判断。\nmermaid.initialize({startOnLoad:true}); graph LR; A(PC) -.- B(防火墙); B -.- C(墙外网站); A -- D(墙内 VPS); D -- E(墙外 VPS); E -- C; D -- F(墙内网站);  \n工作原理  在配置 Xray 之前，不妨先来看一下 Xray 的工作原理，以下是单个 Xray 进程的内部结构示意图。多个 Xray 之间相互独立，互不影响。\nmermaid.initialize({startOnLoad:true}); graph LR; A1(inbound) -- D(Dispatcher / Router / DNS); A2(inbound) -- D; A3(inbound) -- D; A4(inbound) -- D; D -- B1(outbound); D -- B2(outbound); D -- B3(outbound); D -- B4(outbound);   需要配置至少一个入站连接（Inbound）和一个出站连接（Outbound）才可以正常工作。  入站连接负责与客户端（如浏览器）通信：  入站连接通常可以配置用户认证，如 ID 和密码等； 入站连接收到数据之后，会交给分发器（Dispatcher）进行分发；   出站连接负责将数据发给服务器，如另一台主机上的 Xray。   当有多个出站连接时，可以配置路由（Routing）来指定某一类流量由某一个出站连接发出。  路由会在必要时查询 DNS 以获取更多信息来进行判断。    "},{"uri":"https://xtls.github.io/documents/","title":"使用心得","tags":[],"description":"Project X 的文档.","content":" 这个章节包含各种使用技巧,使用心得,大多来自于实际使用中的经验 小小白白话文 给予新手指导的使用心得\n请点击小小白白话文以进行查看\n 入门技巧 具备了基础之后，你就可以通过入门技巧来探索更多的使用方式了  进阶文档 给予进阶用户指导的使用技巧\n点击进阶文档以进行查看\n  \n致谢非常感谢大家无私分享使用技巧和心得, 使得Xray日益强大.\n "},{"uri":"https://xtls.github.io/guide/document/","title":"使用文档","tags":[],"description":"Project X 的文档.","content":"查看文档   您可以使用左侧的菜单选择您要看的相关分类\n  选择某一项菜单之后, 可以在正文区顶部的导航栏快速切换此分类中的文章.\n   在查看文章时, 可以通过右边的标题列表, 快速切换到其中一个标题.\n   改进文档  Project X 的文档托管在github上.\n您可以通过以下步骤, 提交您对文档的改动:\n  从project X 文档仓库打开仓库, 点击右上角的 fork, fork 一份文档仓库的镜像到您自己的 github 仓库.\n  使用任何您喜欢的工具, 从您克隆的仓库获得文档的克隆, 如:\n    git clone https://github.com/yours/XTLS.github.io   基于 main 分支创建新的分支, 如:    git checkout -b your-branch    在新分支上做修改, 完成后提交修改\n  推送创建的分支到您的仓库\n    git push -u origin your-branch    打开 github, 点击 \u0026lsquo;Pull request\u0026rsquo; 向 project X 文档仓库发出PR.\n  请在 PR 的标题和正文中，概述此次 PR 新增/修改的内容等；\n  等待回应, 如果 PR 被 merge, 您做的修改将直接呈现在 Project X 文档网站。\n  "},{"uri":"https://xtls.github.io/config/routing/","title":"路由","tags":[],"description":"Project X 的文档.","content":"路由功能模块可以将入站数据按不同规则由不同的出站连接发出，以达到按需代理的目的。\n如常见用法是分流国内外流量，Xray 可以通过内部机制判断不同地区的流量，然后将它们发送到不同的出站代理。\nRoutingObject  RoutingObject 对应配置文件的 routing 项。\n{ \u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;rules\u0026#34;: [], \u0026#34;balancers\u0026#34;: [] } }  domainStrategy: \u0026ldquo;AsIs\u0026rdquo; | \u0026ldquo;IPIfNonMatch\u0026rdquo; | \u0026ldquo;IPOnDemand\u0026rdquo;\n 域名解析策略，根据不同的设置使用不同的策略。\n \u0026quot;AsIs\u0026quot;：只使用域名进行路由选择。默认值。 \u0026quot;IPIfNonMatch\u0026quot;：当域名没有匹配任何规则时，将域名解析成 IP（A 记录或 AAAA 记录）再次进行匹配；  当一个域名有多个 A 记录时，会尝试匹配所有的 A 记录，直到其中一个与某个规则匹配为止； 解析后的 IP 仅在路由选择时起作用，转发的数据包中依然使用原始域名；   \u0026quot;IPOnDemand\u0026quot;：当匹配时碰到任何基于 IP 的规则，将域名立即解析为 IP 进行匹配；  rules: [RuleObject]\n 对应一个数组，数组中每个元素是一个规则。\n对于每一个连接，路由将根据这些规则依次进行判断，当一个规则生效时，即将这个连接转发至它所指定的 outboundTag或 balancerTag。\nTIP\n当没有匹配到任何规则时，流量默认由第一个outbound发出。\n balancers: [ BalancerObject ]\n 一个数组，数组中每个元素是一个负载均衡器的配置。\n当一个规则指向一个负载均衡器时，Xray 会通过此负载均衡器选出一个outbound, 然后由它转发流量。\n\nRuleObject  { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;baidu.com\u0026#34;, \u0026#34;qq.com\u0026#34;, \u0026#34;geosite:cn\u0026#34; ], \u0026#34;ip\u0026#34;: [ \u0026#34;0.0.0.0/8\u0026#34;, \u0026#34;10.0.0.0/8\u0026#34;, \u0026#34;fc00::/7\u0026#34;, \u0026#34;fe80::/10\u0026#34;, \u0026#34;geoip:cn\u0026#34; ], \u0026#34;port\u0026#34;: \u0026#34;53,443,1000-2000\u0026#34;, \u0026#34;sourcePort\u0026#34;: \u0026#34;53,443,1000-2000\u0026#34;, \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;source\u0026#34;: [ \u0026#34;10.0.0.1\u0026#34; ], \u0026#34;user\u0026#34;: [ \u0026#34;love@xray.com\u0026#34; ], \u0026#34;inboundTag\u0026#34;: [ \u0026#34;tag-vmess\u0026#34; ], \u0026#34;protocol\u0026#34;: [ \u0026#34;http\u0026#34;, \u0026#34;tls\u0026#34;, \u0026#34;bittorrent\u0026#34; ], \u0026#34;attrs\u0026#34;: \u0026#34;attrs[\u0026#39;:method\u0026#39;] == \u0026#39;GET\u0026#39;\u0026#34;, \u0026#34;outboundTag\u0026#34;: \u0026#34;direct\u0026#34;, \u0026#34;balancerTag\u0026#34;: \u0026#34;balancer\u0026#34; } \nimportant当多个属性同时指定时，这些属性需要 同时 满足，才可以使当前规则生效。\n type: \u0026ldquo;field\u0026rdquo;\n 目前只支持\u0026quot;field\u0026quot;这一个选项。\ndomain: [string]\n 一个数组，数组每一项是一个域名的匹配。有以下几种形式：\n 纯字符串：当此字符串匹配目标域名中任意部分，该规则生效。比如 \u0026ldquo;sina.com\u0026rdquo; 可以匹配 \u0026ldquo;sina.com\u0026rdquo;、\u0026ldquo;sina.com.cn\u0026rdquo; 和\u0026quot;www.sina.com\u0026quot;，但不匹配 \u0026ldquo;sina.cn\u0026rdquo;。 正则表达式：由 \u0026quot;regexp:\u0026quot; 开始，余下部分是一个正则表达式。当此正则表达式匹配目标域名时，该规则生效。例如 \u0026ldquo;regexp:\\\\.goo.*\\\\.com$\u0026rdquo; 匹配\u0026quot;www.google.com\u0026quot;或 \u0026ldquo;fonts.googleapis.com\u0026rdquo;，但不匹配 \u0026ldquo;google.com\u0026rdquo;。 子域名（推荐）：由 \u0026quot;domain:\u0026quot; 开始，余下部分是一个域名。当此域名是目标域名或其子域名时，该规则生效。例如 \u0026ldquo;domain:xray.com\u0026rdquo; 匹配\u0026quot;www.xray.com\u0026quot;、\u0026ldquo;xray.com\u0026rdquo;，但不匹配 \u0026ldquo;xray.com\u0026rdquo;。 完整匹配：由 \u0026quot;full:\u0026quot; 开始，余下部分是一个域名。当此域名完整匹配目标域名时，该规则生效。例如 \u0026ldquo;full:xray.com\u0026rdquo; 匹配 \u0026ldquo;xray.com\u0026rdquo; 但不匹配\u0026quot;www.xray.com\u0026quot;。 预定义域名列表：由 \u0026quot;geosite:\u0026quot; 开头，余下部分是一个名称，如 geosite:google 或者 geosite:cn。名称及域名列表参考 预定义域名列表。 从文件中加载域名：形如 \u0026quot;ext:file:tag\u0026quot;，必须以 ext:（小写）开头，后面跟文件名和标签，文件存放在 资源目录 中，文件格式与 geosite.dat 相同，标签必须在文件中存在。 TIP\n\u0026quot;ext:geoip.dat:cn\u0026quot; 等价于 \u0026quot;geoip:cn\u0026quot;\n   ip: [string]\n 一个数组，数组内每一个元素代表一个 IP 范围。当某一元素匹配目标 IP 时，此规则生效。有以下几种形式：\n IP：形如 \u0026quot;127.0.0.1\u0026quot;。 CIDR：形如 \u0026quot;10.0.0.0/8\u0026quot;。 预定义IP列表：此列表预置于每一个 Xray 的安装包中，文件名为 geoip.dat。使用方式形如 \u0026quot;geoip:cn\u0026quot;，必须以 geoip:（小写）开头，后面跟双字符国家代码，支持几乎所有可以上网的国家。  特殊值：\u0026quot;geoip:private\u0026quot;，包含所有私有地址，如 127.0.0.1。   从文件中加载 IP：形如 \u0026quot;ext:file:tag\u0026quot;，必须以 ext:（小写）开头，后面跟文件名和标签，文件存放在 资源目录 中，文件格式与 geoip.dat 相同标签必须在文件中存在。  port：number | string\n 目标端口范围，有三种形式：\n \u0026quot;a-b\u0026quot;：a 和 b 均为正整数，且小于 65536。这个范围是一个前后闭合区间，当目标端口落在此范围内时，此规则生效。 a：a 为正整数，且小于 65536。当目标端口为 a 时，此规则生效。 以上两种形式的混合，以逗号 \u0026ldquo;,\u0026rdquo; 分隔。形如：\u0026quot;53,443,1000-2000\u0026quot;。  sourcePort：number | string\n 来源端口，有三种形式：\n \u0026quot;a-b\u0026quot;：a 和 b 均为正整数，且小于 65536。这个范围是一个前后闭合区间，当目标端口落在此范围内时，此规则生效。 a：a 为正整数，且小于 65536。当目标端口为 a 时，此规则生效。 以上两种形式的混合，以逗号 \u0026ldquo;,\u0026rdquo; 分隔。形如：\u0026quot;53,443,1000-2000\u0026quot;。  network: \u0026ldquo;tcp\u0026rdquo; | \u0026ldquo;udp\u0026rdquo; | \u0026ldquo;tcp,udp\u0026rdquo;\n 可选的值有 \u0026ldquo;tcp\u0026rdquo;、\u0026ldquo;udp\u0026rdquo; 或 \u0026ldquo;tcp,udp\u0026rdquo;，当连接方式是指定的方式时，此规则生效。\nsource: [string]\n 一个数组，数组内每一个元素是一个 IP 或 CIDR。当某一元素匹配来源 IP 时，此规则生效。\nuser: [string]\n 一个数组，数组内每一个元素是一个邮箱地址。当某一元素匹配来源用户时，此规则生效。\ninboundTag: [string]\n 一个数组，数组内每一个元素是一个标识。当某一元素匹配入站协议的标识时，此规则生效。\nprotocol: [ \u0026ldquo;http\u0026rdquo; | \u0026ldquo;tls\u0026rdquo; | \u0026ldquo;bittorrent\u0026rdquo; ]\n 一个数组，数组内每一个元素表示一种协议。当某一个协议匹配当前连接的协议类型时，此规则生效。 TIP\n必须开启入站代理中的 sniffing 选项, 才能嗅探出连接所使用的协议类型.\n attrs: string\n 一段脚本，用于检测流量的属性值。当此脚本返回真值时，此规则生效。\n脚本语言为 Starlark，它的语法是 Python 的子集。脚本接受一个全局变量 attrs，其中包含了流量相关的属性。\n目前只有 http 入站代理会设置这一属性。\n示例：\n 检测 HTTP GET：\u0026quot;attrs[':method'] == 'GET'\u0026quot; 检测 HTTP Path：\u0026quot;attrs[':path'].startswith('/test')\u0026quot; 检测 Content Type：\u0026quot;attrs['accept'].index('text/html') \u0026gt;= 0\u0026quot;  outboundTag: string\n 对应一个outbound的标识。\nbalancerTag: string\n 对应一个Balancer的标识。\nTIP\nbalancerTag 和 outboundTag 须二选一。当同时指定时，outboundTag 生效。\n \nBalancerObject  负载均衡器配置。当一个负载均衡器生效时，它会从指定的outbound中，按配置选出一个最合适的outbound，进行流量转发。\n{ \u0026#34;tag\u0026#34;: \u0026#34;balancer\u0026#34;, \u0026#34;selector\u0026#34;: [] }  tag: string\n 此负载均衡器的标识，用于匹配 RuleObject 中的 balancerTag。\nselector: [ string ]\n 一个字符串数组，其中每一个字符串将用于和outbound标识的前缀匹配。在以下几个outbound标识中：[ \u0026quot;a\u0026quot;, \u0026quot;ab\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;ba\u0026quot; ]，\u0026quot;selector\u0026quot;: [\u0026quot;a\u0026quot;] 将匹配到 [ \u0026quot;a\u0026quot;, \u0026quot;ab\u0026quot; ]。\n如果匹配到多个outbound，负载均衡器目前会从中随机选出一个作为最终的outbound。\n\n预定义域名列表  此列表预置于每一个 Xray 的安装包中，文件名为 geosite.dat。这个文件包含了一些常见的域名，使用方式：geosite:filename，如 geosite:google 表示对文件内符合 google 内包含的域名，进行路由筛选或 DNS 筛选。\n常见的域名有：\n category-ads：包含了常见的广告域名。 category-ads-all：包含了常见的广告域名，以及广告提供商的域名。 cn：相当于 geolocation-cn 和 tld-cn 的合集。 apple：包含了 Apple 旗下绝大部分域名。 google：包含了 Google 旗下绝大部分域名。 microsoft：包含了 Microsoft 旗下绝大部分域名。 facebook：包含了 Facebook 旗下绝大部分域名。 twitter：包含了 Twitter 旗下绝大部分域名。 telegram：包含了 Telegram 旗下绝大部分域名。 geolocation-cn：包含了常见的大陆站点域名。 geolocation-!cn：包含了常见的非大陆站点域名，同时包含了 tld-!cn。 tld-cn：包含了 CNNIC 管理的用于中国大陆的顶级域名，如以 .cn、.中国 结尾的域名。 tld-!cn：包含了非中国大陆使用的顶级域名，如以 .hk（香港）、.tw（台湾）、.jp（日本）、.sg（新加坡）、.us（美国）.ca（加拿大）等结尾的域名。  "},{"uri":"https://xtls.github.io/documents/level-2/","title":"进阶文档","tags":[],"description":"Project X 的文档.","content":" 这个章节包含进阶级的Xray使用心得分享, 如果您已经熟悉Xray, 那么这里的经验可以让您更加发挥Xray的威力 \n 透明代理（TProxy）配置教程  by @BioniCosmos\n 基于Xray的透明代理（TProxy）配置完整教程。\n tproxy配置方案 by @kirin\n 这是里tproxy透明代理的另一种iptbales配置方案 In progress\n"},{"uri":"https://xtls.github.io/qa/tproxy/","title":"透明代理相关问题","tags":[],"description":"Project X 的文档.","content":" Q: 我搭建了透明代理给我和我同宿舍/隔壁宿舍的同学用, 日志中出现很多 too many open files .怎么办? 急,在线等.让你的同学少用BT过代理下载American Video 在 /etc/systemd/system/xray.service 的 [Service] 下加 LimitNPROC=10000 和 LimitNOFILE=1000000.\n Q: sniffing的具体功能是什么，什么时候发挥作用?sniffing流量探测主要作用是用在透明代理等用途.\n他的一个典型工作流程是这样的.\n比如你有一个设备上网,去访问abc.com, 首先设备通过DNS查询得到abc.com的IP是1.2.3.4,然后设备会向1.2.3.4发起连接.\n 透明代理不设置嗅探的话,收到的连接请求是1.2.3.4,是不能走域名规则的路由分流的. 透明代理设置了sniffing,处理这个流量时,会从这个流量的数据中,嗅探出域名,abc.com. 然后把1.2.3.4重置为abc.com. 路由就可以根据域名进行符合域名规则的分流, 或者做更多的事情.  因为变成了一个向abc.com请求的连接,就可以做更多的事情,包括路由域名规则分流, 重新做DNS解析等等\u0026hellip;\n另一个sniffing的作用是可以嗅探BT流量的标识,把流量归类成BT类型. 然后可以在路由中根据BT类型来做规则,比如服务端用来拦截BT流量,比如客户端把BT流量固定发送到某个VPS去代理等.\n "},{"uri":"https://xtls.github.io/config/transports/h2/","title":"HTTP/2","tags":[],"description":"Project X 的文档.","content":"基于 HTTP/2 的传输方式。\n它完整按照 HTTP/2 标准实现，可以通过其它的 HTTP 服务器（如 Nginx）进行中转。\n由 HTTP/2 的建议，客户端和服务器必须同时开启 TLS 才可以正常使用这个传输方式。\nTIP\n当前版本的 HTTP/2 的传输方式并不强制要求服务器端有 TLS 配置.\n这使得可以在特殊用途的分流部署环境中，由外部网关组件完成 TLS 层对话，Xray 作为后端应用，网关和 Xray 间使用称为 h2c 的明文 http/2 进行通讯。\n HttpObject  HttpObject 对应传输配置的 httpSettings 项。\n{ \u0026#34;host\u0026#34;: [\u0026#34;xray.com\u0026#34;], \u0026#34;path\u0026#34;: \u0026#34;/random/path\u0026#34; }  host: [string]\n 一个字符串数组，每一个元素是一个域名。\n客户端会随机从列表中选出一个域名进行通信，服务器会验证域名是否在列表中。\npath string\n HTTP 路径，由 / 开头, 客户端和服务器必须一致。\n默认值为 \u0026quot;/\u0026quot;。\n"},{"uri":"https://xtls.github.io/config/inbound-protocols/","title":"inbound可用协议列表","tags":[],"description":"Project X 的文档.","content":" 这个章节包含了目前所有可用于inbound的协议及具体配置细节. 协议列表   dokodemo-door\n Dokodemo door（任意门）可以监听一个本地端口，并把所有进入此端口的数据发送至指定服务器的一个端口，从而达到端口映射的效果。 http\n HTTP 协议 socks\n 标准 Socks 协议实现，兼容 Socks 4、Socks 4a 和 Socks 5。 vless\n VLESS 是一个无状态的轻量传输协议，可以作为 Xray 客户端和服务器之间的桥梁。 VMess\n VMess 是一个加密传输协议，，可以作为 Xray 客户端和服务器之间的桥梁。 trojan\n Trojan协议 shadowsocks\n Shadowsocks 协议。\n"},{"uri":"https://xtls.github.io/config/outbound-protocols/socks/","title":"Socks","tags":[],"description":"Project X 的文档.","content":"标准 Socks 协议实现，兼容 Socks 4、Socks 4a 和 Socks 5。\nimportantsocks 协议没有对传输加密，不适宜经公网中传输\nsocks inbound 更有意义的用法是在局域网或本机环境下监听，为其他程序提供本地服务。\n OutboundConfigurationObject  { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;test user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;test pass\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }  servers: [ ServerObject ]\n Socks 服务器列表，其中每一项是一个服务器配置。\nServerObject { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;test user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;test pass\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] }  address: address\n 服务器地址, 必填\nTIP\n仅支持连接到 Socks 5 服务器。\n port: number\n 服务器端口, 必填\nusers: [ UserObject ]\n 一个数组表示的用户列表，数组中每个元素为一个用户配置。\n当列表不为空时，Socks 客户端会使用用户信息进行认证；如未指定，则不进行认证。\n默认值为空。\n\nUserObject  { \u0026#34;user\u0026#34;: \u0026#34;test user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;test pass\u0026#34;, \u0026#34;level\u0026#34;: 0 }  user: string\n 用户名，字符串类型。必填。\npass: string\n 密码，字符串类型。必填。\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0\n"},{"uri":"https://xtls.github.io/config/inbound-protocols/vless/","title":"VLESS","tags":[],"description":"Project X 的文档.","content":" important目前 VLESS 没有自带加密，请用于可靠信道，如 TLS。 目前 VLESS 不支持分享。\n VLESS 是一个无状态的轻量传输协议，它分为入站和出站两部分，可以作为 Xray 客户端和服务器之间的桥梁。\n与 VMess 不同，VLESS 不依赖于系统时间，认证方式同样为 UUID，但不需要 alterId。\nInboundConfigurationObject { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34; } ], \u0026#34;decryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;fallbacks\u0026#34;: [ { \u0026#34;dest\u0026#34;: 80 } ] }  clients: [ ClientObject ]\n 一个数组，代表一组服务端认可的用户.\n其中每一项是一个用户ClientObject。\n decryption: \u0026ldquo;none\u0026rdquo;\n 现阶段需要填 \u0026quot;none\u0026quot;，不能留空。 若未正确设置 decryption 的值，使用 Xray 或 -test 时会收到错误信息。\n注意这里是 decryption，和 clients 同级。 decryption 和 vmess 协议的 encryption 的位置不同，是因为若套一层约定加密，服务端需要先解密才能知道是哪个用户。\nfallbacks: [ FallbackObject ]\n 一个数组，包含一系列强大的回落分流配置（可选）。\n ClientObject  { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34; }  id: string\n VLESS 的用户 ID，必须是一个合法的 UUID，你也可以用 UUID 生成它。\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nemail: string\n 用户邮箱，用于区分不同用户的流量（日志、统计）。\n 配置模板  Xray-examples 有完整的 VLESS 配置示例供参考。（但目前不能保证其它协议的配置示例质量）\n 客户端开发指引   VLESS 协议本身还会有不兼容升级，但客户端配置文件参数基本上是只增不减的。所以如果你开发了用 core 的客户端，现在就可以适配。 iOS 客户端的协议实现则需紧跟升级。 视觉标准：UI 标识请统一用 VLESS，而不是 VLess / Vless / vless，配置文件不受影响，代码内则顺其自然。 encryption 应做成输入框而不是选择框，新配置的默认值应为 none，若用户置空则应代填 none。  以下为已支持图形化配置 VLESS 的部分客户端列表，推荐使用：（按实现时间先后顺序排列）\n 新型协议回落模式解析  In progress\n VLESS 分享链接标准  In progress\n"},{"uri":"https://xtls.github.io/qa/fallback/","title":"回落相关问题","tags":[],"description":"Project X 的文档.","content":" Q: 回落是个啥?好吃吗?Fallback 是 Xray 的最强大功能之一, 可有效防止主动探测, 自由配置常用端口多服务共享\n点此查看详情 回落\n Q: 为什么我回落以后nginx日志的IP是 127.0.0.1?需要开启 proxy protocol. 参见fallbacks配置的xver参数\n Q: 我还是上一题的提问者, 那么我如何使用proxy protocol,达到所有日志都有源IP的目的呢?等待好心人写一篇小小白白话文\n "},{"uri":"https://xtls.github.io/develop/","title":"开发指南","tags":[],"description":"Project X 的文档.","content":"In progress\n"},{"uri":"https://xtls.github.io/config/policy/","title":"本地策略","tags":[],"description":"Project X 的文档.","content":"本地策略，可以设置不同的用户等级和对应的策略设置，比如连接超时设置。Xray 处理的每一个连接都对应一个用户，按照用户的等级（level）应用不同的策略。\nPolicyObject  PolicyObject 对应配置文件的 policy 项。\n{ \u0026#34;policy\u0026#34;: { \u0026#34;levels\u0026#34;: { \u0026#34;0\u0026#34;: { \u0026#34;handshake\u0026#34;: 4, \u0026#34;connIdle\u0026#34;: 300, \u0026#34;uplinkOnly\u0026#34;: 2, \u0026#34;downlinkOnly\u0026#34;: 5, \u0026#34;statsUserUplink\u0026#34;: false, \u0026#34;statsUserDownlink\u0026#34;: false, \u0026#34;bufferSize\u0026#34;: 4 } }, \u0026#34;system\u0026#34;: { \u0026#34;statsInboundUplink\u0026#34;: false, \u0026#34;statsInboundDownlink\u0026#34;: false, \u0026#34;statsOutboundUplink\u0026#34;: false, \u0026#34;statsOutboundDownlink\u0026#34;: false } } }  level: map{string: LevelPolicyObject}\n 一组键值对，每个键是一个字符串形式的数字（JSON 的要求），比如 \u0026quot;0\u0026quot;、\u0026quot;1\u0026quot; 等，双引号不能省略，此数字对应用户等级。每一个值是一个 LevelPolicyObject.\nTIP\n每个入站出站代理现在都可以设置用户等级，Xray 会根据实际的用户等级应用不同的本地策略。\n system: SystemPolicyObject\n Xray系统级别的策略\n\nLevelPolicyObject  { \u0026#34;handshake\u0026#34;: 4, \u0026#34;connIdle\u0026#34;: 300, \u0026#34;uplinkOnly\u0026#34;: 2, \u0026#34;downlinkOnly\u0026#34;: 5, \u0026#34;statsUserUplink\u0026#34;: false, \u0026#34;statsUserDownlink\u0026#34;: false, \u0026#34;bufferSize\u0026#34;: 10240 }  handshake: number\n 连接建立时的握手时间限制。单位为秒。默认值为 4。在入站代理处理一个新连接时，在握手阶段如果使用的时间超过这个时间，则中断该连接。\nconnIdle: number\n 连接空闲的时间限制。单位为秒。默认值为 300。inbound/outbound处理一个连接时，如果在 connIdle 时间内，没有任何数据被传输（包括上行和下行数据），则中断该连接。\nuplinkOnly: number\n 当连接下行线路关闭后的时间限制。单位为秒。默认值为 2。当服务器（如远端网站）关闭下行连接时，出站代理会在等待 uplinkOnly 时间后中断连接。\ndownlinkOnly: number\n 当连接上行线路关闭后的时间限制。单位为秒。默认值为 5。当客户端（如浏览器）关闭上行连接时，入站代理会在等待 downlinkOnly 时间后中断连接。\nTIP\n在 HTTP 浏览的场景中，可以将 uplinkOnly 和 downlinkOnly 设为 0，以提高连接关闭的效率。\n statsUserUplink: true | false\n 当值为 true 时，开启当前等级的所有用户的上行流量统计。\nstatsUserDownlink: true | false\n 当值为 true 时，开启当前等级的所有用户的下行流量统计。\nbufferSize: number\n 每个连接的内部缓存大小。单位为 kB。当值为 0 时，内部缓存被禁用。\n默认值:\n 在 ARM、MIPS、MIPSLE 平台上，默认值为 0。 在 ARM64、MIPS64、MIPS64LE 平台上，默认值为 4。 在其它平台上，默认值为 512。  TIP\nbufferSize 选项会覆盖 环境变量中 Xray.ray.buffer.size 的设定。\n -- \nSystemPolicyObject  { \u0026#34;statsInboundUplink\u0026#34;: false, \u0026#34;statsInboundDownlink\u0026#34;: false, \u0026#34;statsOutboundUplink\u0026#34;: false, \u0026#34;statsOutboundDownlink\u0026#34;: false }  statsInboundUplink: true | false\n 当值为 true 时，开启所有入站代理的上行流量统计。 statsInboundDownlink: true | false\n 当值为 true 时，开启所有入站代理的下行流量统计。 statsOutboundUplink: true | false\n 当值为 true 时，开启所有出站代理的上行流量统计。 statsOutboundDownlink: true | false\n 当值为 true 时，开启所有出站代理的下行流量统计。\n"},{"uri":"https://xtls.github.io/config/inbounds/","title":"Inbounds","tags":[],"description":"Project X 的文档.","content":"入站连接用于接收发来的数据，可用的协议请见inbound 可用协议列表。\nInboundObject  InboundObject 对应配置文件中 inbounds 项的一个子元素。\n{ \u0026#34;inbounds\u0026#34;: [ { \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1080, \u0026#34;protocol\u0026#34;: \u0026#34;协议名称\u0026#34;, \u0026#34;settings\u0026#34;: {}, \u0026#34;streamSettings\u0026#34;: {}, \u0026#34;tag\u0026#34;: \u0026#34;标识\u0026#34;, \u0026#34;sniffing\u0026#34;: { \u0026#34;enabled\u0026#34;: true, \u0026#34;destOverride\u0026#34;: [\u0026#34;http\u0026#34;, \u0026#34;tls\u0026#34;] }, \u0026#34;allocate\u0026#34;: { \u0026#34;strategy\u0026#34;: \u0026#34;always\u0026#34;, \u0026#34;refresh\u0026#34;: 5, \u0026#34;concurrency\u0026#34;: 3 } } ] }  listen: address\n 监听地址，IP 地址或 Unix domain socket，默认值为 \u0026quot;0.0.0.0\u0026quot;，表示接收所有网卡上的连接.\n可以指定一个系统可用的 IP 地址。\n支持填写 Unix domain socket，格式为绝对路径，形如 \u0026quot;/dev/shm/domain.socket\u0026quot;，可在开头加 \u0026quot;@\u0026quot; 代表 abstract，\u0026quot;@@\u0026quot; 则代表带 padding 的 abstract。\n填写 Unix domain socket 时，port 和 allocate 将被忽略，协议目前可选 VLESS、VMess、Trojan，传输方式可选 TCP、WebSocket、HTTP/2。\nport: number | \u0026ldquo;env:variable\u0026rdquo; | string\n 端口。接受的格式如下:\n 整型数值：实际的端口号。 环境变量：以 \u0026quot;env:\u0026quot; 开头，后面是一个环境变量的名称，如 \u0026quot;env:PORT\u0026quot;。Xray 会以字符串形式解析这个环境变量。 字符串：可以是一个数值类型的字符串，如 \u0026quot;1234\u0026quot;；或者一个数值范围，如 \u0026quot;5-10\u0026quot; 表示端口 5 到端口 10，这 6 个端口。  当只有一个端口时，Xray 会在此端口监听入站连接。当指定了一个端口范围时，取决于 allocate 设置。\nprotocol: string\n 连接协议名称，可选的协议类型见inbound 可用协议列表。\nsettings: InboundConfigurationObject\n 具体的配置内容，视协议不同而不同。详见每个协议中的 InboundConfigurationObject。\nstreamSettings: StreamSettingsObject\n 底层传输方式（transport）是当前 Xray 节点和其它节点对接的方式\n tag: string\n 此入站连接的标识，用于在其它的配置中定位此连接。\nimportant当其不为空时，其值必须在所有 tag 中 唯一。\n sniffing: SniffingObject\n 流量探测主要作用于在透明代理等用途. 比如一个典型流程如下:\n 如有一个设备上网,去访问abc.com,首先设备通过DNS查询得到abc.com的IP是1.2.3.4,然后设备会向1.2.3.4去发起连接. 如果不设置嗅探,Xray收到的连接请求是1.2.3.4,并不能用于域名规则的路由分流. 当设置了sniffing中的enable为true,Xray处理此连接的流量时,会从流量的数据中,嗅探出域名,即abc.com Xray会把1.2.3.4重置为abc.com.路由就可以根据域名去进行路由的域名规则的分流  因为变成了一个向abc.com请求的连接, 就可以做更多的事情, 除了路由域名规则分流, 还能重新做DNS解析等其他工作.\n当设置了sniffing中的enable为true, 还能嗅探出bittorrent类型的流量, 然后可以在路由中配置\u0026quot;protocol\u0026quot;项来设置规则处理BT流量, 比如服务端用来拦截BT流量, 或客户端固定转发BT流量到某个VPS去等.\nallocate: AllocateObject\n 当设置了多个port时, 端口分配的具体设置\n\nSniffingObject  { \u0026#34;enabled\u0026#34;: true, \u0026#34;destOverride\u0026#34;: [\u0026#34;http\u0026#34;, \u0026#34;tls\u0026#34;] }  enabled: true | false\n 是否开启流量探测。 destOverride: [\u0026ldquo;http\u0026rdquo; | \u0026ldquo;tls\u0026rdquo;]\n 当流量为指定类型时，按其中包括的目标地址重置当前连接的目标。\n\nAllocateObject  { \u0026#34;strategy\u0026#34;: \u0026#34;always\u0026#34;, \u0026#34;refresh\u0026#34;: 5, \u0026#34;concurrency\u0026#34;: 3 }  strategy: \u0026ldquo;always\u0026rdquo; | \u0026ldquo;random\u0026rdquo;\n 端口分配策略。\n \u0026quot;always\u0026quot; 表示总是分配所有已指定的端口，port 中指定了多少个端口，Xray 就会监听这些端口。 \u0026quot;random\u0026quot; 表示随机开放端口，每隔 refresh 分钟在 port 范围中随机选取 concurrency 个端口来监听。  refresh: number\n 随机端口刷新间隔，单位为分钟。最小值为 2，建议值为 5。这个属性仅当 strategy 设置为 \u0026quot;random\u0026quot; 时有效。 concurrency: number\n 随机端口数量。最小值为 1，最大值为 port 范围的三分之一。建议值为 3。\n"},{"uri":"https://xtls.github.io/config/outbound-protocols/","title":"outbound可用协议列表","tags":[],"description":"Project X 的文档.","content":" 这个章节包含了目前所有可用于outbound的协议及具体配置细节. 协议列表   blackhole\n Blackhole（黑洞）是一个出站数据协议，它会阻碍所有数据的出站，配合 路由（Routing） 一起使用，可以达到禁止访问某些网站的效果。 dns\n DNS 是一个出站协议，主要用于拦截和转发 DNS 查询。此出站协议只能接收 DNS 流量（包含基于 UDP 和 TCP 协议的查询），其它类型的流量会导致错误。 freedom\n Freedom 是一个出站协议，可以用来向任意网络发送（正常的） TCP 或 UDP 数据。 http\n HTTP 协议 socks\n 标准 Socks 协议实现，兼容 Socks 4、Socks 4a 和 Socks 5。 vless\n VLESS 是一个无状态的轻量传输协议，可以作为 Xray 客户端和服务器之间的桥梁。 VMess\n VMess 是一个加密传输协议，可以作为 Xray 客户端和服务器之间的桥梁。 trojan\n Trojan协议 shadowsocks\n Shadowsocks 协议。\n"},{"uri":"https://xtls.github.io/config/transports/quic/","title":"QUIC","tags":[],"description":"Project X 的文档.","content":"QUIC 全称 Quick UDP Internet Connection，是由 Google 提出的使用 UDP 进行多路并发传输的协议。其主要优势是:\n 减少了握手的延迟（1-RTT 或 0-RTT） 多路复用，并且没有 TCP 的阻塞问题 连接迁移，（主要是在客户端）当由 Wifi 转移到 4G 时，连接不会被断开。  QUIC 目前处于实验期，使用了正在标准化过程中的 IETF 实现，不能保证与最终版本的兼容性。\n 默认设定:  12 字节的 Connection ID 30 秒没有数据通过时自动断开连接 (可能会影响一些长连接的使用)    QuicObject  QuicObject 对应传输配置的 quicSettings 项。\nimportant对接的两端的配置必须完全一致，否则连接失败。 QUIC 强制要求开启 TLS，在传输配置中没有开启 TLS 时，Xray 会自行签发一个证书进行 TLS 通讯。\n { \u0026#34;security\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;header\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; } }  security: \u0026ldquo;none\u0026rdquo; | \u0026ldquo;aes-128-gcm\u0026rdquo; | \u0026ldquo;chacha20-poly1305\u0026rdquo;\n 加密方式。\n此加密是对 QUIC 数据包的加密，加密后数据包无法被探测。\n默认值为不加密。\nkey: string\n 加密时所用的密钥。\n可以是任意字符串。当 security 不为 \u0026quot;none\u0026quot; 时有效。\nheader: HeaderObject\n 数据包头部伪装设置\n\nHeaderObject  { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }  type: string\n 伪装类型，可选的值有：\n \u0026quot;none\u0026quot;：默认值，不进行伪装，发送的数据是没有特征的数据包。 \u0026quot;srtp\u0026quot;：伪装成 SRTP 数据包，会被识别为视频通话数据（如 FaceTime）。 \u0026quot;utp\u0026quot;：伪装成 uTP 数据包，会被识别为 BT 下载数据。 \u0026quot;wechat-video\u0026quot;：伪装成微信视频通话的数据包。 \u0026quot;dtls\u0026quot;：伪装成 DTLS 1.2 数据包。 \u0026quot;wireguard\u0026quot;：伪装成 WireGuard 数据包。（并不是真正的 WireGuard 协议）  TIP\n当加密和伪装都不启用时，数据包即为原始的 QUIC 数据包，可以与其它的 QUIC 工具对接。\n为了避免被探测，建议加密或伪装至少开启一项。\n "},{"uri":"https://xtls.github.io/config/outbound-protocols/vless/","title":"VLESS","tags":[],"description":"Project X 的文档.","content":" important目前 VLESS 没有自带加密，请用于可靠信道，如 TLS。 目前 VLESS 不支持分享。\n VLESS 是一个无状态的轻量传输协议，它分为入站和出站两部分，可以作为 Xray 客户端和服务器之间的桥梁。\n与 VMess 不同，VLESS 不依赖于系统时间，认证方式同样为 UUID，但不需要 alterId。\nOutboundConfigurationObject  { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;example.com\u0026#34;, \u0026#34;port\u0026#34;: 443, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34;, \u0026#34;encryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }  vnext: [ ServerObject ]\n 一个数组, 表示 VLESS 服务器列表，包含一组指向服务端的配置, 其中每一项是一个服务器配置。\n\nServerObject  { \u0026#34;address\u0026#34;: \u0026#34;example.com\u0026#34;, \u0026#34;port\u0026#34;: 443, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34;, \u0026#34;encryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] }  address: address\n 服务端地址，指向服务端，支持域名、IPv4、IPv6。\nport: number\n 服务端端口，通常与服务端监听的端口相同。\nusers: [ UserObject ]\n 数组, 一组服务端认可的用户列表, 其中每一项是一个用户配置\n\nUserObject  { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34;, \u0026#34;encryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0 }  id: string\n VLESS 的用户 ID，必须是一个合法的 UUID，你可以用 在线工具 生成它。\nencryption: \u0026ldquo;none\u0026rdquo;\n 需要填 \u0026quot;none\u0026quot;，不能留空。\n该要求是为了提醒使用者没有加密，也为了以后出加密方式时，防止使用者填错属性名或填错位置导致裸奔。 若未正确设置 encryption 的值，使用 Xray 或 -test 时会收到错误信息。\nflow: string\n VLESS 的流控模式.\n目前 VLESS 有以下流控模式可选:\n \u0026ldquo;xtls-rprx-origin\u0026rdquo; : 最初的流控方式 \u0026ldquo;xtls-rprx-origin-udp443\u0026rdquo; : 同xtls-rprx-origin, 但是放行了目标为443端口的UDP流量. \u0026ldquo;xtls-rprx-direct\u0026rdquo; : 所有平台皆可使用的典型流控方式 \u0026ldquo;xtls-rprx-direct-udp443\u0026rdquo; : 同xtls-rprx-direct, 但是放行了目标为443端口的UDP流量. \u0026ldquo;xtls-rprx-splice\u0026rdquo; : Linux 平台下最建议使用的流控方式 \u0026ldquo;xtls-rprx-splice-udp443\u0026rdquo; : 同xtls-rprx-splice, 但是放行了目标为443端口的UDP流量.  如果填写了流控模式, 还需将 outbound 的 security 设置成 \u0026ldquo;xtls\u0026rdquo;, 将 \u0026ldquo;tlsSettings\u0026rdquo; 改成 \u0026ldquo;xtlsSettings\u0026rdquo;. 可参考streamSettings设置\nimportantSplice 是 Linux Kernel 提供的函数，系统内核直接转发 TCP，不再经过 Xray 的内存，大大减少了数据拷贝、CPU 上下文切换的次数。\nsplice 模式的的使用限制:\n Linux 环境 inbound为 任意门、Socks、HTTP 等纯净的 TCP 连接, 或 XTLS 模式的inbound outbound 为 VLESS XTLS 或 Trojan XTLS   level: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n\n配置模板  Xray-examples 有完整的 VLESS 配置示例供参考。（但目前不能保证其它协议的配置示例质量）\n 客户端开发指引   VLESS 协议本身还会有不兼容升级，但客户端配置文件参数基本上是只增不减的。所以如果你开发了用 core 的客户端，现在就可以适配。 iOS 客户端的协议实现则需紧跟升级。 视觉标准：UI 标识请统一用 VLESS，而不是 VLess / Vless / vless，配置文件不受影响，代码内则顺其自然。 encryption 应做成输入框而不是选择框，新配置的默认值应为 none，若用户置空则应代填 none。  以下为已支持图形化配置 VLESS 的部分客户端列表，推荐使用：（按实现时间先后顺序排列）\n 新型协议回落模式解析  In progress\n VLESS 分享链接标准  In progress\n"},{"uri":"https://xtls.github.io/config/inbound-protocols/vmess/","title":"VMess","tags":[],"description":"Project X 的文档.","content":"VMess 是一个加密传输协议，通常作为 Xray 客户端和服务器之间的桥梁。\nimportantVMess 依赖于系统时间，请确保使用 Xray 的系统 UTC 时间误差在 90 秒之内，时区无关。在 Linux 系统中可以安装ntp服务来自动同步系统时间。\n InboundConfigurationObject  { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;alterId\u0026#34;: 0, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34; } ], \u0026#34;default\u0026#34;: { \u0026#34;level\u0026#34;: 0, \u0026#34;alterId\u0026#34;: 0 }, \u0026#34;detour\u0026#34;: { \u0026#34;to\u0026#34;: \u0026#34;tag_to_detour\u0026#34; }, \u0026#34;disableInsecureEncryption\u0026#34;: false }  clients: [ ClientObject ]\n 一个数组，代表一组服务端认可的用户.\n其中每一项是一个用户ClientObject。\n当此配置用作动态端口时，Xray 会自动创建用户。\ndetour: DetourObject\n 指示对应的出站协议使用另一个服务器。\ndefault: DefaultObject\n 可选，clients 的默认配置。仅在配合detour时有效。\ndisableInsecureEncryption: true | false\n 是否禁止客户端使用不安全的加密方式，如果设置为 true 当客户端指定下列加密方式时，服务器会主动断开连接。\n \u0026quot;none\u0026quot; \u0026quot;aes-128-cfb\u0026quot;  默认值为false。\n\nClientObject  { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;alterId\u0026#34;: 4, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34; }  id: string\n VMess 的用户 ID。必须是一个合法的 UUID。\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nalterId: number\n 为了进一步防止被探测，一个用户可以在主 ID 的基础上，再额外生成多个 ID。这里只需要指定额外的 ID 的数量，推荐值为 0 代表启用 VMessAEAD。\n最大值 65535。这个值不能超过服务器端所指定的值。\n不指定的话，默认值是 0。\nTIP\n客户端 AlterID 设置为 0 代表启用 VMessAEAD ；服务端为自动适配，可同时兼容启用和未开启 VMessAEAD 的客户端。\n客户端可通过设置环境变量 Xray_VMESS_AEAD_DISABLED=true 强行禁用 VMessAEAD\n email: string\n 用户邮箱地址，用于区分不同用户的流量。\n\nDetourObject  { \u0026#34;to\u0026#34;: \u0026#34;tag_to_detour\u0026#34; }  to: string\n 一个 inbound 的tag, 指定的 inbound 的必须是使用 VMess 协议的 inbound.\n\nDefaultObject  { \u0026#34;level\u0026#34;: 0, \u0026#34;alterId\u0026#34;: 0 }  level: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nalterId: number\n 动态端口的默认alterId，默认值为0。\n\nVMess MD5 认证信息 玷污机制  为了进一步对抗可能的探测和封锁，每个 VMess 认证数据的服务端结构都会包含一个一次写入的玷污状态标记，初始状态为无瑕状态，当服务器检测到重放探测时或者因为其他原因入站连接出错以致校验数据不正确时，该连接所对应的请求认证数据会被玷污。\n被玷污的认证数据无法被用于建立连接，当攻击者或客户端使用被玷污的认证数据建立连接时，服务器会输出包含 \u0026ldquo;invalid user\u0026rdquo; \u0026ldquo;ErrTainted\u0026rdquo; 的错误信息，并阻止该连接。\n当服务器没有受到重放攻击时，该机制对正常连接的客户端没有影响。\n如果服务器正在被重放攻击，可能会出现连接不稳定的情况。\nTIP\n拥有服务器 UUID 以及其他连接数据的恶意程序可能根据此机制对服务器发起拒绝服务攻击，受到此类攻击的服务可以通过修改 proxy/vmess/validator.go 文件中 func (v *TimedUserValidator) BurnTaintFuse(userHash []byte) error 函数的 atomic.CompareAndSwapUint32(pair.taintedFuse, 0, 1) 语句为 atomic.CompareAndSwapUint32(pair.taintedFuse, 0, 0) 来解除服务器对此类攻击的安全保护机制。使用 VMessAEAD 认证机制的客户端不受到 VMess MD5 认证信息 玷污机制 的影响。\n "},{"uri":"https://xtls.github.io/qa/xtls/","title":"XTLS相关问题","tags":[],"description":"Project X 的文档.","content":" Q: XTLS是个啥?好吃吗?XTLS 是 Xray 的原创黑科技, 也是使 Xray 性能一骑绝尘的核心动力\n点此查看详情 XTLS\n Q: TLS和XTLS有啥区别?XTLS会不安全吗?安全性没有区别. 传输的数据都是完全加密的\nTLS / XTLS 是目前最安全的传输加密方案, 且外部看来流量类型和正常上网具有一致性.\n性能有区别. XTLS比TLS快的多的多的多.\n启用 XTLS 并且配置合适的XTLS流控模式, 可以在保持和 TLS 相同的安全性的前提下, 性能达到数倍甚至十几倍的提升.\n Q: 听说XTLS的数据是不完全加密的，是这样的吗?此说法错误，XTLS传输的数据是完全加密的，和TLS没有区别。\nXTLS去掉了旧时代翻墙模式中不必要的对加密数据的重复加密。即:\n 如果原始数据是已经经过TLS加密的数据（通常上网，绝大部分数据都是已经TLS加密过的数据了），此时XTLS不再和旧时代工具一样进行无用的重复加密，从而获得卓越性能。 如果原始数据不是经过TLS加密的，而是明文数据，XTLS会进行TLS加密。   因此XTLS数据仍然是完全TLS加密的，并且去掉了毫无意义的不必要的重复加密，而不是所谓的不完全加密。\n同时外部看来流量类型和正常上网具有一致性，更具隐蔽性，是最安全的模式。\n "},{"uri":"https://xtls.github.io/qa/","title":"常见问答","tags":[],"description":"Project X 的文档.","content":" 如果您有任何疑问, 不妨先到这里看看是不是有人遇到了同样的问题, 并且已经解决了. 下载和安装中的问题 首先您可以点击查看下载和安装Xray\n如果碰到问题, 可以点击这里下载和安装中的问题\n 配置和运行时的问题 首先您可以点击查看配置和运行Xray\n如果碰到问题, 可以点击这里配置和运行时的问题\n 性能相关的问题 速率, 延迟, CPU占用, 内存占用\u0026hellip;\n这些相关的问题请点击这里性能相关的问题\n 透明代理的问题 如果您使用了透明代理\n遇到问题不妨点击这里透明代理的问题\n  \n回落相关的问题 回落是Xray最强大功能之一, 灵活且强大, 可以玩很多杂技\n如有相关问题可以点击回落相关的问题\n XTLS相关的问题 XTLS 是 Xray独创的新科技, 因此 Xray 的性能一骑绝尘.\n如有相关问题可以点击XTLS相关的问题\n  关于 Xray Xray 的非技术问题\n点击查看Xray 的非技术问题\n  \n如果在这里找不到你要的答案或者觉得答案不够细致, 不妨再去翻一翻大案牍术\n "},{"uri":"https://xtls.github.io/config/outbounds/","title":"Outbounds","tags":[],"description":"Project X 的文档.","content":"出站连接用于发送数据，可用的协议请见outbound 可用协议列表。\nOutboundObject  OutboundObject 对应配置文件中 outbounds 项的一个子元素。 TIP\n列表中的第一个元素作为主outbound。当路由匹配不存在或没有匹配成功时，流量由主outbound发出。\n { \u0026#34;outbounds\u0026#34;: [ { \u0026#34;sendThrough\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;协议名称\u0026#34;, \u0026#34;settings\u0026#34;: {}, \u0026#34;tag\u0026#34;: \u0026#34;标识\u0026#34;, \u0026#34;streamSettings\u0026#34;: {}, \u0026#34;proxySettings\u0026#34;: { \u0026#34;tag\u0026#34;: \u0026#34;another-outbound-tag\u0026#34; }, \u0026#34;mux\u0026#34;: {} } ] }  sendThrough: address\n 用于发送数据的 IP 地址，当主机有多个 IP 地址时有效，默认值为 \u0026quot;0.0.0.0\u0026quot;。 protocol: string\n 连接协议名称，可选的协议类型见outbound 可用协议列表。 settings: OutboundConfigurationObject\n 具体的配置内容，视协议不同而不同。详见每个协议中的 OutboundConfigurationObject。 tag: string\n 此出站连接的标识，用于在其它的配置中定位此连接。\nimportant当其不为空时，其值必须在所有 tag 中 唯一。\n streamSettings: StreamSettingsObject\n 底层传输方式（transport）是当前 Xray 节点和其它节点对接的方式\nproxySettings: ProxySettingsObject\n 出站代理配置。当出站代理生效时，此outbound的 streamSettings 将不起作用。\nmux: MuxObject\n Mux 相关的具体配置。\n\nProxySettingsObject  { \u0026#34;tag\u0026#34;: \u0026#34;another-outbound-tag\u0026#34; }  tag: string\n 当指定另一个outbound的标识时，此outbound发出的数据，将被转发至所指定的outbound发出。\n\nMuxObject  Mux 功能是在一条 TCP 连接上分发多个 TCP 连接的数据。实现细节详见 Mux.Cool。Mux 是为了减少 TCP 的握手延迟而设计，而非提高连接的吞吐量。使用 Mux 看视频、下载或者测速通常都有反效果。Mux 只需要在客户端启用，服务器端自动适配。\nMuxObject 对应 OutboundObject 中的 mux 项。\n{ \u0026#34;enabled\u0026#34;: false, \u0026#34;concurrency\u0026#34;: 8 }  enabled: true | false\n 是否启用 Mux 转发请求，默认值 false。 concurrency: number\n 最大并发连接数。最小值 1，最大值 1024，默认值 8。\n这个数值表示了一个 TCP 连接上最多承载的 Mux 连接数量。比如设置 concurrency=8 时，当客户端发出了 8 个 TCP 请求，Xray 只会发出一条实际的 TCP 连接，客户端的 8 个请求全部由这个 TCP 连接传输。\nTIP\n填负数时，如 -1，不加载 mux 模块。\n "},{"uri":"https://xtls.github.io/config/inbound-protocols/trojan/","title":"Trojan","tags":[],"description":"Project X 的文档.","content":"Trojan 协议\nimportantTrojan 被设计工作在正确配置的加密 TLS 隧道\n InboundConfigurationObject  { \u0026#34;clients\u0026#34;: [ { \u0026#34;password\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;level\u0026#34;: 0 } ], \u0026#34;fallbacks\u0026#34;: [ { \u0026#34;dest\u0026#34;: 80 } ] }  clients: [ ClientObject ]\n 一个数组，代表一组服务端认可的用户.\n其中每一项是一个用户ClientObject。\nfallbacks: [ FallbackObject ]\n 一个数组，包含一系列强大的回落分流配置（可选）。\nTIP\nXray 的 Trojan 有完整的 fallbacks 支持，配置方式完全一致。 触发回落的条件也与VLESS类似：首包长度 \u0026lt; 58 或第 57 个字节不为 \u0026lsquo;\\r\u0026rsquo;（因为 Trojan 没有协议版本）或身份认证失败。\n \nClientObject  { \u0026#34;password\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;level\u0026#34;: 0 }  password: string\n 必填，任意字符串。\nemail: string\n 邮件地址，可选，用于标识用户\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n\n"},{"uri":"https://xtls.github.io/config/outbound-protocols/vmess/","title":"VMess","tags":[],"description":"Project X 的文档.","content":"VMess VMess 是一个加密传输协议，通常作为 Xray 客户端和服务器之间的桥梁。\nimportantVMess 依赖于系统时间，请确保使用 Xray 的系统 UTC 时间误差在 90 秒之内，时区无关。在 Linux 系统中可以安装ntp服务来自动同步系统时间。\n OutboundConfigurationObject  { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 37192, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34;, \u0026#34;alterId\u0026#34;: 0, \u0026#34;security\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }  vnext：[ ServerObject ]\n 一个数组，包含一组的服务端配置.\n其中每一项是一个服务端配置ServerObject。\n\nServerObject  { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 37192, \u0026#34;users\u0026#34;: [] }  address: address\n 服务端地址，支持 IP 地址或者域名。\nport: number\n 服务端监听的端口号, 必填。\nusers: [ UserObject ]\n 一个数组，代表一组服务端认可的用户.\n其中每一项是一个用户UserObject。\n\nUserObject  { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34;, \u0026#34;alterId\u0026#34;: 0, \u0026#34;security\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;level\u0026#34;: 0 }  id：string\n VMess 用户的主 ID。必须是一个合法的 UUID。\nalterId：number\n 为了进一步防止被探测，一个用户可以在主 ID 的基础上，再额外生成多个 ID。这里只需要指定额外的 ID 的数量，推荐值为 0 代表启用 VMessAEAD。\n最大值 65535。这个值不能超过服务器端所指定的值。\n不指定的话，默认值是 0。\nTIP\n客户端 AlterID 设置为 0 代表启用 VMessAEAD ；服务端为自动适配，可同时兼容启用和未开启 VMessAEAD 的客户端。\n客户端可通过设置环境变量 Xray_VMESS_AEAD_DISABLED=true 强行禁用 VMessAEAD\n level: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nsecurity: \u0026ldquo;aes-128-gcm\u0026rdquo; | \u0026ldquo;chacha20-poly1305\u0026rdquo; | \u0026ldquo;auto\u0026rdquo; | \u0026ldquo;none\u0026rdquo;\n 加密方式，客户端将使用配置的加密方式发送数据，服务器端自动识别，无需配置。\n \u0026quot;aes-128-gcm\u0026quot;：推荐在 PC 上使用 \u0026quot;chacha20-poly1305\u0026quot;：推荐在手机端使用 \u0026quot;auto\u0026quot;：默认值，自动选择（运行框架为 AMD64、ARM64 或 s390x 时为 aes-128-gcm 加密方式，其他情况则为 Chacha20-Poly1305 加密方式） \u0026quot;none\u0026quot;：不加密  TIP\n推荐使用\u0026quot;auto\u0026quot;加密方式，这样可以永久保证安全性和兼容性。\n "},{"uri":"https://xtls.github.io/config/transports/","title":"传输方式列表","tags":[],"description":"Project X 的文档.","content":" 这个章节包含了目前所有的传输方式及相关的具体配置. 传输方式列表 tcpSettings: TcpObject\n 针对 TCP 连接的配置。\nwsSettings: WebSocketObject\n 针对 WebSocket 连接的配置。\ndsSettings: DomainSocketObject\n 针对 Domain Socket 连接的配置。\nkcpSettings: KcpObject\n 针对 mKCP 连接的配置。\nhttpSettings: HttpObject\n 针对 HTTP/2 连接的配置。\nquicSettings: QuicObject\n 针对 QUIC 连接的配置。\n"},{"uri":"https://xtls.github.io/caseslip/","title":"大案牍术","tags":[],"description":"Project X 的文档.","content":" 大案牍术记载了 Xray 历史上经过大量研究而破解的迷案, 虽然有些卷宗也许已经迷失在时空里… \n卷宗一览  结案 《大案牍术 卷宗一》\u0026ndash; \u0026ndash; 流量统计功能会使裸协议的 ReadV 和 WriteV 同时失效\n相关卷宗开启各种姿势的统计对各种协议组合性能影响的测试\n  经办@rprx @Arthur Morgan\n 结案 《大案牍术 卷宗三》 \u0026ndash; \u0026ndash; 我们是如何破解Splice性能下降甚至低于Direct之谜的\n相关卷宗HARDWARE NAT\n 经办@rprx @Arthur Morgan\n \n未结案 《大案牍术 卷宗五》 \u0026ndash; \u0026ndash; DS性能之谜?\n相关卷宗DS性能测试\n 经办@rprx @Arthur Morgan\n \n结案 《大案牍术 卷宗六》 \u0026ndash; \u0026ndash; 启动内存之优化优化再优化\n相关卷宗多核服务端单核心负载问题 CPUNum测试\n -- 经办@rprx @AT!Mi @SekiBetu\n \n结案 《大案牍术 卷宗七》 \u0026ndash; \u0026ndash; 一核有难, 多核围观?\n相关卷宗多核服务端单核心负载问题 CPUNum测试\n 经办@rprx @Arthur Morgan @ldmlz\n \n"},{"uri":"https://xtls.github.io/config/fallback/","title":"Fallbacks","tags":[],"description":"Project X 的文档.","content":" Fallback 是 Xray 的最强大功能之一, 可有效防止主动探测, 自由配置常用端口多服务共享 \nIn progress\n\nfallback 为 Xray 提供了高强度的防主动探测性, 并且具有独创的首包回落机制.\nfallback 也可以将不同类型的流量根据 path 进行分流, 从而实现一个端口, 多种服务共享.\n目前您可以在使用 VLESS 或者 trojan 协议时, 通过配置 fallbacks 来使用回落这一特, 并且创造出非常丰富的组合玩法.\nfallbacks 配置 \u0026#34;fallbacks\u0026#34;: [ { \u0026#34;dest\u0026#34;: 80 } ]  fallbacks: [ FallbackObject ]\n 一个数组，包含一系列强大的回落分流配置。\n\nFallbackObject  { \u0026#34;alpn\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;dest\u0026#34;: 80, \u0026#34;xver\u0026#34;: 0 } fallbacks 是一个数组，这里是其中一个子元素的配置说明。\nfallbacks 项是可选的，只能用于 TCP+TLS 传输组合\n 该项有子元素时，Inbound TLS 需设置 \u0026quot;alpn\u0026quot;:[\u0026quot;http/1.1\u0026quot;]。**  通常，你需要先设置一组 alpn 和 path 均省略或为空的默认回落，然后再按需配置其它分流。\nVLESS 会把 TLS 解密后首包长度 \u0026lt; 18 或协议版本无效、身份认证失败的流量转发到 dest 指定的地址。\n其它传输组合必须删掉 fallbacks 项或所有子元素，此时也不会开启 Fallback，VLESS 会等待读够所需长度，协议版本无效或身份认证失败时，将直接断开连接。\nalpn: string\n 尝试匹配 TLS ALPN 协商结果，空为任意，默认为 \u0026quot;\u0026quot;\n有需要时，VLESS 才会尝试读取 TLS ALPN 协商结果，若成功，输出 info realAlpn = 到日志。 用途：解决了 Nginx 的 h2c 服务不能同时兼容 http/1.1 的问题，Nginx 需要写两行 listen，分别用于 1.1 和 h2c。 注意：fallbacks alpn 存在 \u0026quot;h2\u0026quot; 时，Inbound TLS 需设置 \u0026quot;alpn\u0026quot;:[\u0026quot;h2\u0026quot;,\u0026quot;http/1.1\u0026quot;]，以支持 h2 访问。\nTIP\nFallback 内设置的 \u0026ldquo;alpn\u0026rdquo; 是匹配实际协商出的 ALPN，而 Inbound TLS 设置的 \u0026ldquo;alpn\u0026rdquo; 是握手时可选的 ALPN 列表，两者含义不同。\n path: string\n 尝试匹配首包 HTTP PATH，空为任意，默认为空，非空则必须以 \u0026quot;/\u0026quot; 开头，不支持 h2c。\n智能：有需要时，VLESS 才会尝试看一眼 PATH（不超过 55 个字节；最快算法，并不完整解析 HTTP），若成功，输出 info realPath = 到日志。 用途：分流其它 inbound 的 WebSocket 流量或 HTTP 伪装流量，没有多余处理、纯粹转发流量，实测比 Nginx 反代更强。\n注意：fallbacks 所在入站本身必须是 TCP+TLS，这是分流至其它 WS 入站用的，被分流的入站则无需配置 TLS。\ndest: string | number\n 决定 TLS 解密后 TCP 流量的去向，目前支持两类地址：（该项必填，否则无法启动）\n TCP，格式为 \u0026quot;addr:port\u0026quot;，其中 addr 支持 IPv4、域名、IPv6，若填写域名，也将直接发起 TCP 连接（而不走内置的 DNS）。 Unix domain socket，格式为绝对路径，形如 \u0026quot;/dev/shm/domain.socket\u0026quot;，可在开头加 \u0026quot;@\u0026quot; 代表 abstract，\u0026quot;@@\u0026quot; 则代表带 padding 的 abstract。  若只填 port，数字或字符串均可，形如 80、\u0026quot;80\u0026quot;，通常指向一个明文 http 服务（addr 会被补为 \u0026quot;127.0.0.1\u0026quot;）。\nxver: number\n 发送 PROXY protocol，专用于传递请求的真实来源 IP 和端口，填版本 1 或 2，默认为 0，即不发送。若有需要建议填 1。\n目前填 1 或 2，功能完全相同，只是结构不同，且前者可打印，后者为二进制。Xray 的 TCP 和 WS 入站均已支持接收 PROXY protocol。\nTIP\n若你正在 配置 Nginx 接收 PROXY protocol，除了设置 proxy_protocol 外，还需设置 set_real_ip_from，否则可能会出问题。\n \n补充说明   将匹配到最精确的子元素，与子元素的排列顺序无关。若配置了几个 alpn 和 path 均相同的子元素，则会以最后的为准。 回落分流均是解密后 TCP 层的转发，而不是 HTTP 层，只在必要时检查首包 PATH。 不支持按域名分流。若有此需求，建议前置 Nginx 等并配置 stream SNI 分流。  "},{"uri":"https://xtls.github.io/config/inbound-protocols/shadowsocks/","title":"Shadowsocks","tags":[],"description":"Project X 的文档.","content":"Shadowsocks 协议，兼容大部分其它版本的实现。\n目前兼容性如下：\n  支持 TCP 和 UDP 数据包转发，其中 UDP 可选择性关闭；\n  推荐的加密方式：\n AES-256-GCM AES-128-GCM ChaCha20-Poly1305 或称 ChaCha20-IETF-Poly1305 none 或 plain  不推荐的加密方式:\n AES-256-CFB AES-128-CFB ChaCha20 ChaCha20-IETF    important\u0026ldquo;none\u0026rdquo; 不加密方式下，服务器端不会验证 \u0026ldquo;password\u0026rdquo; 中的密码。为确保安全性, 一般需要加上 TLS 并在传输层使用安全配置，例如 WebSocket 配置较长的 path\n InboundConfigurationObject { \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;aes-256-gcm\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;密码\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34; }  email: string\n 邮件地址，可选，用于标识用户\nmethod: string\n 必填。\n 推荐的加密方式：  AES-256-GCM AES-128-GCM ChaCha20-Poly1305 或称 ChaCha20-IETF-Poly1305 none 或 plain    password: string\n 必填，任意字符串。\nShadowsocks 协议不限制密码长度，但短密码会更可能被破解，建议使用 16 字符或更长的密码。\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nnetwork: \u0026ldquo;tcp\u0026rdquo; | \u0026ldquo;udp\u0026rdquo; | \u0026ldquo;tcp,udp\u0026rdquo;\n 可接收的网络协议类型。比如当指定为 \u0026quot;tcp\u0026quot; 时，仅会接收 TCP 流量。默认值为 \u0026quot;tcp\u0026quot;。\n"},{"uri":"https://xtls.github.io/config/outbound-protocols/trojan/","title":"Trojan","tags":[],"description":"Project X 的文档.","content":"Trojan 协议\nimportantTrojan 被设计工作在正确配置的加密 TLS 隧道\n OutboundConfigurationObject  { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;password\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] }  servers: [ ServerObject ]\n 一个数组，其中每一项是一个 ServerObject。\n\nServerObject  { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;password\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0 }  address: address\n 服务端地址，支持 IPv4、IPv6 和域名。必填。\nport: number\n 服务端端口，通常与服务端监听的端口相同。\npassword: string\n 密码. 必填，任意字符串。\nemail: string\n 邮件地址，可选，用于标识用户\nflow: string\n trojan 的流控模式.\n目前 trojan 有以下流控模式可选:\n \u0026ldquo;xtls-rprx-origin\u0026rdquo; : 最初的流控方式 \u0026ldquo;xtls-rprx-origin-udp443\u0026rdquo; : 同xtls-rprx-origin, 但是放行了目标为443端口的UDP流量. \u0026ldquo;xtls-rprx-direct\u0026rdquo; : 所有平台皆可使用的典型流控方式 \u0026ldquo;xtls-rprx-direct-udp443\u0026rdquo; : 同xtls-rprx-direct, 但是放行了目标为443端口的UDP流量. \u0026ldquo;xtls-rprx-splice\u0026rdquo; : Linux 平台下最建议使用的流控方式 \u0026ldquo;xtls-rprx-splice-udp443\u0026rdquo; : 同xtls-rprx-splice, 但是放行了目标为443端口的UDP流量.  如果填写了流控模式, 还需将 outbound 的 security 设置成 \u0026ldquo;xtls\u0026rdquo;, 将 \u0026ldquo;tlsSettings\u0026rdquo; 改成 \u0026ldquo;xtlsSettings\u0026rdquo;. 可参考streamSettings设置\nimportantSplice 是 Linux Kernel 提供的函数，系统内核直接转发 TCP，不再经过 Xray 的内存，大大减少了数据拷贝、CPU 上下文切换的次数。\nsplice 模式的的使用限制:\n Linux 环境 inbound为 任意门、Socks、HTTP 等纯净的 TCP 连接, 或 XTLS 模式的inbound outbound 为 VLESS XTLS 或 Trojan XTLS   level: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n"},{"uri":"https://xtls.github.io/config/transport/","title":"传输方式","tags":[],"description":"Project X 的文档.","content":"传输方式（transport）是当前 Xray 节点和其它节点对接的方式。\n传输方式指定了稳定的数据传输的方式。通常来说，一个网络连接的两端需要有对称的传输方式。比如一端用了 WebSocket，那么另一个端也必须使用 WebSocket，否则无法建立连接。\n传输方式（transport）配置有两部分:\n  全局设置（TransportObject）\n  指定inbound/ounbound配置（StreamSettingsObject）。\n指定inbound/ounbound配置时,可以指定每个单独的inbound/ounbound用怎样的方式传输。\n通常来说客户端和服务器对应的inbound和ounbound需要使用同样的传输方式。当inbound/ounbound配置指定了一种传输方式，但没有填写其具体设置时，此传输方式会使用全局配置中的设置。\n  \nTransportObject  TransportObject 对应配置文件的 transport 项。\n{ \u0026#34;transport\u0026#34;: { \u0026#34;tcpSettings\u0026#34;: {}, \u0026#34;kcpSettings\u0026#34;: {}, \u0026#34;wsSettings\u0026#34;: {}, \u0026#34;httpSettings\u0026#34;: {}, \u0026#34;quicSettings\u0026#34;: {}, \u0026#34;dsSettings\u0026#34;: {} } }  tcpSettings: TcpObject\n 针对 TCP 连接的配置。\nkcpSettings: KcpObject\n 针对 mKCP 连接的配置。\nwsSettings: WebSocketObject\n 针对 WebSocket 连接的配置。\nhttpSettings: HttpObject\n 针对 HTTP/2 连接的配置。\nquicSettings: QuicObject\n 针对 QUIC 连接的配置。\ndsSettings: DomainSocketObject\n 针对 Domain Socket 连接的配置。\n\nStreamSettingsObject  StreamSettingsObject 对应inbound/outbound中的 streamSettings 项。每一个 inbound/ounbound 都可以分别配置不同的传输配置，都可以设置 streamSettings 来进行一些传输的配置。\n{ \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;tlsSettings\u0026#34;: {}, \u0026#34;xtlsSettings\u0026#34;: {}, \u0026#34;tcpSettings\u0026#34;: {}, \u0026#34;kcpSettings\u0026#34;: {}, \u0026#34;wsSettings\u0026#34;: {}, \u0026#34;httpSettings\u0026#34;: {}, \u0026#34;quicSettings\u0026#34;: {}, \u0026#34;dsSettings\u0026#34;: {}, \u0026#34;sockopt\u0026#34;: { \u0026#34;mark\u0026#34;: 0, \u0026#34;tcpFastOpen\u0026#34;: false, \u0026#34;tproxy\u0026#34;: \u0026#34;off\u0026#34; } }  network: \u0026ldquo;tcp\u0026rdquo; | \u0026ldquo;kcp\u0026rdquo; | \u0026ldquo;ws\u0026rdquo; | \u0026ldquo;http\u0026rdquo; | \u0026ldquo;domainsocket\u0026rdquo; | \u0026ldquo;quic\u0026rdquo;\n 连接的数据流所使用的传输方式类型，默认值为 \u0026quot;tcp\u0026quot;\nsecurity: \u0026ldquo;none\u0026rdquo; | \u0026ldquo;tls\u0026rdquo; | \u0026ldquo;xtls\u0026rdquo;\n 是否启用传输层加密，支持的选项有\n \u0026quot;none\u0026quot; 表示不加密（默认值） \u0026quot;tls\u0026quot; 表示使用 TLS。 \u0026quot;xtls\u0026quot; 表示使用 XTLS。  tlsSettings: TLSObject\n TLS 配置。TLS 由 Golang 提供，通常情况下TLS协商的结果为使用 TLS 1.3，不支持 DTLS。\nxtlsSettings: XTLSObject\n XTLS 配置。XTLS 是 Xray 的原创黑科技, 也是使 Xray 性能一骑绝尘的核心动力.\nXTLS 与 TLS 有相同的安全性, 配置方式也和TLS一致. 点击此处查看XTLS的技术细节剖析 importantTLS / XTLS 是目前最安全的传输加密方案, 且外部看来流量类型和正常上网具有一致性.\n启用 XTLS 并且配置合适的XTLS流控模式, 可以在保持和 TLS 相同的安全性的前提下, 性能达到数倍甚至十几倍的提升.\n当 security 的值从\u0026rsquo;tls\u0026rsquo;改为\u0026rsquo;xtls\u0026rsquo;时, 只需将tlsSettings 修改成为 xtlsSettings\n tcpSettings: TcpObject\n 当前连接的 TCP 配置，仅当此连接使用 TCP 时有效。配置内容与上面的全局配置相同。\nkcpSettings: KcpObject\n 当前连接的 mKCP 配置，仅当此连接使用 mKCP 时有效。配置内容与上面的全局配置相同。\nwsSettings: WebSocketObject\n 当前连接的 WebSocket 配置，仅当此连接使用 WebSocket 时有效。配置内容与上面的全局配置相同。\nhttpSettings: HttpObject\n 当前连接的 HTTP/2 配置，仅当此连接使用 HTTP/2 时有效。配置内容与上面的全局配置相同。\nquicSettings: QUICObject\n 当前连接的 QUIC 配置，仅当此连接使用 QUIC 时有效。配置内容与上面的全局配置相同。\ndsSettings: DomainSocketObject\n 当前连接的 Domain socket 配置，仅当此连接使用 Domain socket 时有效。配置内容与上面的全局配置相同。\nsockopt: SockoptObject\n 透明代理相关的具体配置。\n\nTLSObject  { \u0026#34;serverName\u0026#34;: \u0026#34;xray.com\u0026#34;, \u0026#34;allowInsecure\u0026#34;: false, \u0026#34;alpn\u0026#34;: [ \u0026#34;h2\u0026#34;, \u0026#34;http/1.1\u0026#34; ], \u0026#34;minVersion\u0026#34;: \u0026#34;1.2\u0026#34;, \u0026#34;maxVersion\u0026#34;: \u0026#34;1.3\u0026#34;, \u0026#34;preferServerCipherSuites\u0026#34;: true, \u0026#34;cipherSuites\u0026#34;: \u0026#34;此处填写你需要的加密套件名称,每个套件名称之间用:进行分隔\u0026#34;, \u0026#34;certificates\u0026#34;: [], \u0026#34;disableSystemRoot\u0026#34;: false }  serverName: string\n 指定服务器端证书的域名，在连接由 IP 建立时有用。\n当目标连接由域名指定时，比如在 Socks inbound接收到了域名，或者由 Sniffing 功能探测出了域名，这个域名会自动用于 serverName，无须手动配置。\nalpn: [ string ]\n 一个字符串数组，指定了 TLS 握手时指定的 ALPN 数值。默认值为 [\u0026quot;h2\u0026quot;, \u0026quot;http/1.1\u0026quot;]。\nminVersion: [ string ]\n minVersion为可接受的最小SSL/TLS版本。\nmaxVersion: [ string ]\n maxVersion为可接受的最大SSL/TLS版本。\npreferServerCipherSuites: true | false\n 指示服务器选择客户端最喜欢的密码套件 或 服务器最优选的密码套件。\n如果为true则为使用服务器的最优选的密码套件\ncipherSuites: [ string ]\n CipherSuites用于配置受支持的密码套件列表, 每个套件名称之间用:进行分隔.\n你可以在这里或这里找到golang加密套件的名词和说明\nimportant以上两项配置为非必要选项，正常情况下不影响安全性 在未配置的情况下golang根据设备自动选择. 若不熟悉, 请勿配置此选项, 填写不当引起的问题自行负责\n allowInsecure: true | false\n 是否允许不安全连接（仅用于客户端）。默认值为 false。\n当值为 true 时，Xray 不会检查远端主机所提供的 TLS 证书的有效性。\nimportant出于安全性考虑，这个选项不应该在实际场景中选择true，否则可能遭受中间人攻击。\n disableSystemRoot: true | false\n 是否禁用操作系统自带的 CA 证书。默认值为 false。\n当值为 true 时，Xray 只会使用 certificates 中指定的证书进行 TLS 握手。当值为 false 时，Xray 只会使用操作系统自带的 CA 证书进行 TLS 握手。\ncertificates: [ CertificateObject ]\n 证书列表，其中每一项表示一个证书（建议 fullchain）。\nTIP\n如果要在 ssllibs 或者 myssl 获得 A/A+ 等级的评价, 请参考这里.\n CertificateObject { \u0026#34;ocspStapling\u0026#34;: 3600, \u0026#34;usage\u0026#34;: \u0026#34;encipherment\u0026#34;, \u0026#34;certificateFile\u0026#34;: \u0026#34;/path/to/certificate.crt\u0026#34;, \u0026#34;keyFile\u0026#34;: \u0026#34;/path/to/key.key\u0026#34;, \u0026#34;certificate\u0026#34;: [ \u0026#34;-----BEGIN CERTIFICATE-----\u0026#34;, \u0026#34;MIICwDCCAaigAwIBAgIRAO16JMdESAuHidFYJAR/7kAwDQYJKoZIhvcNAQELBQAw\u0026#34;, \u0026#34;ADAeFw0xODA0MTAxMzU1MTdaFw0xODA0MTAxNTU1MTdaMAAwggEiMA0GCSqGSIb3\u0026#34;, \u0026#34;DQEBAQUAA4IBDwAwggEKAoIBAQCs2PX0fFSCjOemmdm9UbOvcLctF94Ox4BpSfJ+\u0026#34;, \u0026#34;3lJHwZbvnOFuo56WhQJWrclKoImp/c9veL1J4Bbtam3sW3APkZVEK9UxRQ57HQuw\u0026#34;, \u0026#34;OzhV0FD20/0YELou85TwnkTw5l9GVCXT02NG+pGlYsFrxesUHpojdl8tIcn113M5\u0026#34;, \u0026#34;pypgDPVmPeeORRf7nseMC6GhvXYM4txJPyenohwegl8DZ6OE5FkSVR5wFQtAhbON\u0026#34;, \u0026#34;OAkIVVmw002K2J6pitPuJGOka9PxcCVWhko/W+JCGapcC7O74palwBUuXE1iH+Jp\u0026#34;, \u0026#34;noPjGp4qE2ognW3WH/sgQ+rvo20eXb9Um1steaYY8xlxgBsXAgMBAAGjNTAzMA4G\u0026#34;, \u0026#34;A1UdDwEB/wQEAwIFoDATBgNVHSUEDDAKBggrBgEFBQcDATAMBgNVHRMBAf8EAjAA\u0026#34;, \u0026#34;MA0GCSqGSIb3DQEBCwUAA4IBAQBUd9sGKYemzwPnxtw/vzkV8Q32NILEMlPVqeJU\u0026#34;, \u0026#34;7UxVgIODBV6A1b3tOUoktuhmgSSaQxjhYbFAVTD+LUglMUCxNbj56luBRlLLQWo+\u0026#34;, \u0026#34;9BUhC/ow393tLmqKcB59qNcwbZER6XT5POYwcaKM75QVqhCJVHJNb1zSEE7Co7iO\u0026#34;, \u0026#34;6wIan3lFyjBfYlBEz5vyRWQNIwKfdh5cK1yAu13xGENwmtlSTHiwbjBLXfk+0A/8\u0026#34;, \u0026#34;r/2s+sCYUkGZHhj8xY7bJ1zg0FRalP5LrqY+r6BckT1QPDIQKYy615j1LpOtwZe/\u0026#34;, \u0026#34;d4q7MD/dkzRDsch7t2cIjM/PYeMuzh87admSyL6hdtK0Nm/Q\u0026#34;, \u0026#34;-----END CERTIFICATE-----\u0026#34; ], \u0026#34;key\u0026#34;: [ \u0026#34;-----BEGIN RSA PRIVATE KEY-----\u0026#34;, \u0026#34;MIIEowIBAAKCAQEArNj19HxUgoznppnZvVGzr3C3LRfeDseAaUnyft5SR8GW75zh\u0026#34;, \u0026#34;bqOeloUCVq3JSqCJqf3Pb3i9SeAW7Wpt7FtwD5GVRCvVMUUOex0LsDs4VdBQ9tP9\u0026#34;, \u0026#34;GBC6LvOU8J5E8OZfRlQl09NjRvqRpWLBa8XrFB6aI3ZfLSHJ9ddzOacqYAz1Zj3n\u0026#34;, \u0026#34;jkUX+57HjAuhob12DOLcST8np6IcHoJfA2ejhORZElUecBULQIWzjTgJCFVZsNNN\u0026#34;, \u0026#34;itieqYrT7iRjpGvT8XAlVoZKP1viQhmqXAuzu+KWpcAVLlxNYh/iaZ6D4xqeKhNq\u0026#34;, \u0026#34;IJ1t1h/7IEPq76NtHl2/VJtbLXmmGPMZcYAbFwIDAQABAoIBAFCgG4phfGIxK9Uw\u0026#34;, \u0026#34;qrp+o9xQLYGhQnmOYb27OpwnRCYojSlT+mvLcqwvevnHsr9WxyA+PkZ3AYS2PLue\u0026#34;, \u0026#34;C4xW0pzQgdn8wENtPOX8lHkuBocw1rNsCwDwvIguIuliSjI8o3CAy+xVDFgNhWap\u0026#34;, \u0026#34;/CMzfQYziB7GlnrM6hH838iiy0dlv4I/HKk+3/YlSYQEvnFokTf7HxbDDmznkJTM\u0026#34;, \u0026#34;aPKZ5qbnV+4AcQfcLYJ8QE0ViJ8dVZ7RLwIf7+SG0b0bqloti4+oQXqGtiESUwEW\u0026#34;, \u0026#34;/Wzi7oyCbFJoPsFWp1P5+wD7jAGpAd9lPIwPahdr1wl6VwIx9W0XYjoZn71AEaw4\u0026#34;, \u0026#34;bK4xUXECgYEA3g2o9WqyrhYSax3pGEdvV2qN0VQhw7Xe+jyy98CELOO2DNbB9QNJ\u0026#34;, \u0026#34;8cSSU/PjkxQlgbOJc8DEprdMldN5xI/srlsbQWCj72wXxXnVnh991bI2clwt7oYi\u0026#34;, \u0026#34;pcGZwzCrJyFL+QaZmYzLxkxYl1tCiiuqLm+EkjxCWKTX/kKEFb6rtnMCgYEAx0WR\u0026#34;, \u0026#34;L8Uue3lXxhXRdBS5QRTBNklkSxtU+2yyXRpvFa7Qam+GghJs5RKfJ9lTvjfM/PxG\u0026#34;, \u0026#34;3vhuBliWQOKQbm1ZGLbgGBM505EOP7DikUmH/kzKxIeRo4l64mioKdDwK/4CZtS7\u0026#34;, \u0026#34;az0Lq3eS6bq11qL4mEdE6Gn/Y+sqB83GHZYju80CgYABFm4KbbBcW+1RKv9WSBtK\u0026#34;, \u0026#34;gVIagV/89moWLa/uuLmtApyEqZSfn5mAHqdc0+f8c2/Pl9KHh50u99zfKv8AsHfH\u0026#34;, \u0026#34;TtjuVAvZg10GcZdTQ/I41ruficYL0gpfZ3haVWWxNl+J47di4iapXPxeGWtVA+u8\u0026#34;, \u0026#34;eH1cvgDRMFWCgE7nUFzE8wKBgGndUomfZtdgGrp4ouLZk6W4ogD2MpsYNSixkXyW\u0026#34;, \u0026#34;64cIbV7uSvZVVZbJMtaXxb6bpIKOgBQ6xTEH5SMpenPAEgJoPVts816rhHdfwK5Q\u0026#34;, \u0026#34;8zetklegckYAZtFbqmM0xjOI6bu5rqwFLWr1xo33jF0wDYPQ8RHMJkruB1FIB8V2\u0026#34;, \u0026#34;GxvNAoGBAM4g2z8NTPMqX+8IBGkGgqmcYuRQxd3cs7LOSEjF9hPy1it2ZFe/yUKq\u0026#34;, \u0026#34;ePa2E8osffK5LBkFzhyQb0WrGC9ijM9E6rv10gyuNjlwXdFJcdqVamxwPUBtxRJR\u0026#34;, \u0026#34;cYTY2HRkJXDdtT0Bkc3josE6UUDvwMpO0CfAETQPto1tjNEDhQhT\u0026#34;, \u0026#34;-----END RSA PRIVATE KEY-----\u0026#34; ] }  ocspStapling: number\n ocspStapling 检查更新时间间隔。 单位：秒\nusage: \u0026ldquo;encipherment\u0026rdquo; | \u0026ldquo;verify\u0026rdquo; | \u0026ldquo;issue\u0026rdquo;\n 证书用途，默认值为 \u0026quot;encipherment\u0026quot;。\n \u0026quot;encipherment\u0026quot;：证书用于 TLS 认证和加密。 \u0026quot;verify\u0026quot;：证书用于验证远端 TLS 的证书。当使用此项时，当前证书必须为 CA 证书。 \u0026quot;issue\u0026quot;：证书用于签发其它证书。当使用此项时，当前证书必须为 CA 证书。  TIP 1\n在 Windows 平台上可以将自签名的 CA 证书安装到系统中，即可验证远端 TLS 的证书。\n TIP 2\n当有新的客户端请求时，假设所指定的 serverName 为 \u0026quot;xray.com\u0026quot;，Xray 会先从证书列表中寻找可用于 \u0026quot;xray.com\u0026quot; 的证书，如果没有找到，则使用任一 usage 为 \u0026quot;issue\u0026quot; 的证书签发一个适用于 \u0026quot;xray.com\u0026quot; 的证书，有效期为一小时。并将新的证书加入证书列表，以供后续使用。\n TIP 3\n当 certificateFile 和 certificate 同时指定时，Xray 优先使用 certificateFile。keyFile 和 key 也一样。\n TIP 4\n当 usage 为 \u0026quot;verify\u0026quot; 时，keyFile 和 key 可均为空。\n TIP 5\n使用 xray tls cert 可以生成自签名的 CA 证书。\n TIP 6\n如已经拥有一个域名, 可以使用工具便捷的获取免费第三方证书,如acme.sh\n certificateFile: string\n 证书文件路径，如使用 OpenSSL 生成，后缀名为 .crt。\ncertificate: [ string ]\n 一个字符串数组，表示证书内容，格式如样例所示。certificate 和 certificateFile 二者选一。\nkeyFile: string\n 密钥文件路径，如使用 OpenSSL 生成，后缀名为 .key。目前暂不支持需要密码的 key 文件。\nkey: [ string ]\n 一个字符串数组，表示密钥内容，格式如样例如示。key 和 keyFile 二者选一。\n\nSockoptObject  { \u0026#34;mark\u0026#34;: 0, \u0026#34;tcpFastOpen\u0026#34;: false, \u0026#34;tproxy\u0026#34;: \u0026#34;off\u0026#34; }  mark: number\n 一个整数。当其值非零时，在ountbound连接以此数值上标记 SO_MARK。\n 仅适用于 Linux 系统。 需要 CAP_NET_ADMIN 权限。  tcpFastOpen: true | false\n 是否启用 TCP Fast Open。\n当其值为 true 时，强制开启 TFO；当其值为 false 时，强制关闭 TFO；当此项不存在时，使用系统默认设置。 可用于inbound/ountbound。\n 仅在以下版本（或更新版本）的操作系统中可用:  Windows 10 (1604) Mac OS 10.11 / iOS 9 Linux 3.16：系统已默认开启，无需配置。    tproxy: \u0026ldquo;redirect\u0026rdquo; | \u0026ldquo;tproxy\u0026rdquo; | \u0026ldquo;off\u0026rdquo;\n 是否开启透明代理（仅适用于 Linux）。\n \u0026quot;redirect\u0026quot;：使用 Redirect 模式的透明代理。支持所有基于 IPv4/6 的 TCP 和 UDP 连接。 \u0026quot;tproxy\u0026quot;：使用 TProxy 模式的透明代理。支持所有基于 IPv4/6 的 TCP 和 UDP 连接。 \u0026quot;off\u0026quot;：关闭透明代理。  透明代理需要 Root 或 CAP_NET_ADMIN 权限。\nimportant当 Dokodemo-door 中指定了 followRedirect为true，且 Sockopt设置中的tproxy 为空时，Sockopt设置中的tproxy 的值会被设为 \u0026quot;redirect\u0026quot;。\n "},{"uri":"https://xtls.github.io/qa/about/","title":"关于Xray","tags":[],"description":"Project X 的文档.","content":" Q: XXX功能什么时候出来呀!康明宋\n Q: 为什么会开发 Xray ?兴趣使然\n Q: Xray收钱吗? 可以按我的要求定制吗?Xray 不沾钱,这是个兴趣使然的项目.\nXray 不接受定制, 只根据大家的需求进行兴趣使然的开发.\n Q: XXX也是你们开发的吗?请明辨您获取资源的来源, 小心使用, 谨防蜜罐\n我们的开发均托管在 github, 不在project X 仓库的, 都不属于 project X 开发.\n当然也有很多大佬支持着 Xray 的开发和完善了生态圈, 请见这里.\n我们也欢迎所有人一起来完善 Xray.\n Q: Xray和v2ray是什么关系啊?禁忌の歷史迷局\nXray 的核心创新是\n VLESS 协议 回落分流 , 防主动探测, 强大而且灵活的分流. XTLS，旨在尽可能减少数据流转过程中多余的资源使用（表现为性能大幅提升，CPU 占用大幅降低/网速和延迟可以接近硬件的极限） Xray 保持着活跃的开发与更新, 拒绝搞技术壁垒而保持亲和力, 目标是人人会用. Xray 每周都会有新的特性加入或是历史问题的解决, 更多功能建议关注更新的 release notes.  因为各种各样的原因，xray 与 v2ray 选择了不同的发展路线，并独立分支做维护。（v2ray v4.33.0 起移除了 XTLS 的支持，但保留了 VLESS 协议支持）\n至于实际效果，每个人的软件、硬件、线路都不一样，建议自行尝试测试。\n \n"},{"uri":"https://xtls.github.io/links/","title":"常用链接","tags":[],"description":"Project X 的文档.","content":"安装脚本   Linux Script  Xray-install Xray-script 感谢@kirin   Docker  teddysun/xray 感谢@秋水逸冰 Xray-docker   One Click  ProxySU 感谢@ProxySu Xray-agent 感谢@mack-a   Magisk  Xray4Magisk 感谢@子曦曦 Xray_For_Magisk 感谢@E7KMbb    \n配置模板  所有的模板请传送至: Xray-examples\n包含了各种用法示范的终极配置: VLESS-TCP-XTLS-WHATEVER\n\n图形化客户端   OpenWrt  PassWall Hello World ShadowSocksR Plus+   Windows  v2rayN Qv2ray   Android  v2rayNG Kitsunebi   iOS / Mac  Shadowrocket    \nUUID 生成器  第三方的 UUID 生成器 uuidgenerator.net\n"},{"uri":"https://xtls.github.io/config/outbound-protocols/shadowsocks/","title":"Shadowsocks","tags":[],"description":"Project X 的文档.","content":"Shadowsocks 协议，兼容大部分其它版本的实现。\n目前兼容性如下：\n  支持 TCP 和 UDP 数据包转发，其中 UDP 可选择性关闭；\n  推荐的加密方式：\n AES-256-GCM AES-128-GCM ChaCha20-Poly1305 或称 ChaCha20-IETF-Poly1305 none 或 plain  不推荐的加密方式:\n AES-256-CFB AES-128-CFB ChaCha20 ChaCha20-IETF    important\u0026ldquo;none\u0026rdquo; 不加密方式下，服务器端不会验证 \u0026ldquo;password\u0026rdquo; 中的密码。为确保安全性, 一般需要加上 TLS 并在传输层使用安全配置，例如 WebSocket 配置较长的 path\n OutboundConfigurationObject  { \u0026#34;servers\u0026#34;: [ { \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;method\u0026#34;: \u0026#34;加密方式\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;密码\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] }  servers: [ServerObject]\n 一个数组，代表一组 Shadowsocks 服务端设置, 其中每一项是一个 ServerObject。\n\nServerObject  { \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;method\u0026#34;: \u0026#34;加密方式\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;密码\u0026#34;, \u0026#34;level\u0026#34;: 0 }  email: string\n 邮件地址，可选，用于标识用户\naddress: address\n Shadowsocks 服务端地址，支持 IPv4、IPv6 和域名。必填。\nport: number\n Shadowsocks 服务端端口。必填。\nmethod: string\n 必填。\n 推荐的加密方式：  AES-256-GCM AES-128-GCM ChaCha20-Poly1305 或称 ChaCha20-IETF-Poly1305 none 或 plain    password: string\n 必填。任意字符串。\nShadowsocks 协议不限制密码长度，但短密码会更可能被破解，建议使用 16 字符或更长的密码。\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n"},{"uri":"https://xtls.github.io/config/stats/","title":"统计信息","tags":[],"description":"Project X 的文档.","content":"用于配置 Xray 流量数据的统计。\nStatsObject StatsObject 对应配置文件的 stats 项。\n{ \u0026#34;stats\u0026#34;: {} } 目前统计信息不需要任何参数，只要 StatsObject 项存在，内部的统计即会开启。\n开启了统计以后, 只需在 Policy 中开启对应的项，就可以统计对应的数据。\n\n获取统计信息  可以用 xray api 的相关命令获取统计信息.\n目前已有的统计信息如下：\n  用户数据\n  user\u0026gt;\u0026gt;\u0026gt;[email]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;uplink\n特定用户的上行流量，单位字节。\n  user\u0026gt;\u0026gt;\u0026gt;[email]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;downlink\n特定用户的下行流量，单位字节。\n  TIP\n如果对应用户没有指定 Email，则不会开启统计。\n   全局数据\n  inbound\u0026gt;\u0026gt;\u0026gt;[tag]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;uplink\n特定inbound的上行流量，单位字节。\n  inbound\u0026gt;\u0026gt;\u0026gt;[tag]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;downlink\n特定inbound的下行流量，单位字节。\n  outbound\u0026gt;\u0026gt;\u0026gt;[tag]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;uplink\n特定outbound的上行流量，单位字节。\n  outbound\u0026gt;\u0026gt;\u0026gt;[tag]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;downlink\n特定outbound的下行流量，单位字节。\n    "},{"uri":"https://xtls.github.io/config/xtls/","title":"XTLS","tags":[],"description":"Project X 的文档.","content":" XTLS 是 Xray 的原创黑科技, 也是使 Xray 性能一骑绝尘的核心动力 \nIn progress\n"},{"uri":"https://xtls.github.io/config/reverse/","title":"反向代理","tags":[],"description":"Project X 的文档.","content":"反向代理可以把服务器端的流量向客户端转发，即逆向流量转发。\n反向代理的大致工作原理如下:\n 假设在主机 A 中有一个网页服务器，这台主机没有公网 IP，无法在公网上直接访问。另有一台主机 B，它可以由公网访问。现在我们需要把 B 作为入口，把流量从 B 转发到 A。 在主机 A 中配置 Xray，称为bridge，在 B 中也配置 Xray，称为 portal。 bridge 会向 portal 主动建立连接，此连接的目标地址可以自行设定。portal 会收到两种连接，一是由 bridge 发来的连接，二是公网用户发来的连接。portal 会自动将两类连接合并。于是 bridge 就可以收到公网流量了。 bridge 在收到公网流量之后，会将其原封不动地发给主机 A 中的网页服务器。当然，这一步需要路由的协作。 bridge 会根据流量的大小进行动态的负载均衡。  TIP\n反向代理默认已开启 Mux，请不要在其用到的outbound上再次开启 Mux。\n 反向代理功能尚处于测试阶段，可能会有一些问题。\n \nReverseObject  ReverseObject 对应配置文件的 reverse 项。\n{ \u0026#34;reverse\u0026#34;: { \u0026#34;bridges\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; } ], \u0026#34;portals\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;portal\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; } ] } }  bridges: [BridgeObject]\n 数组，每一项表示一个 bridge。每个 bridge 的配置是一个 BridgeObject。\nportals: [PortalObject]\n 数组，每一项表示一个 portal。每个 portal 的配置是一个 PortalObject。\n\nBridgeObject  { \u0026#34;tag\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; }  tag: string\n 所有由 bridge 发出的连接，都会带有这个标识。可以在 路由配置 中使用 inboundTag 进行识别。\ndomain: string\n 指定一个域名，bridge 向 portal 建立的连接，都会使用这个域名进行发送。\n这个域名只作为 bridge 和 portal 的通信用途，不必真实存在。\n\nPortalObject  { \u0026#34;tag\u0026#34;: \u0026#34;portal\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; }  tag: string\n portal 的标识。在 路由配置 中使用 outboundTag 将流量转发到这个 portal。\ndomain: string\n 一个域名。当 portal 接收到流量时，如果流量的目标域名是此域名，则 portal 认为当前连接上 bridge 发来的通信连接。而其它流量则会被当成需要转发的流量。portal 所做的工作就是把这两类连接进行识别并拼接。\nTIP\n一个 Xray 既可以作为 bridge，也可以作为 portal，也可以同时两者，以适用于不同的场景需要。\n \n完整配置样例  TIP\n在运行过程中，建议先启用 bridge，再启用 portal。\n bridge配置  bridge 通常需要两个outbound，一个用于连接 portal，另一个用于发送实际的流量。也就是说，你需要用路由区分两种流量。\n反向代理配置:\n{ \u0026#34;bridges\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; } ] } outbound:\n{ \u0026#34;tag\u0026#34;: \u0026#34;out\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;redirect\u0026#34;: \u0026#34;127.0.0.1:80\u0026#34; // 将所有流量转发到网页服务器 } }, { \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;portal 的 IP 地址\u0026#34;, \u0026#34;port\u0026#34;: 1024, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34; } ] } ] }, \u0026#34;tag\u0026#34;: \u0026#34;interconn\u0026#34; } 路由配置:\n\u0026#34;routing\u0026#34;: { \u0026#34;rules\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;inboundTag\u0026#34;: [ \u0026#34;bridge\u0026#34; ], \u0026#34;domain\u0026#34;: [ \u0026#34;full:test.xray.com\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;interconn\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;inboundTag\u0026#34;: [ \u0026#34;bridge\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;out\u0026#34; } ] } \nportal配置  portal 通常需要两个inbound，一个用于接收 bridge 的连接，另一个用于接收实际的流量。同时你也需要用路由区分两种流量。\n反向代理配置:\n{ \u0026#34;portals\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;portal\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; // 必须和 bridge 的配置一样 } ] } inbound:\n{ \u0026#34;tag\u0026#34;: \u0026#34;external\u0026#34;, \u0026#34;port\u0026#34;: 80, // 开放 80 端口，用于接收外部的 HTTP 访问 \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 80, \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34; } }, { \u0026#34;port\u0026#34;: 1024, // 用于接收 bridge 的连接 \u0026#34;tag\u0026#34;: \u0026#34;interconn\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34; } ] } } 路由配置:\n\u0026#34;routing\u0026#34;: { \u0026#34;rules\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;inboundTag\u0026#34;: [ \u0026#34;external\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;portal\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;inboundTag\u0026#34;: [ \u0026#34;interconn\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;portal\u0026#34; } ] } "},{"uri":"https://xtls.github.io/config/env/","title":"环境变量","tags":[],"description":"Project X 的文档.","content":"Xray 提供以下环境变量以供修改 Xray 的一些底层配置。\n\nXTLS 信息显示  VLESS   名称：xray.vless.xtls.show 或 XRAY_VLESS_XTLS_SHOW。 默认值：\u0026quot;\u0026quot;。  使用 VLESS 协议时,设置此环境变量为 true 时, 会在终端或日志中输出 XTLS 的相关信息.\nTIP\n可打开此环境变量并根据是否有输出 XTLS 相关信息, 来确定 XTLS 是否成功被应用.\n TROJAN   名称：xray.trojan.xtls.show 或 XRAY_TROJAN_XTLS_SHOW。 默认值：\u0026quot;\u0026quot;。  使用 trojan 协议时, 设置此环境变量为 true 时, 会在终端或日志中输出 XTLS 的相关信息.\nTIP\n可打开此环境变量并根据是否有输出 XTLS 相关信息, 来确定 XTLS 是否成功被应用.\n \n资源文件路径   名称：xray.location.asset 或 XRAY_LOCATION_ASSET。 默认值：和 Xray 文件同路径。  这个环境变量指定了一个文件夹位置，这个文件夹应当包含 geoip.dat 和 geosite.dat 文件。\n\n配置文件位置   名称：xray.location.config 或 XRAY_LOCATION_CONFIG。 默认值：和 Xray 文件同路径。  这个环境变量指定了一个文件夹位置，这个文件夹应当包含 config.json 文件。\n\n多配置目录   名称：xray.location.confdir 或 XRAY_LOCATION_CONFDIR。 默认值：\u0026quot;\u0026quot;。  这个目录内的 .json 文件会按文件名顺序读取，作为多配置选项。\n\n"},{"uri":"https://xtls.github.io/config/multiple_config/","title":"多文件配置","tags":[],"description":"Project X 的文档.","content":"Xray 程序支持使用多个配置文件。\n多配置文件的主要作用在于分散不同作用模块配置，便于管理和维护。\n该功能主要考虑是为了丰富 Xray 的生态链，比如对于 GUI 的客户端，一般只实现节点选择等固定的功能，对于太复杂的配置难以图形化实现；只需留一个 confdir 的自定义配置目录供配置复杂的功能；对于服务器的部署脚本，只需往 confdir 添加文件即可实现配置多种协议。\n多文件启动  TIP\n启动信息中会提示依次读入的每个配置文件，留意启动信息是否符合你预设的顺序。\n $ xray run -confdir /etc/xray/confs 也可使用 Xray.location.confdir 或 Xray_LOCATION_CONFDIR 指定 confdir。\n参数 -confdir 的作用优先于环境变量，如果参数指定了有效的目录则不再读取环境变量中的路径。\n\n规则说明  普通对象（{}）  在 json 的顶级对象当中，后者覆盖或补充前者。\n比如：\n base.json  { \u0026#34;log\u0026#34;: {}, \u0026#34;api\u0026#34;: {}, \u0026#34;dns\u0026#34;: {}, \u0026#34;stats\u0026#34;: {}, \u0026#34;policy\u0026#34;: {}, \u0026#34;transport\u0026#34;: {}, \u0026#34;routing\u0026#34;: {}, \u0026#34;inbounds\u0026#34;: [] }  outbounds.json  { \u0026#34;outbounds\u0026#34;: [] } 以多配置启动 Xray：\n$ xray run -confdir /etc/xray/confs 这两个配置文件的就等效于合成一起的整配置。当需要修改出口节点，只需要修改 outbounds.json 内容。\n如果需要改编日志 log 的级别，也不需要改 base.json，只需后续增加一个配置：\n debuglog.json  { \u0026#34;log\u0026#34;: { \u0026#34;loglevel\u0026#34;: \u0026#34;debug\u0026#34; } } 启动顺序放置在 base 后，即可输出 debug 级别的日志\n\n数组（[]）  在 json 配置中的inbounds和outbounds是数组结构，他们有特殊的规则：\n 当配置中的数组元素有 2 或以上，覆盖前者的 inbounds/oubounds； 当配置中的数组元素只有 1 个时，查找原有tag相同的元素进行覆盖；若无法找到：  对于 inbounds，添加至最后（inbounds 内元素顺序无关） 对于 outbounds，添加至最前（outbounds 默认首选出口）；但如果文件名含有 tail（大小写均可），添加至最后。    借助多配置，可以很方便为原有的配置添加不同协议的 inbound，而不必修改原有配置。\n以下例子不是有效配置，只为展示上述规则。\n 000.json  { \u0026#34;inbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;socks\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;socks\u0026#34;, \u0026#34;port\u0026#34;: 1234 } ] }  001.json  { \u0026#34;inbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;http\u0026#34; } ] }  002.json  { \u0026#34;inbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;socks\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;socks\u0026#34;, \u0026#34;port\u0026#34;: 4321 } ] } 三个配置将会合成为：\n{ \u0026#34;inbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;socks\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;socks\u0026#34;, \u0026#34;port\u0026#34;: 4321 // \u0026lt;--- 002顺序在000后，因此覆盖tag为socks的inbound端口为4321 }, { \u0026#34;protocol\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;http\u0026#34; } ] } \n推荐的多文件列表  执行：\nfor BASE in 00_log 01_api 02_dns 03_routing 04_policy 05_inbounds 06_outbounds 07_transport 08_stats 09_reverse; do echo \u0026#39;{}\u0026#39; \u0026gt; \u0026#34;/etc/Xray/$BASE.json\u0026#34;; done 或\nfor BASE in 00_log 01_api 02_dns 03_routing 04_policy 05_inbounds 06_outbounds 07_transport 08_stats 09_reverse; do echo \u0026#39;{}\u0026#39; \u0026gt; \u0026#34;/usr/local/etc/Xray/$BASE.json\u0026#34;; done . ├── 00_log.json ├── 01_api.json ├── 02_dns.json ├── 03_routing.json ├── 04_policy.json ├── 05_inbounds.json ├── 06_outbounds.json ├── 07_transport.json ├── 08_stats.json └── 09_reverse.json 0 directories, 10 files "},{"uri":"https://xtls.github.io/","title":"","tags":[],"description":"","content":"\n\n\n不 畏 浮 云 遮 望 眼 · 金 睛 如 炬 耀 苍 穹\nK E E P R I D I N G / N E V E R L O O K B A C K\n \n由此开始    极速协议 \n原创 VLESS 轻量协议 摆脱冗余加密\n原创 XTLS 及 Direct/Splice流控 释放CPU算力\n 自由回落 \n完善的回落机制 有效防止主动探测\n自由配置常用端口 多服务共享\n 超低占用 \n适合 OpenWRT RaspberryPi 等\n各种精简设备皆可使用\n  \n跨平台 \nWindows, macOS, Linux, iOS, Android\u0026hellip; \n各种平台皆可用\n 强兼容 \n完整兼容 v2ray-core 配置文件\n完整兼容 v2ray-core API 调用\n 亲和力 \n活跃的社区讨论及贡献\nMPL 2.0 开源许可协议\n    \n\n"},{"uri":"https://xtls.github.io/404.html","title":"Whoops! Page not found","tags":[],"description":"This is a 404 page","content":"That page can\u0026rsquo;t be found.\nOur latest content is on the homepage.\nPhoto by Aron Visuals on Unsplash"}]