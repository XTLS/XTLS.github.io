[{"uri":"https://xtls.github.io/documents/level-0/ch01-preface/","title":"【第1章】前言啰嗦篇","tags":[],"description":"小小白白话文","content":"1.1 这篇文档是写给谁的？  一句话：写给 ①零基础 ②希望学习自建VPS 的新人。\n 1.2 这篇文档不是写给谁的？  包括但不限于：各路大神大能、懒得自己折腾的小白、已经会折腾的高手、确定要用机场的土豪、确定要用一键脚本的逍遥派\u0026hellip;\u0026hellip; 总之只要有技术基础、或不愿不想自建的同学，您直接关闭本文即可，因为这篇文章大概是入不了您的法眼的，更可能会让您生一肚子闲气，那多划不来。\n 1.3 郑重声明及其他声明  郑重声明：\n鄙人技术奇菜无比，故本文必然挂一漏万破绽百出。您若发现问题还请温柔提醒，莫要人参公鸡。\n 免责声明：\n本文内容请您自行判断是否可信可靠可用，若您根据本文内容建立和使用VPS服务器时出了任何问题和不良结果，鄙人概不负责。\n 啰嗦声明：\n基于本文【零基础用户】的目标受众，许多内容会尽力详尽说明，所以语言偏啰嗦，请做好心理准备。\n  1.4 为什么自建是个难题？  要回答这个问题，就需要稍微多说一点背景信息了。\n一、科学上网这件事\n科学上网这件事情，说来已经发展了近二十年（震惊!!!.jpg）。最初，自己稍微动动手即可（改改host、连一下ssh）、后来需要找一个网页代理，再后来需要写一个私有协议(比如Shadowsocks)等等。\n随着GFW技术这十几年来不断的迭代升级，若要完成【自己动手科学上网】这个目标，需要做的事情已经包括但不限于：\n1. 了解Linux系统基本命令 2. 了解网络传输协议 3. 有技术和经济能力完成VPS购买及管理 4. 有技术和经济能力完成域名购买及管理 5. 有技术能力完成TLS证书申请 等等。  这就让【自建VPS科学上网】这个曾经简单的行为逐渐变成了令新人望而生畏的挑战。\n二、零基础用户的无奈\n零基础的非技术用户，如果完成上面这一连串的操作，势必要学习大量的知识，但稍微搜索之后，新人只怕会更加迷茫：大量的信息散布在互联网的各个角落：博客、问答网站、群组、论坛、GitHub、Telegram、YouTube 等等等等）。这些信息纷乱复杂、水平良莠不齐、甚至可能互相矛盾。基本上就是不把新人彻底弄晕誓不罢休。\n面对这些杂乱无章的信息，新人突然就从【信息匮乏】变成了【信息过剩】。若是几番连蒙带猜的折腾以失败告终（大概率如此）的话，他的积极性势必大受挫折。在这个过程中，若他又恰好去了一些不太友好的地方去求助，恐怕还要雪上加霜的被嘲讽一番：“这么菜，用机场不就行了，瞎折腾什么啊！”、“先去学会Linux再回来问吧”。\n这时候，大概也只有一声“呵呵”可以表达心情了。\n 1.5 “用机场不就行了？”  首先，我想反问一下那些冷嘲热讽的人：“用机场”真的就是万灵药吗？\n其次，我认为“不懂”和“不想懂”是有本质区别的。态度恶劣的巨婴伸手党自然惹人厌烦，但真心自学却不得要领的人不该受到无端的白眼和歧视，也正是这种对新人不加区分的恶劣社区氛围促使我写下本文。那么闲话少说，我们来看看机场的优势与劣势究竟如何：\n一、“机场“的优势\n所谓“机场”，就是“线路提供商”。他负责完成1.4提到的那一串技术操作和管理，用户则付费获得使用权。所以，它的优点至少有：\n 用户操作简单：扫码操作、一键添加规则等 线路选择多：可解锁不同国家、地区的网络服务；比如iplc等专线服务、游戏加速服务等 接入节点多：所以抵抗节点封锁的能力强一些，封了一个就换下一个  二、“机场”的风险\n“方便”这枚硬币的另一面就是“风险”，基于“机场”的技术特点和市场情况，它的风险至少有：\n “机场”可完全获得用户信息：用户在网上的所有痕迹，都【必然】经过且【非常可能】长期存储在其服务器上，这些记录无法受到任何具备法律效力的用户隐私协议的约束（窥视、记录你的一举一动） “机场”缺乏市场管理：不可避免存在着以欺诈为目标的恶意商家（主动跑路） “机场”面临监管压力：大机场相对有保障的同时，也无法避免树大招风。2020年间，已经有几个大机场停运、跑路的事件发生，用户的正常使用受到严重干扰（被动跑路） “机场”技术水平难以确定：线路质量良莠不齐，挂羊头卖狗肉的现象屡见不鲜（速度慢、掉线多、连不上）   1.6 那么你到底要不要自建呢？  现在，你已经看到了机场的优势和风险，要用什么，就请各位充分思考并自行决定。毕竟，最适合你的方案才是最好的方案。\n  如果决定使用机场的话，现在，你可以关闭本文了。\n  如果你决定自建，那就请继续阅读后面的章节吧！！\n  总之，本文的目标就是成为零基础用户的知识起点，提供对每一步充分的讲解和演示，清清楚楚（甚至婆婆妈妈、絮絮叨叨、啰啰嗦嗦）的协助新人完成【从输入第一条命令开始，完成VPS服务器部署，并成功在客户端完成科学上网】的全程。并在这个过程中帮助新人逐步接触和熟悉Linux的基础操作，为之后的进一步自学打下基础。\n 1.7 题外啰嗦几句    墙外的信息泥沙俱下，请务必学会理性、独立的思辨，不要随意站队，不要轻信猎奇的信息。\n  衷心希望大家获得更顺畅的网络后，可以获取更新鲜的知识、更丰富的娱乐、接触更美好的世界、结交更多志同道合的朋友，但不要成为任何有不可告人目的之人的替罪羊。\n  你的互联网身份依然是你的身份，绝对的匿名化是极为困难的，所以请务必遵守你个人所在地区和IP所在地区的相关法律法规。无论何时，自我保护都是最基本的底线。\n   1.8 你的进度  PROGRESS⬛⬜⬜⬜⬜⬜⬜⬜ 12.5%\n "},{"uri":"https://xtls.github.io/documents/level-1/fallbacks-lv1/","title":"回落 (fallbacks) 功能简析","tags":[],"description":"入门心得","content":"在使用Xray的过程中，你一定无数次的听说了【回落】这个功能。本文就稍微说明一下这个功能的逻辑以及使用方式。\n1. 回顾《小小白白话文》中的回落 如果你用了《小小白白话文》中的Xray配置，并完成了HTTP自动跳转HTTPS优化，那么你已经有了基于 VLESS 协议的简易回落：\n\u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 443, \u0026#34;protocol\u0026#34;: \u0026#34;vless\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ ... ], \u0026#34;decryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;fallbacks\u0026#34;: [ { \u0026#34;dest\u0026#34;: 8080 // 默认回落到防探测的代理 } ] }, \u0026#34;streamSettings\u0026#34;: { ... } } ] 这一段配置用人话要怎么解释呢？\n  Xray 的入站端口 [inbound port] 是 443\n即由 Xray 负责监听 443 端口的 HTTPS 流量\n  Xray 的入站协议 [inbound protocol] 是 vless\n只有 vless 协议的流量才会流入 Xray 中做后续处理。\n注： VLESS 这个轻量协议开发的初衷就是给 xray 及 v2fly 等核心引入回落功能、并同时减少冗余校验/加密。（当然，到目前为止，xray 中的 trojan 协议也已完整支持回落功能。）\n   回落目标端口 [fallback dest] 是 8080\nXray 接受 443 端口的访问流量后，属于 vless 协议的流量、由 Xray 进行内部处理并转发至出站模块。而其他非 vless 协议的流量，则转发至 8080 端口。\n问：到底是单数还是复数？\n答：一定有聪明的同学发现，配置文件中，明明是复数 inbounds, fallbacks，为什么我解释的时候都是单数：inbound, fallback 呢？\n因为，配置文件中用复数，说明 xray 支持 N 个同等级的元素（即N个入站，M个回落等等），上面的示例解析中仅仅是其中一个，所以我用了单数。\n   回落给 8080 端口的流量，由后续程序处理\n小小白白话文中的示例，就是 8080 端口由 Nginx 处理，根据配置找到并展示小熊猫的网页。\n  总结，小小白白话文示例中的最简单回落，完整数据路线如下：\nmermaid.initialize({startOnLoad:true}); graph LR; W(外部 HTTP:80 请求) -- N80(HTTP:80) subgraph Nginx 外部监听 N80 -.- N301(301转写) -.- N443(HTTPS:443) end N443 -- X(Xray 监听 443) .- X1{入站判断} X1 -- |接收 VLESS 流量| X2(Xray内部规则) X2 -- O(Xray Outbounds 出站) X1 == |回落 非VLESS 流量| N8080(Nginx:8080) N8080:::nginxclass == H(index.html) H:::nginxclass classDef nginxclass fill:#FFFFDE     2. 重新认识回落 (WHAT, HOW v1) 基于上面的示例，你应该就可以明白什么是回落（What）和怎么回落（How）了，简单地说就是下面这几个要素：\n 回落的时间是流量进入 Xray监听端口 后 回落的依据是 协议类型 等流量特征 回落的目标是某个 端口 被回落的流量由监听 回落端口 的后续程序接手   3. 为什么要回落 (WHY v1) 最初，是为了防御 【主动探测】 (Active Probing)\n主动探测： 简单粗暴的理解，就是指外部通过发送特定的网络请求，并解读服务器的回应内容，来推测服务器端是否运行了 xray, v2fly, shadowsocks 等代理工具。一旦可以准确认定，则服务器可能受到干扰或阻断。\n之所以可以根据服务器回应内容进行解读，就是因为一次完整的数据请求，其实有很多数据交换的步骤，每一个步骤，都会产生一些软件特征。用大白话说就是：\n 正常的网站的回应，一定【会有】类似 Nginx, Apache, MySQL 的Web服务、数据库等工具的特征 正常的网站的回应，一定【不会有】类似 xray, v2fly, shadowsocks 等代理工具的特征  于是，当我们给 Xray 提供了【回落】功能后（如上例，回落给 Nginx），面对任何用来探测的请求，产生的结果是：\n 探测流量无法掌握你的 VLESS 要素，故都会被回落至 Nginx 探测流量全都回落进入 Nginx ，故VPS服务器的回应一定【会有】 Nginx 的特征 因为 Xray 本身不对探测流量做任何回应 ，所以VPS的回应一定【不会有】 Xray 的特征  至此，【回落】功能就从数据交互逻辑上解决了服务器被 【主动探测】 的安全隐患。\n 4. 重新认识【回落の完全体】 (WHAT, WHY, HOW v2) 为什么又要再次认识回落呢？ 因为，上面仅仅说清楚了基于“协议”的、抵抗【主动探测】的初版回落。\n在 rprx 不断开发迭代 VLESS 协议及 fallback 功能的过程种，逐渐发现，回落完全可以更加灵活强大，只要在保证抵抗【主动探测】的前提下，充分利用数据首包中的信息，其实可以做到多元素、多层次的回落。（如 path, alpn 等）\n基于这个开发理念，【回落】功能才逐渐成长为现在的完全体，即完成了 纯伪装 --\u0026gt; ws分流 --\u0026gt; 多协议多特征分流 的进化。最终版甚至完全替代了以前要用Web服务器、其他工具才能完成的分流的功能。且由于上述的【回落/分流】处理都在首包判断阶段以毫秒级的速度完成、不涉及任何数据操作，所以几乎没有任何过程损耗。\n因此，现在 Xray 中【完整体的回落功能】，同时具备下述属性：\n 安全： 充分抵御主动探测攻击 高效： 几乎毫无性能损失 灵活： 数据灵活分流、常用端口复用（如443）  啰嗦君： 这样多轮介绍虽然略显繁琐，但只有这样层层深入展开，才能充分的说明【回落の完全体】独有的强大！\n  5. 多层回落示例及解读 理解了【回落の完全体】是什么，那就可以动手操作配置多层回落了。其实，项目已经提供了非常完整的示例，即官方模板中的 VLESS-TCP-XTLS-WHATEVER。\n5.1 首先，我将服务器端配置的 443 监听段摘抄如下： { \u0026#34;port\u0026#34;: 443, \u0026#34;protocol\u0026#34;: \u0026#34;vless\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;\u0026#34;, // 填写你的 UUID \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;email\u0026#34;: \u0026#34;love@example.com\u0026#34; } ], \u0026#34;decryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;fallbacks\u0026#34;: [ { \u0026#34;dest\u0026#34;: 1310, // 默认回落到 Xray 的 Trojan 协议 \u0026#34;xver\u0026#34;: 1 }, { \u0026#34;path\u0026#34;: \u0026#34;/websocket\u0026#34;, // 必须换成自定义的 PATH \u0026#34;dest\u0026#34;: 1234, \u0026#34;xver\u0026#34;: 1 }, { \u0026#34;path\u0026#34;: \u0026#34;/vmesstcp\u0026#34;, // 必须换成自定义的 PATH \u0026#34;dest\u0026#34;: 2345, \u0026#34;xver\u0026#34;: 1 }, { \u0026#34;path\u0026#34;: \u0026#34;/vmessws\u0026#34;, // 必须换成自定义的 PATH \u0026#34;dest\u0026#34;: 3456, \u0026#34;xver\u0026#34;: 1 } ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;xtls\u0026#34;, \u0026#34;xtlsSettings\u0026#34;: { \u0026#34;alpn\u0026#34;: [ \u0026#34;http/1.1\u0026#34; ], \u0026#34;certificates\u0026#34;: [ { \u0026#34;certificateFile\u0026#34;: \u0026#34;/path/to/fullchain.crt\u0026#34;, // 换成你的证书，绝对路径 \u0026#34;keyFile\u0026#34;: \u0026#34;/path/to/private.key\u0026#34; // 换成你的私钥，绝对路径 } ] } } }, 这一段配置用人话要怎么解释呢？\n  Xray 的入站端口 (inbound port) 是 443\n即由 Xray 负责监听 443 端口的 HTTPS 流量，并使用 certificates 项下设定的 TLS 证书来进行验证\n  Xray 的入站协议 (inbound protocol) 是 vless\nvless 协议流量直接流入 Xray 中做后续处理\n  非 VLESS 协议流量有4个不同的回落目标：\n path 为 websocket 的流量，回落给端口 1234 后续处理  path 为 vmesstcp 的流量，回落给端口 2345 后续处理  path 为 vmessws 的流量，回落给端口 3456 后续处理  其它所有流量，回落给端口 1310 后续处理     xver 为 1 表示开启 proxy protocol 功能，向后传递来源真实IP\n  上述回落结构如下图所示：\nmermaid.initialize({startOnLoad:true}); graph LR; W443(外部 HTTP:443 请求) -- X443(Xray-inbound: 443) .- X1{入站判断} X1 -- |协议 = VLESS 的流量| X2(Xray内部规则) X2 -- O(Xray Outbounds 出站) X1 -- |path = /websocket 的流量| X1234(Xray-inbound:1234) X1 -- |path = /vmesstcp 的流量| X2345(Xray-inbound:2345) X1 -- |path = /vmessws 的流量| X3456(Xray-inbound:3456) X1 -- |其它所有流量| X1310(Xray-inbound:1310)    网页回落不见了！\n没错，聪明的同学应该发现了，防御【主动探测】的 nginx回落 不见了！！！这是为什么呢？会不会不安全？别急，我们继续分析：\n   5.2 后续监听处理的配置段摘抄如下：   后续处理回落至 1310 端口的流量，按照下面的配置验证、处理：\n{ \u0026#34;port\u0026#34;: 1310, \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;trojan\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;password\u0026#34;: \u0026#34;\u0026#34;, // 填写你的密码 \u0026#34;level\u0026#34;: 0, \u0026#34;email\u0026#34;: \u0026#34;love@example.com\u0026#34; } ], \u0026#34;fallbacks\u0026#34;: [ { \u0026#34;dest\u0026#34;: 80 // 或者回落到其它也防探测的代理 } ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;tcpSettings\u0026#34;: { \u0026#34;acceptProxyProtocol\u0026#34;: true } } }, 看，神奇的事情发生了， trojan 协议这里又出现了一个新的 fallbacks。前面已经说过，xray 中的 trojan 协议也具有完整的回落能力，所以，此时 trojan 协议可以再次做判断和回落（这也就是传说中的套娃回落了）：\n 所有 trojan 协议的流量，流入 Xray 中做后续处理 所有非 trojan 协议的流量，转发至 80 端口，【主动探测】的防御，完成！    后续处理回落至 1234 端口的流量，仔细看！它其实是 vless+ws：\n{ \u0026#34;port\u0026#34;: 1234, \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;vless\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;\u0026#34;, // 填写你的 UUID \u0026#34;level\u0026#34;: 0, \u0026#34;email\u0026#34;: \u0026#34;love@example.com\u0026#34; } ], \u0026#34;decryption\u0026#34;: \u0026#34;none\u0026#34; }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;ws\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;wsSettings\u0026#34;: { \u0026#34;acceptProxyProtocol\u0026#34;: true, // 提醒：若你用 Nginx/Caddy 等反代 WS，需要删掉这行 \u0026#34;path\u0026#34;: \u0026#34;/websocket\u0026#34; // 必须换成自定义的 PATH，需要和分流的一致 } } },   后续处理回落至 2345 端口的流量，仔细看！它其实是 vmess直连：\n{ \u0026#34;port\u0026#34;: 2345, \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;\u0026#34;, // 填写你的 UUID \u0026#34;level\u0026#34;: 0, \u0026#34;email\u0026#34;: \u0026#34;love@example.com\u0026#34; } ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;tcpSettings\u0026#34;: { \u0026#34;acceptProxyProtocol\u0026#34;: true, \u0026#34;header\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;request\u0026#34;: { \u0026#34;path\u0026#34;: [ \u0026#34;/vmesstcp\u0026#34; // 必须换成自定义的 PATH，需要和分流的一致 ] } } } } },   后续处理回落至 3456 端口的流量，再仔细看！它其实是是 vmess+ws(+cdn)。\n说明： 你没看错，这就是 v2fly 曾经的推荐组合之一，并可完整支持 CDN。现已加入完美回落套餐哦！\n { \u0026#34;port\u0026#34;: 3456, \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;\u0026#34;, // 填写你的 UUID \u0026#34;level\u0026#34;: 0, \u0026#34;email\u0026#34;: \u0026#34;love@example.com\u0026#34; } ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;ws\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;wsSettings\u0026#34;: { \u0026#34;acceptProxyProtocol\u0026#34;: true, // 提醒：若你用 Nginx/Caddy 等反代 WS，需要删掉这行 \u0026#34;path\u0026#34;: \u0026#34;/vmessws\u0026#34; // 必须换成自定义的 PATH，需要和分流的一致 } } }   至此，我们就能够完整的画出模板的回落路线了：\nmermaid.initialize({startOnLoad:true}); graph LR; W443(外部 HTTP:443 请求) -- X443(Xray-inbound: 443) .- X1{入站判断} X1 -- |协议 = VLESS 的流量| X2(Xray内部规则) X2 -- XO(Xray Outbounds 出站) X1 -- |path = /websocket 的流量| X1234(Xray-inbound:1234) X1 -- |path = /vmesstcp 的流量| X2345(Xray-inbound:2345) X1 -- |path = /vmessws 的流量| X3456(Xray-inbound:3456) X1 -- |其它所有流量| X1310(Xray-inbound:1310) X1234 -- X2 X2345 -- X2 X3456 -- X2 X1310 -- |协议 = trojan 的流量| X2 X1310 -- |其他所有流量| N80(Nginx:80) N80:::nginxclass -- H(index.html) H:::nginxclass classDef nginxclass fill:#FFFFDE    6. 结语 至此，Xray 的【回落】功能就介绍完了。希望本文能够对你理解 Xray 的强大有所帮助。\n 7. 附加题 我再无耻的留一个附加题：本文详解的 VLESS-TCP-XTLS-WHATEVER 模板？是否有可以优化的地方？\n提示：HTTP自动跳转HTTPS\n"},{"uri":"https://xtls.github.io/config/outbound-protocols/blackhole/","title":"Blackhole","tags":[],"description":"Project X 的文档.","content":"Blackhole（黑洞）是一个出站数据协议，它会阻碍所有数据的出站，配合 路由配置 一起使用，可以达到禁止访问某些网站的效果。\nOutboundConfigurationObject  { \u0026#34;response\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; } }  response: ResponseObject\n 配置黑洞的响应数据。\nBlackhole 会在收到待转发数据之后，发送指定的响应数据，然后关闭连接，待转发的数据将被丢弃。 如不指定此项，Blackhole 将直接关闭连接。\n\nResponseObject  { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }  type: \u0026ldquo;http\u0026rdquo; | \u0026ldquo;none\u0026rdquo;\n 当 type 为 \u0026quot;none\u0026quot;（默认值）时，Blackhole 将直接关闭连接。\n当 type 为 \u0026quot;http\u0026quot; 时，Blackhole 会发回一个简单的 HTTP 403 数据包，然后关闭连接。\n"},{"uri":"https://xtls.github.io/about/","title":"Project X","tags":[],"description":"Project X 的文档.","content":" Project X originates from XTLS protocol, provides a set of network tools such as Xray-core and Xray-flutter.\n Xray-core 是 v2ray-core 的超集，含更好的整体性能和 XTLS 等一系列增强，且完全兼容 v2ray-core 的功能及配置。  只有一个可执行文件，含 ctl 的功能，run 为默认指令 配置上完全兼容，环境变量和 API 对应要改为以 XRAY_ 开头 全平台开放了裸协议的 ReadV 提供完整的 VLESS \u0026amp; Trojan XTLS 支持，均有 ReadV 提供了 XTLS 多种流控模式, 性能一骑绝尘! “配置兼容，整体更好”\n    Xray-flutter 是一个优雅的跨平台图形界面工具.In progress   开发者   It doesn’t matter who we are. What matters is that we will keep riding and not look back. 帮助Xray变得更强  欢迎帮助Xray变得更强！\n 🖥️ 帮助开发和测试 Xray, 提交高质量的 Pull request. 📩 在 GitHub Issues 或讨论区发起建设性或有意义的 issue/讨论. 📝 写下您的使用心得并提交至 Xray 的文档网站. 💬 在 Telegram 群帮助群友/灌水. \u0026hellip;事实上,每一份给予 Xray 的正能量都会让 Xray 变得更强大   Telegram    Project X 交流群\n 交流群可在底线之上随便水，不要撕逼，没有滥权。 有问题尽管随便问，知道的尽量回答。 禁政治，禁NSFW    Project X 频道\n 发布Project X的最新资讯     致谢   感谢所有人的支持！ 感谢各类脚本、Docker 镜像、客户端支持\u0026hellip;感谢所有帮忙完善生态的大佬们！ 感谢为 Xray 网站和文档添砖加瓦的朋友们. 感谢提出有意义的建议和意见的朋友们. 感谢 Telegram 群每一位帮助群友的朋友.   更多关于 project X   如果你想知道更多关于 project X 的理念与密闻, 请点击这里 如果你想知道更多关于 project X 的足迹与成长, 请点击这里  \nLicense  Mozilla Public License Version 2.0 Stargazers over time  Project X 的 GitHub 主仓库 Xray-core 已获 2000 stars；Project X 群人数近 3000，频道订阅数 1000+\n\n"},{"uri":"https://xtls.github.io/config/transports/tcp/","title":"TCP","tags":[],"description":"Project X 的文档.","content":"TCP 传输模式是目前推荐使用的传输模式之一.\n可以和各种协议有多种组合模式.\nTcpObject  TcpObject 对应传输配置的 tcpSettings 项。\n{ \u0026#34;acceptProxyProtocol\u0026#34;: false, \u0026#34;header\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; } }  acceptProxyProtocol: true | false\n 仅用于 inbound，指示是否接收 PROXY protocol。\nPROXY protocol 专用于传递请求的真实来源 IP 和端口，若你不了解它，请先忽略该项。\n常见的反代软件（如 HAProxy、Nginx）都可以配置发送它，VLESS fallbacks xver 也可以发送它。\n填写 true 时，最底层 TCP 连接建立后，请求方必须先发送 PROXY protocol v1 或 v2，否则连接会被关闭。\n默认值为 false。\nheader: NoneHeaderObject | HttpHeaderobject\n 数据包头部伪装设置，默认值为 NoneHeaderObject。\nTIP\nHTTP 伪装无法被其它 HTTP 服务器（如 Nginx）分流，但可以被 VLESS fallbacks path 分流。\n \nNoneHeaderObject  不进行伪装\n{ \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }  type: \u0026ldquo;none\u0026rdquo;\n 指定不进行伪装\n\nHttpHeaderObject  HTTP 伪装配置必须在对应的入站出站连接上同时配置，且内容必须一致。\n{ \u0026#34;type\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;request\u0026#34;: {}, \u0026#34;response\u0026#34;: {} }  type: \u0026ldquo;http\u0026rdquo;\n 指定进行 HTTP 伪装\nrequest: HTTPRequestObject\n HTTP 请求\nresponse: HTTPResponseObject\n HTTP 响应\n\nHTTPRequestObject  { \u0026#34;version\u0026#34;: \u0026#34;1.1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;path\u0026#34;: [\u0026#34;/\u0026#34;], \u0026#34;headers\u0026#34;: { \u0026#34;Host\u0026#34;: [\u0026#34;www.baidu.com\u0026#34;, \u0026#34;www.bing.com\u0026#34;], \u0026#34;User-Agent\u0026#34;: [ \u0026#34;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36\u0026#34;, \u0026#34;Mozilla/5.0 (iPhone; CPU iPhone OS 10_0_2 like Mac OS X) AppleWebKit/601.1 (KHTML, like Gecko) CriOS/53.0.2785.109 Mobile/14A456 Safari/601.1.46\u0026#34; ], \u0026#34;Accept-Encoding\u0026#34;: [\u0026#34;gzip, deflate\u0026#34;], \u0026#34;Connection\u0026#34;: [\u0026#34;keep-alive\u0026#34;], \u0026#34;Pragma\u0026#34;: \u0026#34;no-cache\u0026#34; } }  version: string\n HTTP 版本，默认值为 \u0026quot;1.1\u0026quot;。\nmethod: string\n HTTP 方法，默认值为 \u0026quot;GET\u0026quot;。\npath: [ string ]\n 路径，一个字符串数组。默认值为 [\u0026quot;/\u0026quot;]。当有多个值时，每次请求随机选择一个值。\nheaders: map{ string, [ string ]}\n HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是一个数组。\n每次请求会附上所有的键，并随机选择一个对应的值。默认值见上方示例。\n\nHTTPResponseObject  { \u0026#34;version\u0026#34;: \u0026#34;1.1\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;200\u0026#34;, \u0026#34;reason\u0026#34;: \u0026#34;OK\u0026#34;, \u0026#34;headers\u0026#34;: { \u0026#34;Content-Type\u0026#34;: [\u0026#34;application/octet-stream\u0026#34;, \u0026#34;video/mpeg\u0026#34;], \u0026#34;Transfer-Encoding\u0026#34;: [\u0026#34;chunked\u0026#34;], \u0026#34;Connection\u0026#34;: [\u0026#34;keep-alive\u0026#34;], \u0026#34;Pragma\u0026#34;: \u0026#34;no-cache\u0026#34; } }  version: string\n HTTP 版本，默认值为 \u0026quot;1.1\u0026quot;。\nstatus: string\n HTTP 状态，默认值为 \u0026quot;200\u0026quot;。\nreason: string\n HTTP 状态说明，默认值为 \u0026quot;OK\u0026quot;。\nheaders: map {string, [ string ]}\n HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是一个数组。\n每次请求会附上所有的键，并随机选择一个对应的值。默认值见上方示例。\n"},{"uri":"https://xtls.github.io/develop/protocols/vless/","title":"VLESS 协议","tags":[],"description":"Project X 的文档.","content":"VLESS 是一个无状态的轻量传输协议，可以作为 Xray 客户端和服务器之间的桥梁。\n\nIn progress\n"},{"uri":"https://xtls.github.io/faq/start/","title":"下载和安装中的问题","tags":[],"description":"Project X 的文档.","content":" Q: 我想自己下载安装包, 可是release好多文件, 我要下载哪一个呢?请先使用谷歌搜索您的设备型号, 确认您设备使用的架构, 然后下载对应的版本.  Q: 我在VPS上运行了脚本, 好像安装好了, 可是似乎没反应?/系统服务不能启动?/我也不知道有没有安装成功?使用命令 \u0026lsquo;journalctl -u xray\u0026rsquo; 查看 xray 的相关日志。\n或者\n终端命令行中执行 \u0026lsquo;xray run -c 您的config.json文件路径\u0026rsquo; 来查看相关信息\n Q: 配置文件在哪个目录。谢谢!这位同学你可真的是不看文档, 不过因为你很有礼貌, 我可以告诉你在这里有所有文件的安装位置\n Q: 路由器容量小, Xray 放不进去!可以使用 UPX 工具来压缩文件大小.\n 启动速度可能会变慢, 但这是必须付出的代价 占用的内存，在启动静置稳定后是差不多的，实际运行占用看具体负载, 与UPX无关。   "},{"uri":"https://xtls.github.io/guide/install/","title":"下载安装","tags":[],"description":"Project X 的文档.","content":"平台支持  Xray 在以下平台中可用：\n Windows 7 及之后版本（x86 / amd64 / arm32）； macOS 10.10 Yosemite 及之后版本（amd64）； Linux 2.6.23 及之后版本（x86 / amd64 / arm / arm64 / mips64 / mips / ppc64 / s390x / riscv64）；  包括但不限于 Debian 7 / 8、Ubuntu 12.04 / 14.04 及后续版本、CentOS 7 / 8、Arch Linux 等；   FreeBSD (x86 / amd64)； OpenBSD (x86 / amd64)； Dragonfly BSD (amd64)；  \n下载 Xray  预编译的二进制 ZIP 格式压缩包可在 Github Releases 中找到。\n下载对应平台的压缩包，解压后即可使用。\n\n验证安装包  Xray 提供两种验证方式：\n ZIP 压缩包的 SHA1 / SHA256 摘要: In progress 可复现构建：In progress  \nWindows 安装方式  在 Github Releases 下载适用于 Windows 平台的 ZIP 压缩包，解压后可得到可执行文件 xray.exe，然后通过命令行带参数运行 即可 通过 Scoop 包管理器安装：In progress 通过 Chocolatey 包管理器安装：In progress  \nmacOS 安装方式  在 Github Releases 下载适用于 macOS 平台的 ZIP 压缩包，解压后可得到可执行文件 xray，然后通过命令行带参数运行 即可 通过 Homebrew 包管理器安装：In progress  \nLinux 安装方式  安装脚本    Linux Script\n Xray-install Xray-script    One Click\n ProxySU Xray-agent    Magisk\n Xray4Magisk Xray_For_Magisk    Linux 发行版包管理器  Linux 发行版 Xray 包（可通过发行版相应的包管理器安装）：\n Debian：In progress Arch Linux：In progress  Linuxbrew 包管理器  In progress\n\nDocker 安装方式   teddysun/xray Xray-docker  Docker image 的文件结构   /etc/xray/config.json：配置文件 /usr/bin/xray：Xray 主程序 /usr/local/share/xray/geoip.dat：IP 数据文件 /usr/local/share/xray/geosite.dat：域名数据文件  \n更多更多\u0026hellip;  您可以点击 传送至众多大佬集结区的任意门 获取更多资源\nFAQ In progress\n"},{"uri":"https://xtls.github.io/about/new/","title":"大史记","tags":[],"description":"Project X 的文档.","content":"2021.01.25  全互联网最好最详细的秘籍入门篇同学们练熟了吗? 🍉老师开始连载秘籍第一层咯\u0026hellip; 英文版文档网站逐渐增加内容ing, 感谢各位大佬的辛苦付出~!  \n2021.01.22 v1.2.3   对 SS 协议的支持又变强了, 支持单端口多用户! 对 trojan 协议的支持也又变强了, trojan 的回落也解锁 SNI 分流的新姿势啦~! (VLESS: 嘤嘤嘤) UDP 奇奇怪怪的 BUG 被干掉了, 一个字, \u0026ldquo;稳定\u0026rdquo;. 嗅探可以排除你不想嗅探的域名, 可以开启一些新玩法. 向发现问题-\u0026gt;开issue-\u0026gt;自行测试-\u0026gt;自行分析-\u0026gt;自行找到问题-\u0026gt;自行解决-\u0026gt;然后给上下游提交PR的大佬 @Bohan Yang 致敬! 其他美味小樱桃, 惯例更新品尝就对啦.  \n2021.01.19  一些数字  版本发布了 10 个 tag 解决掉了 100 个 issue 复刻了 300 个 fork 点了 2000 个 star 群 3000 个 人    \n2021.01.17  辛苦的翻译工作开始了, 感谢@玖柒Max和其他所有的翻译大佬们. English version  \n2021.01.15 v1.2.2   回落分流又解锁了奇怪的新姿势! 回落中可以根据 SNI 分流啦~! 之前预告的 UUID 修改正式上线.(往下看往下看) 日志现在看起来比上一次顺眼又更顺眼了一丢丢. 远程 DOH 和其他的DNS模式一样学会了走路由分流. 当然还有其他各种小糖果.(更新品尝就对了) 啊, 还有, 世界上第一個 M1 上跑起 Xray 的男人是 Anthony TSE  \n2021.01.12   将要到来的 UUID 修改, 支持自定义字符串和 UUID 之间的映射. 这意味着你将可以这样在配置文件中写id来对应用户.  客户端写 \u0026ldquo;id\u0026rdquo;: \u0026ldquo;我爱🍉老师1314\u0026rdquo;, 服务端写 \u0026ldquo;id\u0026rdquo;: \u0026ldquo;5783a3e7-e373-51cd-8642-c83782b807c5\u0026rdquo; (此UUID是 我爱🍉老师1314 的 UUID 映射)   🍉老师的小小白白话文大结局, 撒花.  \n2021.01.10   小小白白话文连载上线啦,🍉老师呕心沥血之作, 手把手教你从什么都不会到熟练配置Xray! (可能是整个互联网上, 最详细最有耐心的教你从0开始配置的教程) 透明代理也增加了更多文章. 还有很多细节修改, 文档将会越来越规范! 感谢 @ricuhkaen , @BioniCosmos, @kirin  v1.2.1   大量的 UDP 相关修复, 甚至可以在育碧的土豆服务器上玩彩虹六号! Google Voice 应该也可以正常使用 v2rayNG 拨打了. 日志现在看起来更顺眼.  \n2021.01.07   礼貌和尊重本应是社区不需要明说的准则之一。  \n2021.01.05   文档网站正在悄悄的进行着某些神秘的变化。。。，🙊🙊🙊  \n2021.01.03   文档仓库第一个PR。🎉\n透明代理（TProxy）配置教程  ，感谢@BioniCosmos tg群突破2500。  \n2021.01.01  【祝大家新年快乐，嗨皮牛耶！】🎆🎇🎆\nv1.2.0  🎁在元旦的最后几分钟，v1.2.0它来了，带着周五必更的惯例，带着各位贡献大佬的心血以及 @rprxx 的黑眼圈，不负众望的来了!\n 圣诞礼物v1.1.5后的元旦礼物🎁，游戏玩家大福利，全面 FullCone。 （UDP还会继续增强！） 如果你已经拆过圣诞礼物，这次还有比圣诞礼物更精美的包装和小糖果哦。（同样不用问，更新品尝就对了） （不，下面不是广告，是里程碑。） Xray 是有史以来第一个不受限制的多协议平台：只需 Xray 即可解决问题，无需借力其它实现。  一人扛起了所有！支持各大主流协议！ 一骑绝尘的性能! 日趋完善的功能! 可怕的生命力与社区亲和力！   Xray 将继续保持前行！ 因此 Xray 需要更多的英雄！！！ PS：请品，请细品release notes每一句。似乎有一个小秘密小彩蛋 （啊，有人敲门\u0026hellip;我一会和你们说）  \n2020.12.29 透明代理的游戏玩家利好！ Xray-core tproxy 入站， socks出站 UDP FullCone 测试版, TG群火热测试中\n\n2020.12.25  圣诞节快乐！\nv1.1.5   游戏玩家的圣诞礼物！你可以用xray爽快的打游戏啦！因为有了 SS/trojan UDP fullcone 你可以用你喜欢的格式写配置文件了，比如yaml，比如toml\u0026hellip; （VLESS 的 UDP fullcone和更多增强很快就到！） 无须再担心证书验证被墙，OCSP stapling 已经上线! kirin带来了一大波 脚本更新.脚本在此 还有更多美味小樱桃！（不用问，更新品尝就对了）  \n2020.12.24 因为某些不可描述的原因，Xray 的文档网站已在发布日前偷跑上线。\n网址为：没错你正在看的就是\n大家可以查阅各种内容也欢迎纠错/提出建议（可发往文档github仓库的issue区）\n文档网站需要不断完善和增加内容，以及完善设计。\n因此更欢迎大家一起为文档建设添砖加瓦。\n文档的仓库\n仓库的readme中有简略教程说明如何帮助xray改进文档网站.\n欢迎大家查看，纠错，修改，增加心得。\n\n2020.12.23 Xray-core Shadowsocks UDP FullCone 测试版, TG群火热测试中\n\n2020.12.21   Project X 群人数 2000+ 群消息(含游戏群) 日均破万  \n2020.12.18  v1.1.4   更低的启动内占用和内存使用优化 随意定制的 TLS 提高你的SSL评级 支持 XTLS 入站的 Splice 以及支持 trojan 的 XTLS 还有在您路由器上使用的Splice最佳使用模式建议  \n2020.12.17  鉴于日益增长群人数和游戏需求, 开启了TG游戏群\n\n2020.12.15  安装脚本dev分支开启, 持续更新功能中.\n\n2020.12.11  v1.1.3   完整版本的 REDIRECT 透明代理模式. 软路由 splice 流控模式的优化建议.  \n2020.12.06  v1.1.2   流控增加 splice 模式, Linux限定, 性能一骑绝尘. 增强了 API 兼容  \n2020.12.04  增加 splice 模式\n\n2020.11.27   Project X 的 GitHub 主仓库 Xray-core 已获 500+ stars 登上了 GitHub Trending Project X 群人数破千，频道订阅数 500+  \n2020.11.25  v1.0.0  Xray的第一个版本.\n 基于 v2ray-core 修改而来，改动较大 全面增强, 性能卓越, 完全兼容  \n2020.11.23  project X start\n"},{"uri":"https://xtls.github.io/documents/level-0/","title":"小小白白话文","tags":[],"description":"小小白白话文","content":" 这个章节是【从零开始】的基础课，新来的同学好好看好好学哦 Made with ❤️ by @ricuhkaen\n  【第1章】 前言罗嗦篇 - 机场还是自建？这是个问题\n【第2章】 原料准备篇 - 工欲善其事，必先利其器\n【第3章】 远程登录篇 - 一桥飞架南北，天堑变通途\n【第4章】 安全防护篇 - 安全不注意，亲人两行泪\n【第5章】 网站建设篇 - 秀出你的美\n【第6章】 证书管理篇 - 领证的才是合法的\n【第7章】 Xray服务器篇 - 终于等到你 \n【第8章】 Xray客户端篇 - 新的开始 \n【第9章】 附录 - 考点都在这里 \n "},{"uri":"https://xtls.github.io/develop/intro/","title":"开发手册","tags":[],"description":"Project X 的文档.","content":" 如果您想帮助 Xray 开发, 请详细阅读本章节中的内容 编译 Xray 支持各种平台, 您可以在多种平台上自行进行交叉编译.\n请点击编译以查看具体编译相关内容\n 设计思路 Xray 内核提供了一个平台，在其之上可以进二次开发 这个章节阐述了Xray的设计目标和架构.\n请点击设计思路以了解Xray的设计目标和架构.\n 开发规范 这个章节阐述了获取代码,进行开发,提交PR的流程中需要遵循的准则, 以及相关的编码规范\n请点击开发规范查看Xray开发中应遵循的准则.\n  \n协议详解 Xray 用到了很多种协议, 您可以通过各种途径获得协议的详细描述.\n请点击协议详解以查看相关协议的详细剖析\n  "},{"uri":"https://xtls.github.io/config/base/log/","title":"日志配置","tags":[],"description":"Project X 的文档.","content":"日志配置，控制 Xray输出日志的方式.\nXray 有两种日志, 访问日志和错误日志, 你可以分别配置两种日志的输出方式.\nLogObject  LogObject 对应配置文件的 log 项。\n{ \u0026#34;log\u0026#34;: { \u0026#34;access\u0026#34;: \u0026#34;文件地址\u0026#34;, \u0026#34;error\u0026#34;: \u0026#34;文件地址\u0026#34;, \u0026#34;loglevel\u0026#34;: \u0026#34;warning\u0026#34;, \u0026#34;dnsLog\u0026#34;: false } }  access: string\n 访问日志的文件地址，其值是一个合法的文件地址，如\u0026quot;/var/log/Xray/access.log\u0026quot;（Linux）或者\u0026quot;C:\\\\Temp\\\\Xray\\\\_access.log\u0026quot;（Windows）。当此项不指定或为空值时，表示将日志输出至 stdout。\n 特殊值none，即关闭 access log。  error: string\n 错误日志的文件地址，其值是一个合法的文件地址，如\u0026quot;/var/log/Xray/error.log\u0026quot;（Linux）或者\u0026quot;C:\\\\Temp\\\\Xray\\\\_error.log\u0026quot;（Windows）。当此项不指定或为空值时，表示将日志输出至 stdout。\n 特殊值none，即关闭 error log。  loglevel: \u0026ldquo;debug\u0026rdquo; | \u0026ldquo;info\u0026rdquo; | \u0026ldquo;warning\u0026rdquo; | \u0026ldquo;error\u0026rdquo; | \u0026ldquo;none\u0026rdquo;\n error 日志的级别, 指示 error 日志需要记录的信息. 默认值为 \u0026quot;warning\u0026quot;。\n \u0026quot;debug\u0026quot;：调试程序时用到的输出信息。同时包含所有 \u0026quot;info\u0026quot; 内容。 \u0026quot;info\u0026quot;：运行时的状态信息等，不影响正常使用。同时包含所有 \u0026quot;warning\u0026quot; 内容。 \u0026quot;warning\u0026quot;：发生了一些并不影响正常运行的问题时输出的信息，但有可能影响用户的体验。同时包含所有 \u0026quot;error\u0026quot; 内容。 \u0026quot;error\u0026quot;：Xray 遇到了无法正常运行的问题，需要立即解决。 \u0026quot;none\u0026quot;：不记录任何内容。  dnsLog: bool\n 是否启用 DNS 查询日志，例如： DOH//doh.server got answer: domain.com -\u0026gt; [ip1, ip2] 2.333ms\n"},{"uri":"https://xtls.github.io/develop/intro/compile/","title":"编译","tags":[],"description":"Project X 的文档.","content":"前序工作  Xray 使用 Golang 作为主要编程语言。\n 下载 Golang: Downloads 安装 Golang: install  important请使用 Golang 1.15 以上版本。\n \n编译  拉取 Xray 源代码和依赖  在安装了git的环境下, 只需要执行以下命令即可clone一份完整的Xray-core代码:\ngit clone https://github.com/XTLS/Xray-core.git \n注意事项  在无法正常访问 Google 的网络环境，依赖可能无法被正常拉取，可以通过各种手段代理解决.\n比如可以通过设置 GOPROXY：\ngo env -w GOPROXY=https://goproxy.io,direct \n手工编译  important本小节的命令需要在 Xray 项目根目录内运行。\n 在 Linux 环境下, 只需执行以下命令, 即可在当前目录下生成刚构建的 xray 可执行文件。\nCGO_ENABLED=0 go build -o xray -trimpath -ldflags \u0026#34;-s -w -buildid=\u0026#34; ./main 如果需要编译可以进行debug的程序,即可以用dlv附加到运行的程序进行调试, 请去掉 ldflags 中的 \u0026lsquo;-w -s\u0026rsquo; 选项.\nTIP\n-w 禁止生成debug信息,注意使用该选项后，无法使用 gdb 进行调试\n-s 禁用符号表\nPS:其实用vscode调试似乎更方便.\n \n交叉编译  构建其他 CPU 架构、其他系统（Windows/macOS）的可执行文件需要设置 GOOS 和 GOARCH 两个环境变量为目标平台/架构.\n可以参考 Golang 相关文档 比如Building Windows Go programs on Linux。\n如下面代码即可以构建可运行在 Windows 64 位系统的 xray.exe 可执行文件：\nCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -o xray.exe -trimpath -ldflags \u0026#34;-s -w -buildid=\u0026#34; ./main  TIP\n执行 go tool dist list 可以查看所有支持的系统与架构。 某些架构还需要控制其它环境变量，如 arm 的 GOARM，用于设置运行时 CPU 浮点协处理器的版本。\n "},{"uri":"https://xtls.github.io/documents/level-2/transparent_proxy/transparent_proxy/","title":"透明代理入门","tags":[],"description":"Project X 的文档.","content":"什么是透明代理 透明代理简单地说就是不让被代理的设备感觉到自己被代理了。简单地说就是，被代理的设备上不需要运行任何代理软件(比如Xray、V2RayNG等)，当你连接上网络时，你的设备已经被代理了。\n这也意味着，代理的软件运行在别的地方，比如运行在路由器中，通过路由器上网的设备就自动被代理了。\n透明代理的实现 透明代理的实现目前主要有两种方式：\ntun2socks 可用Windows/Linux(包括安卓)实现。因为实现过程比较简单，很少有教程，我这里简单描述一下。\nWindows\n  安装 Netch ，使用模式[3] [TUN/TAP] 绕过局域网启动。\n  开启热点\n  打开控制面板-\u0026gt;网络和 Internet-\u0026gt;网络和共享中心-\u0026gt;更改适配器设置，找到TAP-Windows Adapter和Microsoft Wi-Fi Direct Virtual Adapter。\n  鼠标右键点击TAP-Windows Adapter，属性-\u0026gt;共享，勾选允许其他网络用户通过此计算机的 Internet 连接来连接，在家庭网络连接中选择Microsoft Wi-Fi Direct Virtual Adapter的那个网络连接，点击确定。\n  Android\n  配置连接V2RayNG\n  开启热点\n  热点设置 -\u0026gt; 允许热点使用VPN(部分安卓系统可能没有这个选项)\n  iptables/nftables iptables与nftables实现透明代理的原理相同，下文统一使用iptables。\n基于iptables的透明代理实现只能用于Linux系统(包括openwrt/安卓)。由于其比tun2socks更高效率以及适合在路由器中配置而广泛使用。\n现存的三篇白话文透明代理教程其实讲的都是基于这种方案的透明代理实现，它们是： 新 V2Ray 白话文指南-透明代理 、 新 V2Ray 白话文指南-透明代理(TPROXY) 、 透明代理（TProxy）配置教程 。其中第一篇是基于iptables-redirect模式，已经过时了，不建议使用，仅供参考。第二篇和第三篇讲的都是基于iptables-tproxy模式的透明代理实现。\niptables实现透明代理原理 Linux使用Netfilter来管理网络，Netfilter模型如下：\n假设使用路由器作为网关(即我们平时的上网方式)，那么：\n局域网设备通过路由器访问互联网的流量方向：\nPREROUTING链-\u0026gt;FORWARD链-\u0026gt;POSTINGROUTING链\n局域网设备访问路由器的流量(如登陆路由器web管理界面/ssh连接路由器/访问路由器的dns服务器等)方向：\nPREROUTING链-\u0026gt;INPUT链-\u0026gt;网关本机\n路由器访问互联网的流量方向：\n网关本机-\u0026gt;OUTPUT链-\u0026gt;POSTINGROUTING链\n通过使用iptables操控PREROUTING链和OUTPUT链的流量走向，转发到Xray，就可以代理局域网设备和网关本机。\n透明代理难在哪里 透明代理的难点就在于路由，所谓路由，就是区分哪些流量是直连的，哪些该被代理，所以我个人认为叫做分流更加合适。\n我们可以把路由由易到难分为以下几个阶段：\n  代理全部请求\n  本地局域网IP/组播IP请求直连，其它请求代理\n  在2的基础上直连Xray发起的连接请求\n  在3的基础上直连指向中国大陆IP的连接请求，并对国内外域名选择国内外DNS服务器解析。\n  上面说的三篇教程，都是在第四阶段。所以新手直接阅读可能显得有点难懂。\n从零开始一步步实现基于iptables-tproxy的透明代理 在开始之前，你需要有一定的基础知识：   大概知道什么是TCP/IP协议、域名和DNS服务器\n  知道什么是WAN口，LAN口，LAN_IP，WAN_IP以及DHCP服务器。对于旁路由，只有一个网口，这里称其为LAN口\n  对Linux系统有最基础的了解(知道怎么运行命令)\n  能够手写客户端json文件配置，至少要能看懂\n  前期准备工作 1. 准备一个运行Linux系统的网关\n比如，刷了OpenWRT的路由器\n2. 在网关(路由器)准备好Xray可执行文件以及配置文件\n配置文件监听12345端口，开启tproxy：\n{ \u0026#34;log\u0026#34;: { \u0026#34;loglevel\u0026#34;: \u0026#34;warning\u0026#34; }, \u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 12345, \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;tcp,udp\u0026#34;, \u0026#34;followRedirect\u0026#34;: true }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;sockopt\u0026#34;: { \u0026#34;tproxy\u0026#34;: \u0026#34;tproxy\u0026#34; } } } ], \u0026#34;outbounds\u0026#34;: [ { 你的服务器配置 } ] } 我们由易到难，不写routing，只写一个inbound一个outbound。\n首先，我们先试试做到第一阶段 将所有PREROUTING链的流量，都转发到Xray中。\n运行Xray，执行以下指令：\nip rule add fwmark 1 table 100 ip route add local 0.0.0.0/0 dev lo table 100 iptables -t mangle -N XRAY iptables -t mangle -A XRAY -p tcp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A XRAY -p udp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A PREROUTING -j XRAY 当你输入完之后，如果你是使用ssh连接到网关上的，你会发现ssh的连接断开了(不用紧张，断电重启即可恢复)，并且透明代理无法上网；如果你是的网关是虚拟机，你会发现网关本身也无法上网，并且Xray日志access_log中出现许多源地址为目标地址，目标地址为WAN_IP的请求。\n理论上网关本机访问公网只会经过OUTPUT链和POSTROUTING链，为什么操控PREROUTING链会导致网关无法上网呢？这是因为网络通讯往往是双向的，虽然网关访问公网IP不需要经过PREROUTING链，但被访问的服务器向网关返回信息时要经过PREROUTING链，且这部分被转发到Xray了，因此出现了日志中的反向请求。\n我们修改一下规则，源IP不是来自局域网的则返回。重启网关，运行Xray，执行以下指令：\nip rule add fwmark 1 table 100 ip route add local 0.0.0.0/0 dev lo table 100 iptables -t mangle -N XRAY # \u0026#34;网关LAN_IP地址段\u0026#34; 通过运行命令\u0026#34;ip address | grep -w \u0026#34;inet\u0026#34; | awk \u0026#39;{print $2}\u0026#39;\u0026#34;获得，是其中的一个 iptables -t mangle -A XRAY ! -s 网关LAN_IP地址段 -j RETURN iptables -t mangle -A XRAY -p tcp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A XRAY -p udp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A PREROUTING -j XRAY 然后你会发现，虽然ssh连接断开了，但是透明代理已经可用了。只要我们修改系统dns为公共dns，就能正常上网了(因为现在网关访问不了，所以dns设置为网关是不行的)。\n至此，第一阶段就完成了。之所以无法访问网关，是因为代理规则代理了全部流量，包括访问网关的流量。试想在VPS上访问你本地的网关，肯定是访问不了的，所以我们要对这部分流量直连，请看第二阶段：\n第二阶段 重启网关，运行Xray，执行以下指令：\nip rule add fwmark 1 table 100 ip route add local 0.0.0.0/0 dev lo table 100 iptables -t mangle -N XRAY # 所有目标地址在网关所在网段的请求直连 # 通过运行命令\u0026#34;ip address | grep -w \u0026#34;inet\u0026#34; | awk \u0026#39;{print $2}\u0026#39;\u0026#34;获得，一般来说有多个 iptables -t mangle -A XRAY -d 网关所在网段1 -j RETURN iptables -t mangle -A XRAY -d 网关所在网段2 -j RETURN ... # 目标地址为组播IP的请求直连 iptables -t mangle -A XRAY -d 224.0.0.0/4 -j RETURN iptables -t mangle -A XRAY -d 255.255.255.255/32 -j RETURN iptables -t mangle -A XRAY -p tcp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A XRAY -p udp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A PREROUTING -j XRAY 使用这条规则后，上一条规则iptables -t mangle -A XRAY ! -s 网关LAN_IP地址段 -j RETURN便成为了多余规则，可以删去。\n至此，第二阶段完成。网关已经可以访问，ssh不会断开。\n第三阶段 我们平时用的DNS一般来自路由器，但这个iptables规则只代理了局域网中的设备，却没有代理网关本机，这样返回的DNS查询结果可能是错误的或者污染的。\niptables-tproxy不支持对OUTPUT链操作，但是Netfilter有个特性，在OUTPUT链给包打标记为1后相应的包会重路由到PREROUTING链上。所以我们就给网关本机需要代理的请求在OUTPUT链上标记1即可。\n如果要代理网关本机发出的的全部请求，就会引入一个问题，Xray运行在网关，Xray向代理服务端发送请求，这个请求又被代理了，就形成了回环。\n因此要代理网关本机，就要避免回环发生，即代理规则中规避Xray请求的流量。\n常见的方法有三种：\n 直连目标地址为VPS的流量  重启网关，运行Xray，执行以下指令：\n#代理局域网设备 #继承上一个阶段的成果 ip rule add fwmark 1 table 100 ip route add local 0.0.0.0/0 dev lo table 100 iptables -t mangle -N XRAY iptables -t mangle -A XRAY -d 网关所在网段1 -j RETURN iptables -t mangle -A XRAY -d 网关所在网段2 -j RETURN ... iptables -t mangle -A XRAY -d 224.0.0.0/4 -j RETURN iptables -t mangle -A XRAY -d 255.255.255.255/32 -j RETURN iptables -t mangle -A XRAY -p tcp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A XRAY -p udp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A PREROUTING -j XRAY #代理网关本机 iptables -t mangle -N XRAY_MASK iptables -t mangle -A XRAY_MASK -d 网关所在网段1 -j RETURN iptables -t mangle -A XRAY_MASK -d 网关所在网段2 -j RETURN ... iptables -t mangle -A XRAY_MASK -d 224.0.0.0/4 -j RETURN iptables -t mangle -A XRAY_MASK -d 255.255.255.255/32 -j RETURN iptables -t mangle -A XRAY_MASK -d VPS公网ip/32 -j RETURN iptables -t mangle -A XRAY_MASK -j MARK --set-mark 1 iptables -t mangle -A OUTPUT -p tcp -j XRAY_MASK iptables -t mangle -A OUTPUT -p udp -j XRAY_MASK 但是这么配置有个缺点，如果使用CDN或者VPS很多的话，就不好写规则了。\n通过mark规避  三个白话文教程都是使用这种方法规避，自行参考，这里不再赘述。\n通过gid规避(推荐)  参考 [透明代理]通过gid规避Xray流量\n这样就完成了第三阶段的代理，也就是平时说的全局代理。但是记得把网关的DNS服务器设置为国外的DNS服务器，否则可能依然返回被污染的结果。\n第四阶段 其实，并不是所有人都需要实现第四阶段。全局代理对于大部分情况已经适用。\n特别是对于旁路由而言。需要代理时，将网关调成旁路由的IP，不需要代理时，将网关换回主路由IP。\n至于第四阶段的具体实现，那三篇白话文教程讲的都是。在理解了上面的内容后，再去看那三篇白话文教程，就比较容易理解了。\n代理ipv6 上面的规则只对ipv4生效，如果还想要代理ipv6请求，则使用ip6tables命令，用法与iptables基本相同。参考 [透明代理]通过gid规避Xray流量#4-设置iptables规则\niptables透明代理的其它注意事项   如果作为代理的网关作为主路由，要在PREROUTING链规则中加一条iptables -t mangle -A XRAY ! -s 网关LAN_IP地址段 -j RETURN，即在第一阶段使用、第二阶段被删除的指令。如果不写，WAN口中同网段的其它人可以将网关填写成你的WAN_IP，从而蹭你的透明代理用，还可能带来一定的危险性。\n  新 V2Ray 白话文指南-透明代理(TPROXY)#设置网关 中的第三条说：手动配置 PC 的网络，将默认网关指向树莓派的地址即 192.168.1.22。此时 PC 应当能正常上网（由于还没设置代理，“正常”是指可以上国内的网站）。实际上，Ubuntu、CentOS、debian等系统就算开启了IP转发，PC也不能正常上网，这是正常的。事实上只有OpenWRT能做到文中所描述的那样，据 @BioniCosmos 点拨，这是由于一般的Linux系统没有Masquery规则。\n  too many open files 问题 ，解决方法见 [透明代理]通过gid规避Xray流量-配置最大文件大开数\u0026amp;运行Xray客户端\n  关于开启ip_forward，待补充\u0026hellip;\n  避免已有连接的包二次通过 TPROXY ,待补充\u0026hellip;\n  主路由、单臂路由与旁路由，待补充\u0026hellip;\n  "},{"uri":"https://xtls.github.io/documents/level-1/fallbacks-with-sni/","title":"通过 SNI 回落功能实现伪装与按域名分流","tags":[],"description":"Project X 的文档.","content":"VLESS 是一种很轻的协议，和 Trojan 一样，不对流量进行复杂的加密和混淆，而是大隐隐于市，通过 TLS 协议加密，混杂在其他 HTTPS 流量中，在墙内外穿进穿出。为了更好的伪装以应对主动探测，Fallbacks 回落功能随 VLESS 同时出现。这篇教程将演示如何使用 Xray 中 VLESS 入站协议的回落功能配合 Nginx 或 Caddy 在保证伪装完全的前提下实现按域名分流。\n应用情景 由于 XTLS，Xray 需要监听 443 端口，这导致如果之前有网站运行在服务器上，那么此时网站无法运行或需要运行在其他端口上，这显然是不合理的。有以下三种方案可以解决这个问题：\n  Xray 监听其他常用端口（如 22、3389、8443）\n这个方案是最简单的，但不够完美。\n  Nginx 或 HAProxy 监听 443 端口，通过 SNI 分流做 L4 反向代理，实现端口复用\n这个方案比较复杂，需要对 Nginx 或 HAProxy 的使用有一定了解，此处不作过多解释。\n  Xray 监听 443 端口，通过 Fallbacks 功能 SNI 分流将网站流量回落到 Nginx 或 Caddy\n这个方案难度适中，也是此教程接下来想要演示的方案。\n  SNI 简介 服务器名称指示（英语：Server Name Indication，缩写：SNI）是 TLS 的一个扩展协议。熟悉反向代理的朋友都知道，如果想要通过域名将流量代理到正确的内容上，需要以下配置：\nproxy_set_header Host 主机名; 这句的作用是将名为 “Host” 的 HTTP Header 设定为某个主机名。为什么要这样做？一般而言，一台服务器对应一个 IP，但却运行多个网站，访问者通过域名查询到 IP 以访问服务器，那么问题来了，如何确定访问者想要访问的是哪一个网站？这需要“基于名称的虚拟主机”。\n当 Web 服务器收到访问请求后，它会查看请求的主机头，使访问者访问正确的网站。然而当 HTTP 协议被 TLS 协议加密后，这种简单的方法就无法实现了。因为 TLS 握手发生在服务器看到任何 HTTP 头之前，因此，服务器不可能使用 HTTP 主机头中的信息来决定呈现哪个证书，更无法决定访问者的访问目标。\nSNI 的原理也很简单，它通过让客户端发送主机名作为 TLS 协商的一部分来解决此问题。所以在使用 Nginx 对 HTTPS 协议进行反向代理时，需要在配置中加入 proxy_ssl_server_name on;，此时 Nginx 会向被代理的服务器发送 SNI 信息，解决了 HTTPS 协议下虚拟主机失效的问题。另外，使用 SNI 时，即使不指定主机头，也可以正确访问网站。\n思路 从 443 端口接收到流量后，Xray 会把 TLS 解密后首包长度 \u0026lt; 18、协议版本无效或身份认证失败的流量通过对 name、path、alpn 的匹配转发到 dest 指定的地址。\n添加 DNS 记录 请按实际情况修改域名和 IP。\n申请 TLS 证书 由于要对不同前缀的域名进行分流，但一个通配符证书的作用域仅限于两“.”之间（例如：申请 *.example.com，example.com 和 *.*.example.com 并不能使用该证书），故需申请 SAN 通配符证书。根据 Let\u0026rsquo;s Encrypt 官网信息1，申请通配符证书要求 DNS-01 验证方式，此处演示 NS 记录为 Cloudflare 的域名通过 acme.sh 申请 Let\u0026rsquo;s Encrypt 的免费 TLS 证书。使用其他域名托管商的申请方法请阅读 dnsapi · acmesh-official/acme.sh Wiki。\n首先需要到 Cloudflare 面板创建 API Token。参数如下：\n权限部分至关重要，其他部分任意。\n创建完毕后，你会得到一串神秘字符，请将其妥善保管到安全且不会丢失的地方，因为它不再会显示。这串字符就是即将用到的 CF_Token。\n 注意：以下操作需要在 root 用户下进行，使用 sudo 会出现错误。\n curl https://get.acme.sh | sh # 安装 acme.sh export CF_Token=\u0026#34;sdfsdfsdfljlbjkljlkjsdfoiwje\u0026#34; # 设定 API Token 变量 acme.sh --issue -d example.com -d *.example.com --dns dns_cf # 使用 DNS-01 验证方式申请证书 mkdir /etc/ssl/xray # 新建证书存放目录 acme.sh --install-cert -d example.com --fullchain-file /etc/ssl/xray/cert.pem --key-file /etc/ssl/xray/privkey.key --reloadcmd \u0026#34;chown nobody:nogroup -R /etc/ssl/xray \u0026amp;\u0026amp; systemctl restart xray\u0026#34; # 安装证书到指定目录并设定自动续签生效指令 Xray 配置 { \u0026#34;log\u0026#34;: { \u0026#34;loglevel\u0026#34;: \u0026#34;warning\u0026#34; }, \u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 443, \u0026#34;protocol\u0026#34;: \u0026#34;vless\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;UUID\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34; } ], \u0026#34;decryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;fallbacks\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;example.com\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/vmessws\u0026#34;, \u0026#34;dest\u0026#34;: 5000, \u0026#34;xver\u0026#34;: 1 }, { \u0026#34;dest\u0026#34;: 5001, \u0026#34;xver\u0026#34;: 1 }, { \u0026#34;alpn\u0026#34;: \u0026#34;h2\u0026#34;, \u0026#34;dest\u0026#34;: 5002, \u0026#34;xver\u0026#34;: 1 }, { \u0026#34;name\u0026#34;: \u0026#34;blog.example.com\u0026#34;, \u0026#34;dest\u0026#34;: 5003, \u0026#34;xver\u0026#34;: 1 }, { \u0026#34;name\u0026#34;: \u0026#34;blog.example.com\u0026#34;, \u0026#34;alpn\u0026#34;: \u0026#34;h2\u0026#34;, \u0026#34;dest\u0026#34;: 5004, \u0026#34;xver\u0026#34;: 1 } ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;xtls\u0026#34;, \u0026#34;xtlsSettings\u0026#34;: { \u0026#34;alpn\u0026#34;: [ \u0026#34;h2\u0026#34;, \u0026#34;http/1.1\u0026#34; ], \u0026#34;certificates\u0026#34;: [ { \u0026#34;certificateFile\u0026#34;: \u0026#34;/etc/ssl/xray/cert.pem\u0026#34;, \u0026#34;keyFile\u0026#34;: \u0026#34;/etc/ssl/xray/privkey.key\u0026#34; } ] } } }, { \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 5000, \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;UUID\u0026#34; } ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;ws\u0026#34;, \u0026#34;wsSettings\u0026#34;: { \u0026#34;acceptProxyProtocol\u0026#34;: true, \u0026#34;path\u0026#34;: \u0026#34;/vmessws\u0026#34; } } } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34; } ] } 以上配置针对于 Nginx，以下是需要注意的一些细节。\n  有关 Proxy Protocol\nProxy Protocol 是 HaProxy 开发的一种旨在解决代理时容易丢失客户端信息问题的协议，常用于链式代理和反向代理。传统的处理方法往往较为复杂且有诸多限制，而 Proxy Protocol 非常简单地在传输数据时附带上原始连接四元组信息的数据包，解决了这个问题。\n凡事皆有利弊，Proxy Protocol 也是如此。\n 有发送必须有接收，反之亦然 同一端口不能既兼容带 Proxy Protocol 数据的连接又兼容不带数据的连接（如：Nginx 同端口的不同虚拟主机（server），本质是上一条）23  在遇到异常时，请考虑配置是否符合上述条件。\n此处，我们使用 Proxy Protocol 让被回落到的目标获取到客户端的真实 IP。\n另外，当 Xray 的某个入站配置存在 \u0026quot;acceptProxyProtocol\u0026quot;: true 时，ReadV 将失效。\n  有关 HTTP/2\n首先，inbounds.streamSettings.xtlsSettings.alpn 有顺序，应将 h2 放前，http/1.1 放后，在优先使用 HTTP/2 的同时保证兼容性；反过来会导致 HTTP/2 在协商时变为 HTTP/1.1，成为无效配置。\n在上述配置中，每条回落到 Nginx 的配置都要分成两个。这是因为 h2 是强制 TLS 加密的 HTTP/2 连接，这有益于数据在互联网中传输的安全，但在服务器内部没有必要；而 h2c 是非加密的 HTTP/2 连接，适合该环境。然而，Nginx 不能在同一端口上同时监听 HTTP/1.1 和 h2c，为了解决这个问题，需要在回落中指定 alpn 项（是 fallbacks 而不是 xtlsSettings 里面的），以尝试匹配 TLS ALPN 协商结果。\n建议 alpn 项只按需用两种填法：4\n 省略 \u0026quot;h2\u0026quot;  如果使用 Caddy 就大可不必如此繁杂了，因为它可以在同一端口上同时监听 HTTP/1.1 和 h2c，配置改动如下：\n\u0026#34;fallbacks\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;example.com\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/vmessws\u0026#34;, \u0026#34;dest\u0026#34;: 5000, \u0026#34;xver\u0026#34;: 1 }, { \u0026#34;dest\u0026#34;: 5001, \u0026#34;xver\u0026#34;: 1 }, { \u0026#34;name\u0026#34;: \u0026#34;blog.example.com\u0026#34;, \u0026#34;dest\u0026#34;: 5002, \u0026#34;xver\u0026#34;: 1 } ]   Nginx 配置 Nginx 将通过官方源进行安装。\nsudo apt install curl gnupg2 ca-certificates lsb-release echo \u0026#34;deb [arch=amd64] http://nginx.org/packages/ubuntu `lsb_release -cs` nginx\u0026#34; \\  | sudo tee /etc/apt/sources.list.d/nginx.list curl -fsSL https://nginx.org/keys/nginx_signing.key | sudo apt-key add - sudo apt update sudo apt install nginx 删除 /etc/nginx/conf.d/default.conf 并创建 /etc/nginx/conf.d/fallbacks.conf，内容如下：\nset_real_ip_from 127.0.0.1; real_ip_header proxy_protocol; server { listen 127.0.0.1:5001 proxy_protocol default_server; listen 127.0.0.1:5002 proxy_protocol default_server http2; location / { root /srv/http/default; } } server { listen 127.0.0.1:5003 proxy_protocol; listen 127.0.0.1:5004 proxy_protocol http2; server_name blog.example.com; location / { root /srv/http/blog.example.com; } } server { listen 80; return 301 https://$host$request_uri; } Caddy 配置 安装 Caddy 请参阅 Install — Caddy Documentation。\n为了使 Caddy 能获取到访问者的真实 IP，需要编译带有 Proxy Protocol 模块的 Caddy。建议直接在 Caddy 官网上在线编译。\nsudo curl -o /usr/bin/caddy \u0026#34;https://caddyserver.com/api/download?os=linux\u0026amp;arch=amd64\u0026amp;p=github.com%2Fmastercactapus%2Fcaddy2-proxyprotocol\u0026amp;idempotency=79074247675458\u0026#34; sudo chmod +x /usr/bin/caddy 直接替换即可。\n 建议先通过官网文档安装 Caddy，再替换二进制文件。这样做无需手动设定进程守护。\n 编辑 /etc/caddy/Caddyfile：\n{ servers 127.0.0.1:5001 { listener_wrappers { proxy_protocol } protocol { allow_h2c } } servers 127.0.0.1:5002 { listener_wrappers { proxy_protocol } protocol { allow_h2c } } } :5001 { root * /srv/http/default file_server log bind 127.0.0.1 } http://blog.example.com:5002 { root * /srv/http/blog.example.com file_server log bind 127.0.0.1 } :80 { redir https://{host}{uri} permanent } 参考  服务器名称指示 - 维基百科，自由的百科全书 Home · acmesh-official/acme.sh Wiki HTTP/2 - 维基百科，自由的百科全书  引用   常见问题 - Let\u0026rsquo;s Encrypt - 免费的SSL/TLS证书 \u0026#x21a9;\u0026#xfe0e;\n Proxy Protocol - HAProxy Technologies \u0026#x21a9;\u0026#xfe0e;\n proxy protocol介绍及nginx配置 - 简书 \u0026#x21a9;\u0026#xfe0e;\n v2fly-github-io/vless.md at master · rprx/v2fly-github-io \u0026#x21a9;\u0026#xfe0e;\n   "},{"uri":"https://xtls.github.io/documents/level-0/ch02-preparation/","title":"【第2章】原料准备篇","tags":[],"description":"小小白白话文","content":"这一章比较特殊，因为涉及到金钱交易行为，本文基于项目的中立立场，不做具体的推荐。我能做的，是告诉你需要准备哪些东西。\n2.1 获取一台VPS  你需要获取一台健康的、IP没有被墙的VPS，并在管理后台做下面这些基础准备：\n 在VPS的后台安装 Debian 10 64bit 系统 小本本记下VPS的IP地址（本文会用 \u0026quot;100.200.300.400\u0026quot; 来表示） 注意： 这是一个故意写错的非法IP，请替换成你的真实IP）\n  小本本记下VPS的SSH远程登陆端口(Port) 小本本记下SSH远程登录的用户名和密码  购买VPS是一个比较复杂的事情，建议先去学习一下相关知识，选择适合自己的经济能力和线路需求的即可。另外可以选择薅一些国际大厂的羊毛（比如甲骨文和谷歌提供的永久免费或限时免费的套餐）。总之，务必量力而行。\n说明： 关于选择 Debian 10 作为操作系统，这里稍微多说一句：不管你在网上听说了什么，不管哪个大神告诉你XXX版的Linux更好、XXX版的Linux更牛，这些Linux的派系之争跟现在的你半毛钱关系也没有！使用 Debian 10 足以让你的VPS服务器在安全、稳健运行的同时得到足够的优化（如cloud专用内核、及时的bbr支持等）。等你对Linux熟悉之后，再回头去尝试其他的Linux发行版也不迟\n  2.2 获取一个心仪的域名  你需要获取一个域名、并在DNS设置中添加一条A记录，指向你VPS的IP地址\n  请选择靠谱的国际域名服务商。选择一些常见的域名后缀就行，注意不要用 .cn 后缀。\n  在DNS设置中，添加一条指向你VPS的IP地址的A记录（A记录的名字可以随便起，本文会用 \u0026quot;a-name\u0026quot; 来表示。完整的域名则会用 \u0026quot;二级域名.你的域名.com\u0026quot; 或者 \u0026quot;a-name.yourdomain.com\u0026quot; 来表示）。效果如下图：\n注意： 这不是一个真实可用的网址，请替换成你的真实网址\n    2.3 你本地电脑上需要安装的软件    SSH远程登录工具\n Windows: PuTTY macOS/Linux: Terminal    远程文件拷贝工具\n Windows: WinSCP macOS/Linux: Terminal    靠谱的文本编辑器\n Windows/macOS/Linux: VSCode     2.4 你的进度  如果上面的原材料你都准备好了的话，你已经拿到了开启新世界大门的钥匙。那还等什么，让我们快点进入下一章，走进这扇门吧！\nPROGRESS⬛⬛⬜⬜⬜⬜⬜⬜ 25%\n "},{"uri":"https://xtls.github.io/documents/level-1/routing-lv1-part1/","title":"路由 (routing) 功能简析（上）","tags":[],"description":"入门心得","content":"如果说Xray的【强大】主要体现在它极致的速度和广泛的兼容性。那么Xray的【灵活】，则主要应该归功于它巧妙的【路由】功能。本文就稍微说明一下这个功能的逻辑以及使用方式。\n1. 初识【路由】三兄弟 要理解路由，就要理解完整的路由功能需要有三兄弟来合力完成：1. 入站；2. 路由；3. 出站。\n三兄弟桃园结义，不求同年同月同日生，但求同年同月同日死。\n所以谨记：任何一个元素错误，就可能导致路由功能无法正常工作。\n因为路由的灵活性非常高，只看技术文档很容易把自己绕晕，所以本文我们用几个具体的示例来逐层讲解。\n罗嗦君： 路由功能实在过于灵活，所以本文的示例，都是为了讲解对应的概念，实际使用时请根据自己的需求进行调整。\n  2. 基本功： “兄弟一条心” 下图的示例，就是在客户端的 Xray 入站接收APP数据、在路由100%转发给出站，并从出站流向VPS。\n mermaid.initialize({startOnLoad:true}); graph LR; S(APP数据) .- I[入站] subgraph Xray I -- R[路由] -- O[出站] end O .- V(VPS) V:::greyclass S:::greyclass R:::routingclass classDef greyclass fill:#C0C0C0 classDef routingclass fill:#FFFFDE  下面我们来逐个分析：\n 2.1 入站\n入站： 就是流量如何流入 Xray\n 下面的入站配置示例，用大白话说就是：数据按照 socks 协议，通过 10808 端口，从本机 127.0.0.1 流入Xray。同时，Xray 将这个入站用 [tag] 命名为 inbound-10808。\n\u0026#34;inbounds\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;inbound-10808\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;socks\u0026#34;, \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 10808, \u0026#34;settings\u0026#34;: { \u0026#34;udp\u0026#34;: true } } ]  2.2 出站\n出站： 就是流量如何流出 Xray\n 下面的出站配置示例，用大白话说就是：数据按照 VLESS 协议，以 tcp + xtls (direct) 的方式、及其他相关设置，把流量发送给对应的VPS。同时，Xray 将这个出站用 [tag] 命名为 proxy-out-vless：\n\u0026#34;outbounds\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;proxy-out-vless\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;vless\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;a-name.yourdomain.com\u0026#34;, \u0026#34;port\u0026#34;: 443, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;uuiduuid-uuid-uuid-uuid-uuiduuiduuid\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;encryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;xtls\u0026#34;, \u0026#34;xtlsSettings\u0026#34;: { \u0026#34;serverName\u0026#34;: \u0026#34;a-name.yourdomain.com\u0026#34; } } } ]  2.3 路由\n路由： 就是把【入站】和【出站】之间的通道，用某种【条件】串联起来\n 下面的路由配置示例，用大白话说就是：把所有通过 [tag]=\u0026quot;inbound-10808\u0026quot; 入站流入 Xray 的流量，100% 全部流转导入 [tag]=\u0026quot;proxy-out-vless\u0026quot; 的出站，没有任何分流或其他操作。\n\u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;rules\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;inboundTag\u0026#34;: [ \u0026#34;inbound-10808\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;proxy-out-vless\u0026#34; } ] } 至此，我们最开始设计的极简规则【客户端的 Xray 入站接收APP数据、在路由100%转发给出站，并从出站流向VPS】已经完成。\n 2.4 路由配置项解析之一：流量筛选的依据\n注意观察路由配置，我们可以看到几个新名词：\n \u0026quot;domainStrategy\u0026quot;: \u0026quot;AsIs\u0026quot; “rules” \u0026quot;type\u0026quot;: \u0026quot;field\u0026quot; \u0026quot;inboundTag\u0026quot;: [\u0026quot;inbound-10808\u0026quot;] \u0026quot;outboundTag\u0026quot;: \u0026quot;proxy-out-vless\u0026quot;  其中 domainStrategy 我们暂且按下不表，先简单说明后面几个：\n   配置名称 配置值 配置说明     “rules”  它的内层就是【路由规则】的明细设置   \u0026quot;type\u0026quot; \u0026quot;field\u0026quot; 该项暂时没有特别定义，但是不能省略，所以记得写上就好   \u0026quot;inboundTag\u0026quot; [\u0026quot;inbound-10808\u0026quot;] 筛选流量的 【依据】 是【入站Tag】，具体 【条件】 现在只有一个：【入站来源是 inbound-10808】   \u0026quot;outboundTag\u0026quot; \u0026quot;proxy-out-vless\u0026quot; 当上面的筛选条件成立时（即入站[tag]=\u0026quot;inbound-10808\u0026quot;时 ），Xray 会将流量导入 [tag]=\u0026quot;proxy-out-vless\u0026quot; 的出站    本例中，我们只有一个入站，它的\u0026quot;inboundTag\u0026quot; = \u0026quot;inbound-10808\u0026quot; 。我们也只有一个出站，它的 [tag]=\u0026quot;proxy-out-vless\u0026quot;。所以根据上面这个路由规则，从唯一入站端口 10808 流入Xray的流量，100% 符合筛选条件、会被路由模块选中，然后转发给唯一的出站。\n至此，入站、路由、出站 三兄弟就已经可以携手工作了。当然，现在这个100%转发的工作并没有什么特别的意义。那么接下来，我们就看看这种分工合作的机制可以带来什么好处。\n 3. 小试牛刀： “三分天下” 之 “域名分流” [geosite.dat]  mermaid.initialize({startOnLoad:true}); graph LR; S(APP数据) .- I[入站] subgraph Xray I -- R[路由] -- \"geosite:category-ads-all\" -- O1[block] R[路由] -- \"geosite:cn\" -- O2[direct] R[路由] -- \"geosite:geolocation-!cn\" -- O3[proxy] end O2 .- D(国内服务器) O3 .- V(VPS) O1:::redclass V:::greyclass S:::greyclass R:::routingclass classDef redclass fill:#FF0000 classDef greyclass fill:#C0C0C0 classDef routingclass fill:#FFFFDE,stroke:#000000   这个配置逻辑，其实就是最简单、最常用的（《小小白白话文》中也在用的）路由配置三件套：\n 广告流量屏蔽 [block] 国内流量直连 [direct] 国外流量转发VPS [proxy]  注意： 小小白白话文中的直连配置是包括【国内域名】、【国内IP】、【本机内部IP】的。这里先讲解【国内域名】。\n  3.1 入站\n保持上例的 inbound-10808 不变。\n 3.2 出站\n在上例的基础上，我们已经有了 [proxy] 的出站 \u0026quot;proxy-out-vless\u0026quot;，所以它保持不变。显而易见，我们需要加入两个新的出站方式：[block] 和 [direct]，如下：\n\u0026#34;outbounds\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;proxy-out-vless\u0026#34;, ...... }, { \u0026#34;tag\u0026#34;: \u0026#34;block\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;blackhole\u0026#34; }, { \u0026#34;tag\u0026#34;: \u0026#34;direct-out\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34; } ] 上面的配置用大白话翻译如下：\n 上例中的 [proxy-out-vless] 出站配置保持不变 加入 blackhole 黑洞协议，通过这个协议出站的流量，其实都被发送到了 Xray 内部的黑洞里，再也无法逃脱，于是效果就是屏蔽 [block] 加入 freedom 自由协议，通过这个协议出站的流量，是自由的离开Xray去寻找原定的服务器，就像从没有来过，于是效果就是直连 [direct] （我这里起名叫做 [direct-out] 是为了强调它是一个出站）   3.3 路由\n接下来就是见证奇迹的时刻了，我们可以用【路由】的配置把这些连接起来！\n\u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;rules\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:category-ads-all\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;block\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:cn\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct-out\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:geolocation-!cn\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;proxy-out-vless\u0026#34; } ] } 为了理解这个配置文件，我们要稍微解释一下这里出现的几个新配置项：\n \u0026quot;domain\u0026quot;: [\u0026quot;geosite:category-ads-all\u0026quot;] \u0026quot;domain\u0026quot;: [\u0026quot;geosite:cn\u0026quot;] \u0026quot;domain\u0026quot;: [\u0026quot;geosite:geolocation-!cn\u0026quot;]   3.4 简析域名文件： geosite.dat\n其实，聪明的你大概可以通过这些配置项的名称猜出来个大概：\n \u0026quot;domain\u0026quot;：就是这次筛选流量的 【依据】 是 【域名】 （而不再是入站tag） \u0026quot;geosite\u0026quot;：就是 Xray 会去 geosite.dat 文件中寻找 【符合条件的域名】 \u0026quot;category-ads-all\u0026quot;：就是该文件中的 【所有广告类域名】 \u0026quot;cn\u0026quot;：就是该文件中的 【中国域名】 \u0026quot;geolocation-!cn\u0026quot;：就是该文件中的 【非中国域名】  结合这些说明，3.3 中的配置用大白话翻译就是：\n APP试图访问国外域名 \u0026quot;domain\u0026quot;: \u0026quot;geolocation-!cn\u0026quot; 的流量，通过 [proxy-out-vless] 出站，转发至VPS APP试图访问国外域名广告域名 \u0026quot;domain\u0026quot;: \u0026quot;geosite:category-ads-all\u0026quot; 的流量，通过 [block] 出站，转发至黑洞进行屏蔽 APP试图访问国内域名 \u0026quot;domain\u0026quot;: \u0026quot;geosite:cn\u0026quot; 的流量，通过 [direct-out] 出站，自由离开完成直连  这时，才让【路由功能】的好处稍微得到了一些展现。\n 3.5 所以 geosite.dat 到底是什么？不是有个 GFWList 吗？\n你想，这世界上的域名何止千万，如果我们每写一个基于【域名】匹配的路由规则，都要自己收集、手动输入域名，那效率将会何其低下！\n而如果所有的域名都只有一个种类，[direct], [proxy], [block] 只能三选其一，那又是多么的不方便！\n就如关羽需要他的青龙偃月刀，geosite.dat 文件便作为【路由功能】驱使的神兵利器横空出世了，它致力于为用户提供成熟完善的【域名分类表】。让用户可以简单的通过 geosite:xxx 这种格式方便的调用任何子类，定制符合自身需求的路由规则。\n这种模块化结构提供的灵活性，其实远超传统的一揽子防火墙域名列表 GFWList。为什么这么说呢？比如，你可以指定苹果的域名 geosite:apple 和icloud相关域名 geosite:icloud 通过代理 [proxy]，但是苹果的软件域名 geosite:apple-update 保持直连 [direct] 来保持最大下载速度。\n注意： 现在，geosite.dat 文件其实有多种选择：\n最初，从 Victoria Raymond 主力维护 Project V 项目时期，便提供了最初的配套项目：domain-list-community，用来收集、沉淀、分类各种常用的域名类型；\n之后，随着V姐突然消失导致 Project V 的原项目开发陷入停滞，v2fly 社区维护并持续更新了社区版本的 domain-list-community；\n同时，@Loyalsoldier 维护了其个人修改增强的路由规则文件 v2ray-rules-dat，提供了诸多不同的选择和分类逻辑；\n另外，Project X 也计划于未来定制维护更适合 Xray 使用的路由规则文件 Xray-rules-dat。(你们看，文件夹都建好了，所以快了快了)\n甚至，你还可以定制自己的 geosite 文件，外挂给 Xray 使用，但是这个就跑题了，本文不展开。\n如果你发现有些你遇到的域名没有被合理分类，请向上面的项目们提出 issue 甚至提交 Pull Request 吧！社区列表社区维护，人人为我我为人人！\n  3.6 军师锦囊藏奇兵：一条隐藏的路由规则\n事实上，当你认真思考上面的规则，不难发现一个问题，我们的所有规则都只规定了【当入站流量 符合某种条件时 应该被转发给哪个出站】，那么，如果 geosite.dat 文件不全面，我们的入站流量【不符合任何条件时】，Xray 会怎么处理呢？\n注意： 如果你认为【不符合条件当然就无法连接啦！】的话，你可要重新思考一下哦。因为只有指定了 [block] 规则，才会被导入到 blackhole 黑洞协议从而阻断连接\n 事实上，Xray 为了避免路由规则不完全导致的规则混乱，已经贴心的提供了一条隐藏的路由规则：【当入站流量不符合任何条件时，转发给第一个出站 】\n这样，就不会有任何流量被漏掉了。所以，你一定要把你最信赖的心腹大将放在【第一条出站】，让它为你守城护池。\n 3.7 再看“三分天下”的大地图\n因为我们在前面的示例中把 [proxy-out-vless] 放在了出站的第一位，所以隐藏规则生效时，流量会通过 VLESS 协议被转发至远端的VPS。因此，Xray 此时的完整工作逻辑如下：\nmermaid.initialize({startOnLoad:true}); graph LR; S(APP数据) .- I[入站] subgraph Xray I -- R[路由] -- \"geosite:category-ads-all\" -- O1[block] R[路由] -- \"geosite:cn\" -- O2[direct] R[路由] -- \"geosite:geolocation-!cn\" -- O3[proxy] R[路由] -. \"没有命中规则的流量\" .- O4[第一条出站] end O2 .- D(国内服务器) O3 .- V(VPS) O4 .- V(VPS) O1:::redclass V:::greyclass S:::greyclass R:::routingclass classDef redclass fill:#FF0000 classDef greyclass fill:#C0C0C0 classDef routingclass fill:#FFFFDE,stroke:#000000   事实上，这就是传统所谓的 【默认科学上网、国内网站白名单直连】 的配置。\n 4. “三分天下” 之 “蜀魏争雄” 现在，你已经知道了隐藏的默认路由规则：【当入站流量不符合任何条件时，转发给第一个出站 】。这时候，你应该能看出来，究竟是【科学上网】为王，还是【直连】称霸，全看你的第一条出站是什么！\n上一步我们已经配置出了 【默认科学上网、国内网站白名单直连】 的规则。那么现在只要 【把直连规则放在第一位】，就立即变成了正好相反的 【默认直连、国外网站白名单科学上网】 规则。\n是不是，非常的简单？\n\u0026#34;outbounds\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;direct-out\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34; }, { \u0026#34;tag\u0026#34;: \u0026#34;proxy-out-vless\u0026#34;, ...... }, { \u0026#34;tag\u0026#34;: \u0026#34;block\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;blackhole\u0026#34; } ] 此时，路由规则其实变成了：\nmermaid.initialize({startOnLoad:true}); graph LR; S(APP数据) .- I[入站] subgraph Xray I -- R[路由] -- \"geosite:category-ads-all\" -- O1[block] R[路由] -- \"geosite:geolocation-!cn\" -- O3[proxy] R[路由] -- \"geosite:cn\" -- O2[direct] R[路由] -. \"没有命中规则的流量\" .- O4[第一条出站] end O2 .- D(国内服务器) O3 .- V(VPS) O4 .- D O1:::redclass V:::greyclass S:::greyclass R:::routingclass classDef redclass fill:#FF0000 classDef greyclass fill:#C0C0C0 classDef routingclass fill:#FFFFDE,stroke:#000000  这就是路由功能的灵活之处了，你可以自由的改变它的顺序来实现不同的设计。\n至此，我们已经解释完了 【如何利用 geosite.dat 文件，通过路由规则，根据【域名】来分流网络流量】。\n 5. 攻城略池 - 多种路由匹配条件 请确保你已经读懂了上面的内容，因为这样，你就已经理解了【路由】功能的工作逻辑。有了这个基础，我们就可以继续分析【路由】功能更多更详细的配置方式和匹配条件了。\n等你看完后面的内容，就完全可以自由的定制属于自己的路由规则啦！还等什么，让我们一起进入 《路由 (routing) 功能简析（下）》 吧！\n"},{"uri":"https://xtls.github.io/config/base/api/","title":"API接口","tags":[],"description":"Project X 的文档.","content":"API接口配置提供了一些基于 gRPC的 API 接口供远程调用。\n可以通过api配置模块开启接口. 当api配置开启时，Xray 会自建一个出站代理， 须手动将所有的 API 入站连接通过 路由规则配置 指向这一出站代理。\n请参考本节中的相关配置\n大多数用户并不会用到此 API，新手可以直接忽略这一项。\n ApiObject  ApiObject 对应配置文件的 api 项。\n{ \u0026#34;api\u0026#34;: { \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34;, \u0026#34;services\u0026#34;: [ \u0026#34;HandlerService\u0026#34;, \u0026#34;LoggerService\u0026#34;, \u0026#34;StatsService\u0026#34; ] } }  tag: string\n 出站代理标识。\nservices: [string]\n 开启的 API 列表，可选的值见 API 列表。\n\n相关配置  可以在 inbounds 配置中增加一个 api 的 inbound\n\u0026#34;inbounds\u0026#34;: [ { \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 10085, \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34; }, \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; } ] 在路由配置中增加针对api inbound的路由规则\n\u0026#34;routing\u0026#34;: { \u0026#34;settings\u0026#34;: { \u0026#34;rules\u0026#34;: [ { \u0026#34;inboundTag\u0026#34;: [ \u0026#34;api\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;api\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; } ] }, \u0026#34;strategy\u0026#34;: \u0026#34;rules\u0026#34; } \n支持的 API 列表  HandlerService 一些对于入站出站代理进行修改的 API，可用的功能如下：\n 添加一个新的入站代理； 添加一个新的出站代理； 删除一个现有的入站代理； 删除一个现有的出站代理； 在一个入站代理中添加一个用户（仅支持 VMess、VLESS、Trojan、Shadowsocks（v1.3.0+））； 在一个入站代理中删除一个用户（仅支持 VMess、VLESS、Trojan、Shadowsocks（v1.3.0+））；  LoggerService 支持对内置 Logger 的重启，可配合 logrotate 进行一些对日志文件的操作。\nStatsService 内置的数据统计服务，详见 统计信息。\n"},{"uri":"https://xtls.github.io/config/outbound-protocols/dns/","title":"DNS","tags":[],"description":"Project X 的文档.","content":"DNS 是一个出站协议，主要用于拦截和转发 DNS 查询。\n此出站协议只能接收 DNS 流量（包含基于 UDP 和 TCP 协议的查询），其它类型的流量会导致错误。\n在处理 DNS 查询时，此出站协议会将 IP 查询（即 A 和 AAAA）转发给内置的 DNS 服务器。其它类型的查询流量将被转发至它们原本的目标地址。\nOutboundConfigurationObject  { \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;1.1.1.1\u0026#34;, \u0026#34;port\u0026#34;: 53 }  network: \u0026ldquo;tcp\u0026rdquo; | \u0026ldquo;udp\u0026rdquo;\n 修改 DNS 流量的传输层协议，可选的值有 \u0026quot;tcp\u0026quot; 和 \u0026quot;udp\u0026quot;。当不指定时，保持来源的传输方式不变。\naddress: address\n 修改 DNS 服务器地址。当不指定时，保持来源中指定的地址不变。\nport: number\n 修改 DNS 服务器端口。当不指定时，保持来源中指定的端口不变。\n\nDNS配置实例  In progress\n"},{"uri":"https://xtls.github.io/config/inbound-protocols/dokodemo/","title":"Dokodemo door","tags":[],"description":"Project X 的文档.","content":"Dokodemo door（任意门）可以监听一个本地端口，并把所有进入此端口的数据发送至指定服务器的一个端口，从而达到端口映射的效果。\nInboundConfigurationObject  { \u0026#34;address\u0026#34;: \u0026#34;8.8.8.8\u0026#34;, \u0026#34;port\u0026#34;: 53, \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;timeout\u0026#34;: 0, \u0026#34;followRedirect\u0026#34;: false, \u0026#34;userLevel\u0026#34;: 0 }  address: address\n 将流量转发到此地址。可以是一个 IP 地址，形如 \u0026quot;1.2.3.4\u0026quot;，或者一个域名，形如 \u0026quot;xray.com\u0026quot;。字符串类型。\n当 followRedirect（见下文）为 true 时，address 可为空。\nport: number\n 将流量转发到目标地址的指定端口，范围 [1, 65535]，数值类型。必填参数。\nnetwork: \u0026ldquo;tcp\u0026rdquo; | \u0026ldquo;udp\u0026rdquo; | \u0026ldquo;tcp,udp\u0026rdquo;\n 可接收的网络协议类型。比如当指定为 \u0026quot;tcp\u0026quot; 时，仅会接收 TCP 流量。默认值为 \u0026quot;tcp\u0026quot;。\ntimeout: number\n 连接空闲的时间限制。单位为秒。默认值为 300。处理一个连接时，如果在 timeout 时间内，没有任何数据被传输，则中断该连接。\nfollowRedirect: true | false\n 当值为 true 时，dokodemo-door 会识别出由 iptables 转发而来的数据，并转发到相应的目标地址。\n可参考 传输配置 中的 tproxy 设置。\nuserLevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n\n透明代理配置样例  此部分请参考透明代理（TProxy）配置教程。\n"},{"uri":"https://xtls.github.io/develop/protocols/vmess/","title":"VMess 协议","tags":[],"description":"Project X 的文档.","content":"VMess 是一个加密传输协议，可以作为 Xray 客户端和服务器之间的桥梁。\n\n版本  当前版本号为 1。\n\n依赖  底层协议  VMess 是一个基于 TCP 的协议，所有数据使用 TCP 传输。\n\n用户 ID  ID 等价于 UUID，是一个 16 字节长的随机数，它的作用相当于一个令牌（Token）。 一个 ID 形如：de305d54-75b4-431b-adb2-eb6b9e546014，几乎完全随机，可以使用任何的 UUID 生成器来生成，比如这个。\n用户 ID 可在配置文件中指定。\n\n函数   MD5: MD5 函数  输入参数为任意长度的 byte 数组 输出为一个 16 byte 的数组   HMAC: HMAC 函数  输入参数为：  H：散列函数 K：密钥，任意长度的 byte 数组 M：消息，任意长度的 byte 数组     Shake: SHA3-Shake128 函数  输入参数为任意长度的字符串 输出为任意长度的字符串    \n通讯过程  VMess 是一个无状态协议，即客户端和服务器之间不需要握手即可直接传输数据，每一次数据传输对之前和之后的其它数据传输没有影响。\nVMess 的客户端发起一次请求，服务器判断该请求是否来自一个合法的客户端。如验证通过，则转发该请求，并把获得的响应发回给客户端。\nVMess 使用非对称格式，即客户端发出的请求和服务器端的响应使用了不同的格式。\n\n客户端请求     16 字节 X 字节 余下部分     认证信息 指令部分 数据部分    \n认证信息  认证信息是一个 16 字节的哈希（hash）值，它的计算方式如下：\n H = MD5 K = 用户 ID (16 字节) M = UTC 时间，精确到秒，取值为当前时间的前后 30 秒随机值(8 字节, Big Endian) Hash = HMAC(H, K, M)  \n指令部分  指令部分经过 AES-128-CFB 加密：\n Key：MD5(用户 ID + []byte(\u0026lsquo;c48619fe-8f02-49e0-b9e9-edf763e17e21\u0026rsquo;)) IV：MD5(X + X + X + X)，X = []byte(认证信息生成的时间) (8 字节, Big Endian)     1 字节 16 字节 16 字节 1 字节 1 字节 4 位 4 位 1 字节 1 字节 2 字节 1 字节 N 字节 P 字节 4 字节     版本号 Ver 数据加密 IV 数据加密 Key 响应认证 V 选项 Opt 余量 P 加密方式 Sec 保留 指令 Cmd 端口 Port 地址类型 T 地址 A 随机值 校验 F    选项 Opt 细节：（当某一位为 1 时，表示该选项启用）\n   0 1 2 3 4 5 6 7     X X X X X M R S    其中：\n 版本号 Ver：始终为 1； 数据加密 IV：随机值； 数据加密 Key：随机值； 响应认证 V：随机值； 选项 Opt：  S (0x01)：标准格式的数据流（建议开启）； R (0x02)：客户端期待重用 TCP 连接（Xray 2.23+ 弃用）；  只有当 S 开启时，这一项才有效；   M (0x04)：开启元数据混淆（建议开启）；  只有当 S 开启时，这一项才有效； 当其项开启时，客户端和服务器端需要分别构造两个 Shake 实例，分别为 RequestMask = Shake(请求数据 IV), ResponseMask = Shake(响应数据 IV)。   X：保留   余量 P：在校验值之前加入 P 字节的随机值； 加密方式：指定数据部分的加密方式，可选的值有：  0x00：AES-128-CFB； 0x01：不加密； 0x02：AES-128-GCM； 0x03：ChaCha20-Poly1305；   指令 Cmd：  0x01：TCP 数据； 0x02：UDP 数据；   端口 Port：Big Endian 格式的整型端口号； 地址类型 T：  0x01：IPv4 0x02：域名 0x03：IPv6   地址 A：  当 T = 0x01 时，A 为 4 字节 IPv4 地址； 当 T = 0x02 时，A 为 1 字节长度（L） + L 字节域名； 当 T = 0x03 时，A 为 16 字节 IPv6 地址；   校验 F：指令部分除 F 外所有内容的 FNV1a hash；  \n数据部分  当 Opt(S) 开启时，数据部分使用此格式。实际的请求数据被分割为若干个小块，每个小块的格式如下。服务器校验完所有的小块之后，再按基本格式的方式进行转发。\n   2 字节 L 字节     长度 L 数据包    其中：\n 长度 L：Big Endian 格式的整型，最大值为 2^14；  当 Opt(M) 开启时，L 的值 = 真实值 xor Mask。Mask = (RequestMask.NextByte() \u0026laquo; 8) + RequestMask.NextByte()；   数据包：由指定的加密方式加密过的数据包；  在传输结束之前，数据包中必须有实际数据，即除了长度和认证数据之外的数据。当传输结束时，客户端必须发送一个空的数据包，即 L = 0（不加密） 或认证数据长度（有加密），来表示传输结束。\n按加密方式不同，数据包的格式如下：\n 不加密：  L 字节：实际数据；   AES-128-CFB：整个数据部分使用 AES-128-CFB 加密  4 字节：实际数据的 FNV1a hash； L - 4 字节：实际数据；   AES-128-GCM：Key 为指令部分的 Key，IV = count (2 字节) + IV (10 字节)。count 从 0 开始递增，每个数据包加 1；IV 为 指令部分 IV 的第 3 至第 12 字节。  L - 16 字节：实际数据； 16 字节：GCM 认证信息   ChaCha20-Poly1305：Key = MD5(指令部分 Key) + MD5(MD5(指令部分 Key))，IV = count (2 字节) + IV (10 字节)。count 从 0 开始递增，每个数据包加 1；IV 为 指令部分 IV 的第 3 至第 12 字节。  L - 16 字节：实际数据； 16 字节：Poly1305 认证信息    \n服务器应答  应答头部数据使用 AES-128-CFB 加密，IV 为 MD5(数据加密 IV)，Key 为 MD5(数据加密 Key)。实际应答数据视加密设置不同而不同。\n   1 字节 1 字节 1 字节 1 字节 M 字节 余下部分     响应认证 V 选项 Opt 指令 Cmd 指令长度 M 指令内容 实际应答数据    其中：\n 响应认证 V：必须和客户端请求中的响应认证 V 一致； 选项 Opt：  0x01：服务器端准备重用 TCP 连接（Xray 2.23+ 弃用）；   指令 Cmd：  0x01：动态端口指令   实际应答数据：  如果请求中的 Opt(S) 开启，则使用标准格式，否则使用基本格式。 格式均和请求数据相同。  当 Opt(M) 开启时，长度 L 的值 = 真实值 xor Mask。Mask = (ResponseMask.NextByte() \u0026laquo; 8) + ResponseMask.NextByte()；      \n动态端口指令     1 字节 2 字节 16 字节 2 字节 1 字节 1 字节     保留 端口 Port 用户 ID AlterID 用户等级 有效时间 T    其中：\n 端口 Port：Big Endian 格式的整型端口号； 有效时间 T：分钟数；  客户端在收到动态端口指令时，服务器已开放新的端口用于通信，这时客户端可以将数据发往新的端口。在 T 分钟之后，这个端口将失效，客户端必须重新使用主端口进行通信。\n\n注释   为确保向前兼容性，所有保留字段的值必须为 0。  "},{"uri":"https://xtls.github.io/config/transports/websocket/","title":"WebSocket","tags":[],"description":"Project X 的文档.","content":"使用标准的 WebSocket 来传输数据。\nWebSocket 连接可以被其它 HTTP 服务器（如 Nginx）分流，也可以被 VLESS fallbacks path 分流。\nTIP\nWebsocket 会识别 HTTP 请求的 X-Forwarded-For 头来覆写流量的源地址，优先级高于 PROXY protocol。\n WebSocketObject WebSocketObject 对应传输配置的 wsSettings 项。\n{ \u0026#34;acceptProxyProtocol\u0026#34;: false, \u0026#34;path\u0026#34;: \u0026#34;/\u0026#34;, \u0026#34;headers\u0026#34;: { \u0026#34;Host\u0026#34;: \u0026#34;xray.com\u0026#34; } }  acceptProxyProtocol: true | false\n 仅用于 inbound，指示是否接收 PROXY protocol。\nPROXY protocol 专用于传递请求的真实来源 IP 和端口，若你不了解它，请先忽略该项。\n常见的反代软件（如 HAProxy、Nginx）都可以配置发送它，VLESS fallbacks xver 也可以发送它。\n填写 true 时，最底层 TCP 连接建立后，请求方必须先发送 PROXY protocol v1 或 v2，否则连接会被关闭。\npath string\n WebSocket 所使用的 HTTP 协议路径，默认值为 \u0026quot;/\u0026quot;。\n如果路径中包含 ed 参数，将会启用 Early Data 以降低延迟，其值为首包长度阈值。如果首包长度超过此值，就不会启用 Early Data。建议的值为 2048。\nEarly Data 使用 Sec-WebSocket-Protocol 头承载数据。如果你遇到兼容性问题，可以尝试调低阈值。\n headers: map {string: string}\n 自定义 HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是字符串。\n默认值为空。\n"},{"uri":"https://xtls.github.io/documents/level-1/","title":"入门技巧","tags":[],"description":"Project X 的文档.","content":" 这个章节是入门级的Xray使用心得分享，主要分享一些Xray常用功能模块的原理说明。 回落 (fallbacks) 功能简析\n 路由 (routing) 功能简析（上）\n 路由 (routing) 功能简析（下）\n Xray的工作模式简析\n 通过 SNI 回落功能实现伪装与按域名分流\n "},{"uri":"https://xtls.github.io/develop/protocols/","title":"协议详解","tags":[],"description":"Project X 的文档.","content":" 这个章节包含了 Xray 中所使用协议的详细剖析 \n vless\n VLESS 是一个无状态的轻量传输协议，可以作为 Xray 客户端和服务器之间的桥梁。 VMess\n VMess 是一个加密传输协议，可以作为 Xray 客户端和服务器之间的桥梁。 Mux.Cool\n Mux.Cool 协议是一个多路复用传输协议，用于在一条已建立的数据流中传输多个各自独立的数据流。 mKCP\n mKCP 是流式传输协议，由 KCP 协议修改而来，可以按顺序传输任意的数据流。\n"},{"uri":"https://xtls.github.io/guide/","title":"快速入门","tags":[],"description":"Project X 的文档.","content":" 这个章节将告诉您如何用最简单的方式获得Xray,并且开始使用Xray. 下载安装 Xray支持各种平台,并且您可以从多种渠道和方式获得Xray的各种版本.\n请点击如何下载安装Xray以获取Xray\n 配置运行 下载并安装Xray后，只需对他进行配置即可使用.\n请点击如何配置运行Xray以学习最简单的配置方式.\n 命令参数 Xray有多种命令和参数可用,因此变得灵活和强大.\n请点击Xray的命令参数查看Xray的更多命令和参数用法.\n  \n使用文档 您正在查看的是 Project X 的文档网站. 您可以了解更多网站的使用方式, 或是帮助我们改进文档质量.\n请点击使用文档进一步查看相关内容\n    "},{"uri":"https://xtls.github.io/develop/intro/design/","title":"设计思路","tags":[],"description":"Project X 的文档.","content":"设计目标   Xray 内核提供了一个平台，支持必要的网络代理功能，在其之上可以进二次开发，以提供更好的用户体验； 以跨平台为首要原则，以减少二次开发的成本；  \n架构  内核分为三层：应用层、代理层和传输层。\n每一层内包含数个模块，模块间互相独立，同类型的模块可无缝替换。\n\n应用层  应用层包含一些代理层中常用的功能，这些功能被抽象出来，以便在不同的代理模块中复用。\n应用层的模块应为纯软件实现，与硬件或平台相关的技术无关。\n重要模块列表：\n Dispatcher: 用于把入站代理所接收到的数据，传送给出站代理； Router: 路由模块，详见 路由配置； DNS: 内置的 DNS 服务器模块； Proxy Manager: 代理管理器；  \n代理层  代理层分为两部分：入站代理（Inbound Proxy）和出站代理（Outbound Proxy）。\n两部分相互独立，入站代理不依赖于某个特定的出站代理，反之亦然。\n入站代理   实现 proxy.Inbound 接口；  出站代理   实现 proxy.Outbound 接口；  \n传输层  传输层提供一些网络数据传输相关的工具模块。\n"},{"uri":"https://xtls.github.io/documents/level-2/tproxy/","title":"透明代理（TProxy）配置教程","tags":[],"description":"Project X 的文档.","content":"本配置基于TProxy 透明代理的新 V2Ray 白话文教程，加入了 Xray 的新特性，使用 VLESS + XTLS Splice 方案，并将旧教程中默认出站代理的分流方式改为默认出站直连，使用者请按照实际情况进行修改。\n本文中所有配置已在 Raspberry Pi 2B、Ubuntu 20.04 环境下测试成功，如在其它环境中使用请自行调整配置。\n开始之前 请检查您的设备是否有可用的网络连接，且服务端已经配置成功，客户端已经安装完毕。\n需注意的是，目前很多透明代理教程都会将 Linux 系统的 IP 转发打开，但这样会导致 Splice 性能下降。详情请参考大案牍术破案纪实第三篇\u0026ndash;我们是如何破解 Splice 性能下降甚至低于 Direct 之谜的。\n这里我想要补充的是，很多透明代理教程会使用 Netfilter 进行分流，使直连流量直接发出而不经过 Xray，这时必须开启 IP 转发；也有的教程，如本文，会将所有流量导入 Xray 之中，由 Xray 的路由模块进行分流，这时无需开启 IP 转发。\nXray 配置 为了更好的分流体验，请替换默认路由规则文件为 Loyalsoldier/v2ray-rules-dat，否则 Xray-core 将无法加载本配置。\nsudo curl -oL /usr/local/share/xray/geoip.dat https://github.com/Loyalsoldier/v2ray-rules-dat/releases/latest/download/geoip.dat sudo curl -oL /usr/local/share/xray/geosite.dat https://github.com/Loyalsoldier/v2ray-rules-dat/releases/latest/download/geosite.dat { \u0026#34;log\u0026#34;: { \u0026#34;loglevel\u0026#34;: \u0026#34;warning\u0026#34;, \u0026#34;error\u0026#34;: \u0026#34;/var/log/xray/error.log\u0026#34;, \u0026#34;access\u0026#34;: \u0026#34;/var/log/xray/access.log\u0026#34; }, \u0026#34;inbounds\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;all-in\u0026#34;, \u0026#34;port\u0026#34;: 12345, \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;tcp,udp\u0026#34;, \u0026#34;followRedirect\u0026#34;: true }, \u0026#34;sniffing\u0026#34;: { \u0026#34;enabled\u0026#34;: true, \u0026#34;destOverride\u0026#34;: [ \u0026#34;http\u0026#34;, \u0026#34;tls\u0026#34; ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;sockopt\u0026#34;: { \u0026#34;tproxy\u0026#34;: \u0026#34;tproxy\u0026#34; } } } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;direct\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;UseIPv4\u0026#34; }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;sockopt\u0026#34;: { \u0026#34;mark\u0026#34;: 2 } } }, { \u0026#34;tag\u0026#34;: \u0026#34;proxy\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;vless\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;服务端域名\u0026#34;, \u0026#34;port\u0026#34;: 443, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;UUID\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-splice\u0026#34;, \u0026#34;encryption\u0026#34;: \u0026#34;none\u0026#34; } ] } ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;xtls\u0026#34;, \u0026#34;sockopt\u0026#34;: { \u0026#34;mark\u0026#34;: 2 } } }, { \u0026#34;tag\u0026#34;: \u0026#34;block\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;blackhole\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;response\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;http\u0026#34; } } }, { \u0026#34;tag\u0026#34;: \u0026#34;dns-out\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;dns\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;8.8.8.8\u0026#34; }, \u0026#34;proxySettings\u0026#34;: { \u0026#34;tag\u0026#34;: \u0026#34;proxy\u0026#34; }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;sockopt\u0026#34;: { \u0026#34;mark\u0026#34;: 2 } } } ], \u0026#34;dns\u0026#34;: { \u0026#34;hosts\u0026#34;: { \u0026#34;服务端域名\u0026#34;: \u0026#34;服务端 IP\u0026#34; }, \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;119.29.29.29\u0026#34;, \u0026#34;port\u0026#34;: 53, \u0026#34;domains\u0026#34;: [ \u0026#34;geosite:cn\u0026#34; ], \u0026#34;expectIPs\u0026#34;: [ \u0026#34;geoip:cn\u0026#34; ] }, { \u0026#34;address\u0026#34;: \u0026#34;223.5.5.5\u0026#34;, \u0026#34;port\u0026#34;: 53, \u0026#34;domains\u0026#34;: [ \u0026#34;geosite:cn\u0026#34; ], \u0026#34;expectIPs\u0026#34;: [ \u0026#34;geoip:cn\u0026#34; ] }, \u0026#34;8.8.8.8\u0026#34;, \u0026#34;1.1.1.1\u0026#34;, \u0026#34;https+local://doh.dns.sb/dns-query\u0026#34; ] }, \u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;IPIfNonMatch\u0026#34;, \u0026#34;rules\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;inboundTag\u0026#34;: [ \u0026#34;all-in\u0026#34; ], \u0026#34;port\u0026#34;: 53, \u0026#34;outboundTag\u0026#34;: \u0026#34;dns-out\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [ \u0026#34;8.8.8.8\u0026#34;, \u0026#34;1.1.1.1\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;proxy\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:category-ads-all\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;block\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:geolocation-!cn\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;proxy\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [ \u0026#34;geoip:telegram\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;proxy\u0026#34; } ] } }  TIP\n本配置会劫持所有发往 53 端口的流量以解决 DNS 污染问题，所以客户端和本机的 DNS 服务器的地址可以随意配置。\n 策略路由配置 sudo ip route add local default dev lo table 100 # 添加路由表 100 sudo ip rule add fwmark 1 table 100 # 为路由表 100 设定规则 Netfilter 配置 注意\nnftables 配置与 iptables 配置二选一，不可同时使用。\n nftables #!/usr/sbin/nft -f flush ruleset\ndefine RESERVED_IP = { 10.0.0.0/8, 100.64.0.0/10, 127.0.0.0/8, 169.254.0.0/16, 172.16.0.0/12, 192.0.0.0/24, 224.0.0.0/4, 240.0.0.0/4, 255.255.255.255/32 }\ntable ip xray { chain prerouting { type filter hook prerouting priority mangle; policy accept; ip daddr $RESERVED_IP return ip daddr 192.168.0.0/16 tcp dport != 53 return ip daddr 192.168.0.0/16 udp dport != 53 return ip protocol tcp tproxy to 127.0.0.1:12345 meta mark set 1 ip protocol udp tproxy to 127.0.0.1:12345 meta mark set 1 } chain output { type route hook output priority mangle; policy accept; ip daddr $RESERVED_IP return ip daddr 192.168.0.0/16 tcp dport != 53 return ip daddr 192.168.0.0/16 udp dport != 53 return meta mark 2 return ip protocol tcp meta mark set 1 ip protocol udp meta mark set 1 } } 使用方法\n将上述配置写入一个文件（如 nft.conf），之后将该文件赋予可执行权限，最后使用 root 权限执行该文件即可（# ./nft.conf）。\n iptables iptables -t mangle -N XRAY iptables -t mangle -A XRAY -d 10.0.0.0/8 -j RETURN iptables -t mangle -A XRAY -d 100.64.0.0/10 -j RETURN iptables -t mangle -A XRAY -d 127.0.0.0/8 -j RETURN iptables -t mangle -A XRAY -d 169.254.0.0/16 -j RETURN iptables -t mangle -A XRAY -d 172.16.0.0/12 -j RETURN iptables -t mangle -A XRAY -d 192.0.0.0/24 -j RETURN iptables -t mangle -A XRAY -d 224.0.0.0/4 -j RETURN iptables -t mangle -A XRAY -d 240.0.0.0/4 -j RETURN iptables -t mangle -A XRAY -d 255.255.255.255/32 -j RETURN iptables -t mangle -A XRAY -d 192.168.0.0/16 -p tcp ! --dport 53 -j RETURN iptables -t mangle -A XRAY -d 192.168.0.0/16 -p udp ! --dport 53 -j RETURN iptables -t mangle -A XRAY -p tcp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A XRAY -p udp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A PREROUTING -j XRAY iptables -t mangle -N XRAY_SELF iptables -t mangle -A XRAY_SELF -d 10.0.0.0/8 -j RETURN iptables -t mangle -A XRAY_SELF -d 100.64.0.0/10 -j RETURN iptables -t mangle -A XRAY_SELF -d 127.0.0.0/8 -j RETURN iptables -t mangle -A XRAY_SELF -d 169.254.0.0/16 -j RETURN iptables -t mangle -A XRAY_SELF -d 172.16.0.0/12 -j RETURN iptables -t mangle -A XRAY_SELF -d 192.0.0.0/24 -j RETURN iptables -t mangle -A XRAY_SELF -d 224.0.0.0/4 -j RETURN iptables -t mangle -A XRAY_SELF -d 240.0.0.0/4 -j RETURN iptables -t mangle -A XRAY_SELF -d 255.255.255.255/32 -j RETURN iptables -t mangle -A XRAY_SELF -d 192.168.0.0/16 -p tcp ! --dport 53 -j RETURN iptables -t mangle -A XRAY_SELF -d 192.168.0.0/16 -p udp ! --dport 53 -j RETURN iptables -t mangle -A XRAY_SELF -m mark --mark 2 -j RETURN iptables -t mangle -A XRAY_SELF -p tcp -j MARK --set-mark 1 iptables -t mangle -A XRAY_SELF -p udp -j MARK --set-mark 1 iptables -t mangle -A OUTPUT -j XRAY_SELF  配置完成后，将局域网内其它设备的默认网关改为该设备 IP，就可以直接翻墙了。在其它主机和本机皆测试成功后，可进行下一步配置。\n配置永久化与开机自启 nftables 首先将已经编辑好的 nftables 配置文件移动到 /etc 目录下，并重命名为 nftables.conf。然后编辑 /lib/systemd/system/nftables.service。\n[Unit] Description=nftables Documentation=man:nft(8) http://wiki.nftables.org Wants=network-pre.target Before=network-pre.target shutdown.target Conflicts=shutdown.target DefaultDependencies=no [Service] Type=oneshot RemainAfterExit=yes StandardInput=null ProtectSystem=full ProtectHome=true ExecStart=/usr/sbin/nft -f /etc/nftables.conf ; /usr/sbin/ip route add local default dev lo table 100 ; /usr/sbin/ip rule add fwmark 1 table 100 ExecReload=/usr/sbin/nft -f /etc/nftables.conf ExecStop=/usr/sbin/nft flush ruleset ; /usr/sbin/ip route del local default dev lo table 100 ; /usr/sbin/ip rule del table 100\n[Install] WantedBy=sysinit.target 最后 enable 即可。\niptables 关于 iptables 的永久化，建议直接安装 iptables-persistent。\n安装过程中会提示你选择“是否保存配置”，如果已经将 iptables 配置写入系统，那么此时选择“是”即可；如果尚未写入也没有关系，安装完毕后将配置写入，然后执行 netfilter-persistent save 即可（需要 root 权限）。\n之后编辑 /lib/systemd/system/netfilter-persistent.service。\n[Unit] Description=netfilter persistent configuration DefaultDependencies=no Wants=network-pre.target systemd-modules-load.service local-fs.target Before=network-pre.target shutdown.target After=systemd-modules-load.service local-fs.target Conflicts=shutdown.target Documentation=man:netfilter-persistent(8) [Service] Type=oneshot RemainAfterExit=yes ExecStart=/usr/sbin/netfilter-persistent start ; /usr/sbin/ip route add local default dev lo table 100 ; /usr/sbin/ip rule add fwmark 1 table 100 ExecStop=/usr/sbin/netfilter-persistent stop ; /usr/sbin/ip route del local default dev lo table 100 ; /usr/sbin/ip rule del table 100 [Install] WantedBy=multi-user.target  "},{"uri":"https://xtls.github.io/faq/config/","title":"配置和运行时的问题","tags":[],"description":"Project X 的文档.","content":" Q: 为什么windows下只有一个可执行程序? 我想要隐藏执行, 嘤嘤嘤.A1: 方式很多,如: 建立一个hiderun.vbs文件,放在xray.exe同一目录 编辑内容为\nCreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;xray.exe\u0026#34;,0 运行此vbs即可, 然后放个快捷方式到shell:startup里面，就可以开机启动了\n A2: 也可以通过创建window服务/计划任务等方式实现,亦可借助一些专门的后台运行的工具(不太必要)\n A3: CHP (Create Hidden Process)\n A4: 用winsw可以将xray-core添加为Win的系统服务，开机自动运行，不需要手动隐藏窗口。\n A5: 写一个bat开机启动\n@echo off if \u0026#34;%1\u0026#34; == \u0026#34;h\u0026#34; goto begin mshta vbscript:createobject(\u0026#34;wscript.shell\u0026#34;).run(\u0026#34;%~nx0 h\u0026#34;,0)(window.close)\u0026amp;\u0026amp;exit :begin D:/Xray run -c D:/Xray.json ` \n \nQ: 无法用做Tor前置代理 #66关闭 sniffing 再试试.\n \nQ: 如何自定义.dat文件的文件位置?设置环境变量 XRAY_LOCATION_ASSET 的值\n \nQ: 为什么我配置了SSL证书但不可用? 检查证书权限 使用 fullchain 证书   \nQ: 我以前用gfw列表, 我现在用Xray怎么进行分流呢?使用geo*.dat, 并且合理配置路由规则.\n \nQ: 我还是上一题的提问者, 那么我如何使用dat数据文件和配置路由规则达到国内走直连,其他走代理的目的呢?等待好心人写一篇小小白白话文\n \nQ: 如何配置才能在myssl或者ssllibs得到双A+的评价？首先，这不是必需的，即便没有双A+，甚至只有B，也并不意味着不安全。\n你现在可以这样做:\n 前提, 你的证书是ECC证书, 比如你用acme.sh可以这样获取  ./acme.sh --issue -d \u0026#34;your.domain\u0026#34; -w /var/www/html -k ec-256 --cert-file /etc/xray/\u0026#34;your.domain\u0026#34;/\u0026#34;your.domain\u0026#34;.cer --key-file /etc/xray/\u0026#34;your.domain\u0026#34;/\u0026#34;your.domain\u0026#34;.key --fullchain-file /etc/xray/\u0026#34;your.domain\u0026#34;/fullchain.cer --force \n只需简单的在 服务端的 TLS 配置 (streamsettings中的tlsSettings/xtlsSettings) 中加入  \u0026#34;minVersion\u0026#34;: \u0026#34;1.2\u0026#34; 即可在myssl或ssllabs上获得A\n\n然后在回落的网站服务器上开启HSTS,如 Nginx 只需配置  add_header Strict-Transport-Security \u0026#34;max-age=63072000\u0026#34; always; 即可在myssl或ssllabs上获得A+\n \nQ: 什么是UDP fullcone?fullcone的核心改变在于对游戏性能、使用到UDP的语音视频性能的优化。\n很多游戏会测试网络类型，类型过低甚至不能联机。fullcone一般都可以达到最佳类型。\n \nQ: 实现Full Cone NAT时,设置了iptables后降低了NAT等级怎么办?请参见这个issue里提出的方式\n \nQ: 打开证书的时候提示没有权限? 首先需要给证书文件以读取权限. 其次要给证书所在目录及上层目录x权限.   \nQ: log 里面有大量报 warning 的信息, 好可怕!连接异常断开是常有的现象, 如果能正常使用, 不必惊慌, 如果不能正常使用, 拿好你的配置文件和log, 去开一个issue.\n \n"},{"uri":"https://xtls.github.io/guide/config/","title":"配置运行","tags":[],"description":"Project X 的文档.","content":"下载并安装 了 Xray 之后，您需要对它进行一下配置。\n为了演示，这里只介绍简单的配置方式.\n如需配置更复杂的功能，请参考更详细的 配置文件 中相关说明。\n\n服务端配置  你需要一台防火墙外的服务器，来运行服务器端的 Xray。配置如下：\n{ \u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 10086, // 服务器监听端口 \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;b831381d-6324-4d53-ad4f-8cda48b30811\u0026#34; } ] } } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34; } ] } 服务器的配置中需要确保 id 和端口与客户端一致，就可以正常连接了。\n\n客户端配置  在你的 PC（或手机）中，需要用以下配置运行 Xray ：\n{ \u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 1080, // SOCKS 代理端口，在浏览器中需配置代理并指向这个端口 \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;socks\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;udp\u0026#34;: true } } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;server\u0026#34;, // 服务器地址，请修改为你自己的服务器 ip 或域名 \u0026#34;port\u0026#34;: 10086, // 服务器端口 \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;b831381d-6324-4d53-ad4f-8cda48b30811\u0026#34; } ] } ] } }, { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;direct\u0026#34; } ], \u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;IPOnDemand\u0026#34;, \u0026#34;rules\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [\u0026#34;geoip:private\u0026#34;], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct\u0026#34; } ] } } 上述配置唯一要更改的地方是你的服务器 IP，配置中已注明。上述配置会把除局域网（比如访问路由器）以外的所有流量转发至你的服务器。\n\n运行   在 Windows 和 macOS 中，配置文件通常是 Xray 同目录下的 config.json 文件。  直接运行 Xray 或 Xray.exe 即可。   在 Linux 中，配置文件通常位于 /etc/xray/ 或 /usr/local/etc/xray/ 目录下。  运行 xray run -c /etc/xray/config.json 或使用 systemd 等工具将 Xray 作为服务在后台运行。    更多详细的说明可以参考 配置文档 和 使用心得。\n"},{"uri":"https://xtls.github.io/documents/level-0/ch03-ssh/","title":"【第3章】远程登录篇","tags":[],"description":"小小白白话文","content":"3.1 远程登录VPS (PuTTY)  首先，鉴于零基础人群中Windows的用户基数最大，所以本文以Windows为例进行展示。\n其次，虽然Windows 10之后的PowerShell和WSL也可以达到很好的SSH操作体验。但是因为并非所有版本的Windows都有最新的组件，故本文还是以老牌的PuTTY为例，进行SSH远程登录的操作详解。（使用其他工具的话、在SSH登陆之后的操作都是一样的）\n下面就跟我一步步操作吧。\n  进入PuTTY的官网，选择适合你操作系统的版本下载。（本文以64位版本为例）\n  安装运行后，将会看到PuTTY的主界面。现在请拿出你上一章记东西的小本本，在下图的对应位置填入你VPS的IP地址(VPS IP)和端口(VPS PORT)。为了方便以后使用时不用重复输入，我们可以保存会话 (Saved Sessions)，未来使用时只要按Load即可一键载入设置。\n  我建议将 Connection 中的 keepalive 设置为 60 秒，防止你一段时间没有操作之后SSH自动断线。另外务必再次保存设置。\n注意： 对PuTTY的任何设置更新都要再次手动保存Session，不然关闭后就会丢失\n   点击 Open 就会进入SSH连接窗口，对应下图输入用户名与密码，与你的VPS远程主机建立连接。（本文假设默认用户名是 root，另外，在Linux系统输入密码的时候，是不会出现 ****** 这种提示符的，这样可以避免密码长度泄漏，不是你的键盘坏掉了哦！）\n   3.2 成功登录SSH！初识命令行界面！    如果你的信息都填写正确，你将会看到类似下图的界面，说明已登录成功：\n这个界面，就等于远程服务器的【桌面】，但它没有你熟悉的图标和鼠标，没有绚丽的色彩，有的只是简单文字，这就是【命令行界面】- Command Line Interface，或者缩写为 CLI。\n接下来的所有操作，都需要你像电影里的黑客一样，在这个命令行界面中完成。也许你会觉得陌生，但请相信我，使用命令行既不可怕，也不神秘。说到底，它只不过是把你习惯的鼠标操作变成了文字指令而已，你说一句，它做一句。\n  现在，你可以稍微观察并熟悉一下命令行环境，这个界面其实已经告诉了你一些有用的信息了，比如系统内核版本（比如图内是 4.19.37-5）、上次登录时间及IP等。当然根据VPS的不同，你看到的界面可能会略有不同。\n  请注意命令行最下面一行，闪动的光标左边，有一串字符。图中显示的是root@vps-server:~#，这一串要怎么理解呢？很简单：\n 现在的用户是 root root 所在的服务器是 vps-server root 现在所在的文件夹是 ~ # 之后是你可以输入命令的地方  前两个很直观，无需多说。第三个是关于Linux的文件夹系统，现在也不需要过于深入，你只需要知道，\u0026quot;~\u0026ldquo;就是【当前用户的大本营】。第四个，提示符#，你也不用管，只需要知道，未来文章中会写一些需要你输入的命令，都会以 \u0026ldquo;#\u0026rdquo; 或者 \u0026ldquo;$\u0026rdquo; 开头，提示你后面是你输入命令的地方。（所以你复制命令的时候，只需要复制后面的内容，不要复制提示符）\n   3.3 第一次更新Linux的软件！    正如你的手机，无论安卓还是iPhone，为了APP及时更新（获取安全补丁和新功能），都会时不时从应用商店获得更新信息，并且提示你有多少个APP可更新。Linux系统也有逻辑十分类似的更新机制。所以只要你会更新手机APP，就能学会更新Linux软件！\n  Linux下，每个APP都叫做一个“包” （package）。管理APP的程序自然就叫做“包管理器”（Package Manager）。你可以通过它安装、更新、卸载各种软件、甚至更新Linux系统本身。Linux下的包管理器非常强大，此处按下不表，现在你只需要知道Debian系统的包管理器叫做 apt 即可。接下来，我们就先使用 apt 做一次软件的全面更新，让你熟悉它的基本操作。\n  小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-01 apt update 查询软件更新   cmd-02 apt upgrade 执行软件更新      现在请输入第一条命令，获取更新信息\n# apt update   然后请输入第二条命令，并在询问是否继续安装 (Y/n) 时输入 y 并回车确认，开始安装\n# apt upgrade   完整流程演示如下：\n   3.4 你的进度  恭喜你又迈出了坚实的一步！ 现在，你已经可以通过SSH来登录你的远程服务器了！那登录进去之后，除了升级软件之外，应该再做点什么呢？敬请进入下一章一探究竟吧！\nPROGRESS⬛⬛⬛⬜⬜⬜⬜⬜ 37.5%\n "},{"uri":"https://xtls.github.io/documents/level-1/routing-lv1-part2/","title":"路由 (routing) 功能简析（下）","tags":[],"description":"入门心得","content":"欢迎继续学习 Xray 的【路由】功能！\n在 《路由 (routing) 功能简析（上）》 中，我们已经对【路由】功能的工作逻辑有了清晰的理解，也基于 geosite.dat 文件做了简单的域名分流配置。\n如前面所说，域名分流仅仅是【路由】功能的牛刀小试而已。下面就让我们来看看除了域名之外，还什么可以用做分流依据的东西吧！\n5. 攻城略池 - 多种路由匹配条件 [域名], [IP], [协议], etc.  基于域名的分流，已经可以让我们对网络流量进行基本合理的分流。为什么说【基本合理】呢？ 因为【三分天下】虽然是正确的战略方向，但如果只用【域名】来实现这个战略，其实漏洞百出，比如：\n 我读了《小小白白话文》后，给VPS新申请了一个 proxy.yourdomain.com 的域名, 我希望它无论如何都代理，geosite.dat 里面有吗？ 如果我还有个 direct.yourdomain.com 的域名，我希望它无论如何都直连， geosite.dat 里面有吗？ 本机 127.0.0.1 的内部流量，是否正确直连了？（比如 docker 等） 路由器、本地局域网 192.168.*.* 的流量，是否正确直连了？（比如路由器、群晖等） 我的国内DNS查询（如 223.5.5.5）是否正确直连了？ 我的国外DNS查询（如 1.1.1.1）是否正确代理了？ 其他类似国内公共DNS一样没有域名、只有IP地址的国内网站，是否正确直连了？ 其他类似国外公共DNS一样没有域名、只有IP地址的国外网站，是否正确代理了？ BT下载的流量，虽然来源是国外，但如果通过VPS下载很可能导致违规使用被封，这该如何强制直连？ \u0026hellip;\u0026hellip;  我之所以说只用【域名分流】会漏洞百出，是因为 geosite.dat 文件内只包含了一部分常用的域名。换言之，仅仅依赖它，则会：\n 无法匹配文件里没有的新域名 无法匹配基于IP地址的规则 无法匹配基于网络协议的规则  罗嗦君： 那我们来复习一下，当上面这些情况无法匹配时，会发生什么？对了，会触发隐藏路由规则，即【转发给第一个出站 】。这其实就是说：\n 当你的第一个出站是 [direct-out] 时：需要直连的都正确了，但需要代理的则都错误 当你的第一个出站是 [proxy-out-vless] 时：需要代理的都正确了，但需要直连的则都错误   所以，我们需要一个办法，让我们鱼与熊掌兼得。这样的办法是否存在呢？当然存在！ 我们需要的只是【域名】之外更多的【分流判断依据】而已。\n 5.1 基于指定域名分流：[domain], [full] 等\n 如果需要匹配某个子域名，如 a-name.yourdomain.com，我们使用 full: \u0026quot;a-name.yourdomain.com\u0026quot; 前面的 问题1 和 问题2，就可以通过给 proxy.yourdomain.com 指定 [proxy-out-vless] 出站，给 direct.yourdomain.com 指定 [direct-out] 出站来解决 如果需要匹配 yourdomain.com 的所有子域名，我们使用 domain: \u0026quot;yourdomain.com\u0026quot; 实现 上述两个可以成为两个独立的路由规则，达到某些子域名直连，其他子域名代理的配置 另外，[domain] 还支持正则表达式等匹配方式。详情请参考 《基础配置模块 - 路由》文档  上述配置如下：\n\u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;rules\u0026#34;: [ // 指定子域名直连 { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;full:direct.yourdomain.com\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct-out\u0026#34; }, // 指定子域名转发VPS { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;full:proxy.yourdomain.com\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;proxy-out-vless\u0026#34; }, // 指定泛域名转发VPS { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;yourdomain.com\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;proxy-out-vless\u0026#34; } ] }  5.2 基于IP文件分流：geoip.dat\n与 geosite.dat 规则文件十分类似的，我们还有 geoip.dat 这个规则文件，它致力于为用户提供成熟完善的【IP分类表】。让用户可以简单的通过 geoip:xxx 这种格式方便的调用任何子类，定制符合自身需求的路由规则 。\n 解决前面的 [问题3], [问题4]，我们使用 geoip:private 类别来指定 [direct-out] 解决前面的 [问题7]，我们使用 geoip:cn 类别来指定 [direct-out] 解决前面的 [问题8]，由于 geoip 中没有【非中国IP】这个分类（因为这等于要收集全世界的IP段），所以我们用隐藏规则代替，也就是将 [proxy-out-vless] 放在第一个出站  上述配置如下：\n\u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;rules\u0026#34;: [ // 本机内部地址、局域网地址直连 { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [ \u0026#34;geoip:private\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct-out\u0026#34; }, // 国内IP集直连 { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [ \u0026#34;geoip:cn\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct-out\u0026#34; } ] }  5.3 基于指定IP地址分流\n与 geosite.dat 规则文件十分类似的，我们还有 geoip.dat 这个规则文件，它是供【路由功能】驱使的第二个神兵利器，它致力于为用户提供成熟完善的【IP分类表】。让用户可以简单的通过 geoip:xxx 这种格式方便的调用任何子类，定制符合自身需求的路由规则 。\n 解决前面的 [问题5]，我们使用 ip: \u0026quot;223.5.5.5\u0026quot; 来指定 [direct-out] 解决前面的 [问题6]，我们使用 ip: \u0026quot;1.1.1.1\u0026quot; 来指定 [proxy-out-vless]  上述配置如下：\n\u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;rules\u0026#34;: [ // 指定IP地址直连 { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [ \u0026#34;223.5.5.5\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct-out\u0026#34; }, // 指定IP地址转发VPS { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [ \u0026#34;1.1.1.1\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;proxy-out-vless\u0026#34; } ] }  5.4 基于协议类型分流：[protocol] 等\n 解决前面的 [问题9]，我们使用 \u0026quot;protocol\u0026quot;: [\u0026quot;bittorrent\u0026quot;] 类别来指定 [direct-out]  \u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;rules\u0026#34;: [ // 指定 BT 协议直连 { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;protocol\u0026#34;: [ \u0026#34;bittorrent\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct-out\u0026#34; } ] }  5.5 基于更多条件的分流\n到目前位置，我们仍然只讲了【路由功能】分流能力的冰山一角！因为它还支持很多其他的判断条件！我在此简单罗列如下：\n本文已经讲过的：\n inboundTag domain ip protocol  本文尚未讲到的：\n port sourcePort network source user attrs  但这些内容实在是过多，全部展开就远远不是 level-1 的内容了，所以，需要这些复杂条件的朋友，请仔细阅读 《基础配置模块 - 路由》文档 自学哦！有问题就去 TG 群里面问问吧！\n 6. “霸业初定”：路由规则整体回顾 到现在为止，我们已经累积出了一套战略雄伟、战术精准的路由规则，为了避免混乱，现在就对它进行一次完整的整理和回顾。\n注意： 路由生效的顺序是：【从上往下，依次判断】，所以我一般推荐的规则顺序是：\n[1-block] --\u0026gt; [2-direct] --\u0026gt; [3-proxy] --\u0026gt; [4-first-outbound]\n \u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;rules\u0026#34;: [ // [1-block 广告流量屏蔽] // 1.1 广告域名集屏蔽 { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:category-ads-all\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;block\u0026#34; }, // [2-direct 国内流量直连] // 2.1 国内域名集、指定子域名直连 { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:cn\u0026#34;, \u0026#34;full:direct.yourdomain.com\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct-out\u0026#34; }, // 2.2 本机内部地址+局域网、国内IP、指定IP直连 { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [ \u0026#34;geoip:private\u0026#34;, \u0026#34;geoip:cn\u0026#34;, \u0026#34;223.5.5.5\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct-out\u0026#34; }, // 2.3 BT协议流量直连 { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;protocol\u0026#34;: [ \u0026#34;bittorrent\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct-out\u0026#34; }, // [3-proxy 国外流量转发VPS] // 3.1 国外域名集、指定子域名、指定泛域名转发VPS { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:geolocation-!cn\u0026#34;, \u0026#34;full:proxy.yourdomain.com\u0026#34;, \u0026#34;yourdomain.com\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;proxy-out-vless\u0026#34; }, // 3.2 指定IP转发VPS { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [ \u0026#34;1.1.1.1\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;proxy-out-vless\u0026#34; } // [4-default-routing 第一条出站] // 没有匹配到任何规则的流量，默认使用第一条出站处理 ] } 此时，路由规则其实变成了：\nmermaid.initialize({startOnLoad:true}); graph LR; S(APP数据) .- I[入站] subgraph Xray I -- R[路由] -- \"geosite:category-ads-all\" -- O1[block] R[路由] -- \"geosite:cn\" -- O2[direct] R[路由] -- \"direct.yourdomain.com\" -- O2[direct] R[路由] -- \"geoip:private\" -- O2[direct] R[路由] -- \"geoip:cn\" -- O2[direct] R[路由] -- \"ip:223.5.5.5\" -- O2[direct] R[路由] -- \"protocol:bittorrent\" -- O2[direct] R[路由] -- \"geosite:geolocation-!cn\" -- O3[proxy] R[路由] -- \"proxy.yourdomain.com\" -- O3[proxy] R[路由] -- \"*.yourdomain.com\" -- O3[proxy] R[路由] -- \"ip:1.1.1.1\" -- O3[proxy] R[路由] -. \"没有命中规则的流量\" .- O4[第一条出站] end O2 .- D(国内服务器) O3 .- V(VPS) O1:::redclass V:::greyclass S:::greyclass R:::routingclass classDef redclass fill:#FF0000 classDef greyclass fill:#C0C0C0 classDef routingclass fill:#FFFFDE,stroke:#000000  至于第一条出站是 [direct-out] 还是 [proxy-out-vless]，这就全看你的需求了。\n 7. 路由配置常见错误 请大家注意看，我上面每一条路由规则，都是一个独立的匹配依据，只有这样才能确保生效。而新人在自定义路由规则时常犯的一个错误就是：在一条规则内同时匹配了多种不同的匹配依据，造成匹配无效。\n比如，他希望实现的配置是：\n 自己的 direct.yourdomain.com 直连 国内DNS查询（如 223.5.5.5）直连   7.1 错误示范\n为了实现上面的目标，他写出了以下路由规则：\n\u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;rules\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [ \u0026#34;223.5.5.5\u0026#34; ], \u0026#34;domain\u0026#34;: [ \u0026#34;full:direct.yourdomain.com\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct-out\u0026#34; } ] } 你能看出这里面的错误吗？乍一看，似乎是对的？\n注意： 同一个规则之内，各个依据需要同时成立，才会匹配成功，逻辑关系是 AND，而不是 OR。\n 换言之，这条规则的意思是：【当你访问的  目标 = direct.yourdomain.com, 并且 同时还满足  目标 = 223.5.5.5 时，Xray 才会将流量转发给 [direct-out] 直连出站】\n很显然，一个目标不可能同时等于两个不同的值，所以这不但是一个永远不可能实现的无效规则，更与原本的目标风马牛不相及。\n 7.2 正确示范\n正确示范，自然就是将不同的匹配依据独立出来：\n\u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;rules\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [ \u0026#34;223.5.5.5\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct-out\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;full:direct.yourdomain.com\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct-out\u0026#34; } ] } 其实，第6点已经是我整理过的规则了，原则就是【相同的匹配依据可以合并，不同的匹配依据保持独立】。\n 8. 明修栈道、暗渡陈仓 [domain] 转化 [ip] 的密道：domainStrategy 我们在 5.4 中提交了多种流量判断的【依据】，其中一种是域名 [domain]、一种是 [IP]。\n如果你初步了解过DNS的运作过程，就会知道，我们对一个域名 [domain] 发起访问请求时，其实需要先向 DNS 发起请求来解析域名 [domain] 对应的 [IP]，在得到 [IP] 后再向它发起实际请求。\n所以，面对入站的一次域名请求，Xray 其实有两次机会去判断它的类型。那么，究竟是否要用这两次机会呢？这就是由 domainStrategy 这个配置来决定的。它有三个选项：\n AsIs IPIfNonMatch IPOnDemand  按么我们逐个来解释一下：\n 8.1 域名策略: \u0026quot;AsIs\u0026quot;\n就是 \u0026ldquo;As Domain Is\u0026rdquo;，也就是说 【域名什么样，就什么样，不多折腾】。\n简单粗暴理解就是说【仅用 [domain] 来匹配】。\n这个方式的处理都在 Xray 内部完成，没有与外界的数据往来，所以速度最快。它的兜底策略也很清晰：即前面所说的、无法匹配的域名自动转入第一条出站处理。所以，对于常规使用路由功能这最推荐的策略。\n 8.2 域名策略: \u0026quot;IPIfNonMatch\u0026quot;\n就是 \u0026ldquo;lookup IP if (there\u0026rsquo;s) no matching rule\u0026rdquo;，也就是说【如果其他所有规则都匹配不上，那就转化成 IP 去匹配 IP 规则】。\n简单粗暴理解就是说【先把访问目标和其他所有类型规则匹配，如果匹配不上，那就通过 DNS 查询转化成 IP，再从头和所有规则匹配一次】。\n该策略下没有命中任何规则的这一部分域名，会需要再经历 DNS 查询过程、以及第二轮规则匹配的过程，其耗时会多于 AsIs 策略，所以并不是首选推荐的策略。\n 8.3 域名策略: \u0026quot;IPOnDemand\u0026quot;\n这里其实说 Demand IP 更准确些，也就是说【当匹配时碰到任何基于 IP 的规则，将域名立即解析为 IP 进行匹配】。\n简单粗暴理解就是说【只要路由规则中有 IP 类规则，那么所有基于域名 [domain] 的请求都要解析成 [IP] 然后去匹配 [IP] 类规则】。\n它要对所有首次域名访问进行 DNS 解析，所以首次查询比较耗时。虽然由于 Xray 中 DNS 缓存机制的存在，后续对相同域名的访问速度会重回巅峰，但总体来说也不是首选推荐的策略。\n啰嗦君： domainStrategy 仅对域名生效，不要搞混了哦~\n  9. 思考题 迄今为止，我们都是在【单入站】和【单出站】的基础上，讲解【路由】内部的各种配置逻辑。\n但是，如你所知，Xray 本身是支持多端口，多协议的。那么，如果我问你：\n 我希望 VLESS 协议将我日常的网页浏览和APP流量转发给美国的大流量服务器 我希望 trojan 协议将我的所有Netflix流量转发给日本的服务器解锁各种二次元 我希望 shadowsocks 协议将我所有的游戏流量转发给香港的服务器达到最低的延迟 我希望有一个独立的端口，能够把 telegram 的流量全都转发给VPS 我希望有一个独立的端口，能够把 bittorrent 下载流量全都转发给欧洲大盘鸡 我希望\u0026hellip;\u0026hellip;  这些想法，是否能通过【路由】功能配置实现呢？\n答案当然是 【完全可以】 啦！ 但是这些对于 level-1 来说已经超纲了，就留给各位自由的探索吧！\n 10. 结语 至此，Xray 的【路由】功能就介绍完了。希望本文能够对你理解 Xray 的灵活有所帮助。\n"},{"uri":"https://xtls.github.io/config/transports/domainsocket/","title":"Domain Socket","tags":[],"description":"Project X 的文档.","content":" important推荐写到 inbounds 的 listen 处，传输方式可选 TCP、WebSocket、HTTP/2.\n未来这里的 DomainSocket 可能会被弃用。\n Domain Socket 使用标准的 Unix domain socket 来传输数据。\n它的优势是使用了操作系统内建的传输通道，而不会占用网络缓存。 理论上相比起本地环回网络（local loopback）来说，Domain socket 速度略快一些。\n目前仅可用于支持 Unix domain socket 的平台，如 Linux 和 macOS。在 Windows 10 Build 17036 前不可用。\n如果指定了 domain socket 作为传输方式，在入站出站代理中配置的端口和 IP 地址将会失效，所有的传输由 domain socket 取代。\nDomainSocketObject  DomainSocketObject 对应传输配置的 dsSettings 项。\n{ \u0026#34;path\u0026#34;: \u0026#34;/path/to/ds/file\u0026#34;, \u0026#34;abstract\u0026#34;: false, \u0026#34;padding\u0026#34;: false }  path: string\n 一个合法的文件路径。 important在运行 Xray 之前，这个文件必须不存在。\n abstract: true | false\n 是否为 abstract domain socket，默认值 false。\n padding: true | false\n abstract domain socket 是否带 padding，默认值 false。\n"},{"uri":"https://xtls.github.io/config/outbound-protocols/freedom/","title":"Freedom","tags":[],"description":"Project X 的文档.","content":"Freedom 是一个出站协议，可以用来向任意网络发送（正常的） TCP 或 UDP 数据。\nOutboundConfigurationObject  { \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;redirect\u0026#34;: \u0026#34;127.0.0.1:3366\u0026#34;, \u0026#34;userLevel\u0026#34;: 0 }  domainStrategy: \u0026ldquo;AsIs\u0026rdquo; | \u0026ldquo;UseIP\u0026rdquo; | \u0026ldquo;UseIPv4\u0026rdquo; | \u0026ldquo;UseIPv6\u0026rdquo;\n 在目标地址为域名时, 配置相应的值, Freedom 的行为模式如下:\n \u0026quot;AsIs\u0026quot;: Freedom 通过系统DNS服务器解析获取IP, 向此域名发出连接. \u0026quot;UseIP\u0026quot;、\u0026quot;UseIPv4\u0026quot; 和 \u0026quot;UseIPv6\u0026quot;: Xray 使用内置 DNS 服务器解析获取IP, 向此域名发出连接. 默认值为 \u0026quot;AsIs\u0026quot;。   TIP 1\n当使用 \u0026quot;UseIP\u0026quot; 模式，并且出站连接配置 中指定了 sendThrough 时，Freedom 会根据 sendThrough 的值自动判断所需的 IP 类型，IPv4 或 IPv6。\n TIP 2\n当使用 \u0026quot;UseIPv4\u0026quot; 或 \u0026quot;UseIPv6\u0026quot; 模式时，Freedom 会只使用对应的 IPv4 或 IPv6 地址。当 sendThrough 指定了不匹配的本地地址时，将导致连接失败。\n redirect: address_port\n Freedom 会强制将所有数据发送到指定地址（而不是 inbound 指定的地址）。\n其值为一个字符串，样例：\u0026quot;127.0.0.1:80\u0026quot;，\u0026quot;:1234\u0026quot;。\n当地址不指定时，如 \u0026quot;:443\u0026quot;，Freedom 不会修改原先的目标地址。 当端口为 0 时，如 \u0026quot;xray.com: 0\u0026quot;，Freedom 不会修改原先的端口。\nuserLevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n"},{"uri":"https://xtls.github.io/config/inbound-protocols/http/","title":"HTTP","tags":[],"description":"Project X 的文档.","content":"HTTP 协议。\nimportanthttp 协议没有对传输加密，不适宜经公网中传输，更容易成为被人用作攻击的肉鸡。\nhttp inbound 更有意义的用法是在局域网或本机环境下监听，为其他程序提供本地服务。\n TIP 1\nhttp proxy 只能代理 tcp 协议，udp 系的协议均不能通过。\n TIP 2\n在 Linux 中使用以下环境变量即可在当前 session 使用全局 HTTP 代理（很多软件都支持这一设置，也有不支持的）。\n export http_proxy=http://127.0.0.1:8080/ (地址须改成你配置的 HTTP 入站代理地址) export https_proxy=$http_proxy   InboundConfigurationObject  { \u0026#34;timeout\u0026#34;: 0, \u0026#34;accounts\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; } ], \u0026#34;allowTransparent\u0026#34;: false, \u0026#34;userLevel\u0026#34;: 0 }  timeout: number\n 连接空闲的时间限制。单位为秒。默认值为 300, 0 表示不限时。\n处理一个连接时，如果在 timeout 时间内，没有任何数据被传输，则中断该连接。\naccounts: [AccountObject]\n 一个数组，数组中每个元素为一个用户帐号。默认值为空。\n当 accounts 非空时，HTTP 代理将对入站连接进行 Basic Authentication 验证。\nallowTransparent: true | false\n 当为 true 时，会转发所有 HTTP 请求，而非只是代理请求。\nTIP\n若配置不当，开启此选项会导致死循环。\n userLevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n\nAccountObject  { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; }  user: string\n 用户名，字符串类型。必填。\npass: string\n 密码，字符串类型。必填。\n"},{"uri":"https://xtls.github.io/develop/protocols/muxcool/","title":"Mux.Cool 协议","tags":[],"description":"Project X 的文档.","content":"Mux.Cool 协议是一个多路复用传输协议，用于在一条已建立的数据流中传输多个各自独立的数据流。\n\n版本  当前版本是 1 Beta。\n\n依赖  底层协议  Mux.Cool 必须运行在一个已建立的可靠数据流之上。\n\n通讯过程  一个 Mux.Cool 连接中可传输若干个子连接，每个子连接有一个独立的 ID 和状态。传输过程由帧（Frame）组成，每一帧用于传输一个特定的子连接的数据。\n\n客户端行为  当有连接需求时并且没有现有可用的连接时，客户端向服务器发起一个新连接，以下称为“主连接”。\n 一个主连接可用于发送若干个子连接。客户端可自主决定主连接可承载的子连接数量。 对于一个新的子连接，客户端必须发送状态New以通知服务器建立子连接，然后使用状态Keep来传送数据。 当子连接结束时，客户端发送End状态来通知服务器关闭子连接。 客户端可自行决定何时关闭主连接，但必须确定服务器也同时保持连接。 客户端可使用 KeepAlive 状态来避免服务器关闭主连接。  \n服务器端行为  当服务器端接收到新的子连接时，服务器应当按正常的连接来处理。\n 当收到状态End时，服务器端可以关闭对目标地址的上行连接。 在服务器的响应中，必须使用与请求相同的 ID 来传输子连接的数据。 服务器不能使用New状态。 服务器可使用 KeepAlive 状态来避免客户端关闭主连接。  \n传输格式  Mux.Cool 使用对称传输格式，即客户端和服务器发送和接收相同格式的数据。\n\n帧格式     2 字节 L 字节 X 字节     元数据长度 L 元数据 额外数据    \n元数据  元数据有若干种类型，由状态 S 来区分。所有类型的元数据都包含 ID 和 Opt 两项，其含义为：\n ID: 子连接的唯一标识 Opt:  D(0x01): 有额外数据    当选项 Opt(D) 开启时，额外数据格式如下：\n   2 字节 L 字节     长度 L 数据    \n新建子连接 (New)     2 字节 1 字节 1 字节 1 字节 2 字节 1 字节 X 字节     ID 0x01 选项 Opt 网络类型 N 端口 地址类型 T 地址 A    其中：\n 网络类型 N：  0x01：TCP，表示当前子连接的流量应当以 TCP 的方式发送至目标。 0x02：UDP，表示当前子连接的流量应当以 UDP 的方式发送至目标。   地址类型 T：  0x01：IPv4 0x02：域名 0x03：IPv6   地址 A：  当 T = 0x01 时，A 为 4 字节 IPv4 地址； 当 T = 0x02 时，A 为 1 字节长度（L） + L 字节域名； 当 T = 0x03 时，A 为 16 字节 IPv6 地址；    在新建子连接时，若 Opt(D) 开启，则这一帧所带的数据需要被发往目标主机。\n\n保持子连接 (Keep)     2 字节 1 字节 1 字节     ID 0x02 选项 Opt    在保持子连接时，若 Opt(D) 开启，则这一帧所带的数据需要被发往目标主机。\n\n关闭子连接 (End)     2 字节 1 字节 1 字节     ID 0x03 选项 Opt    在保持子连接时，若 Opt(D) 开启，则这一帧所带的数据需要被发往目标主机。\n\n保持连接 (KeepAlive)     2 字节 1 字节 1 字节     ID 0x04 选项 Opt    在保持连接时:\n 若 Opt(D) 开启，则这一帧所带的数据必须被丢弃。 ID 可为随机值。  \n应用  Mux.Cool 协议与底层协议无关，理论上可以使用任何可靠的流式连接来传输 Mux.Cool 的协议数据。\n在目标导向的协议如 Shadowsocks 和 VMess 协议中，连接建立时必须包含一个指定的地址。\n为了保持兼容性，Mux.Cool 协议指定地址为“v1.mux.cool”。即当主连接的目标地址与之匹配时，则进行 Mux.Cool 方式的转发，否则按传统方式进行转发。\n"},{"uri":"https://xtls.github.io/config/base/dns/","title":"内置DNS服务器","tags":[],"description":"Project X 的文档.","content":"DNS 服务器  如果为 Xray 配置了 DNS 服务器模块，主要有两大用途：\n  在路由阶段, 解析域名为 IP, 并且根据域名解析得到的 IP 进行规则匹配以分流. 是否解析域名及分流和路由配置模块中\u0026quot;domainStrategy\u0026quot;的值有关, 只有在设置以下两种值时,才会使用内置 DNS 服务器进行 DNS 查询:\n \u0026ldquo;IPIfNonMatch\u0026rdquo;, 请求一个域名时，进行路由里面的 domain 进行匹配，若无法匹配到结果，则对这个域名使用内置 DNS 服务器进行 DNS 查询，并且使用查询返回的 IP 地址再重新进行 IP 路由匹配。 \u0026ldquo;IPOnDemand\u0026rdquo;, 当匹配时碰到任何基于 IP 的规则，将域名立即解析为 IP 进行匹配。    解析目标地址进行连接。\n 如 在 freedom 协议的 outbound 中，将domainStrategy 设置为 UseIP, 由此 outbound 发出的请求, 会先将域名通过内置服务器解析成 IP, 然后进行连接    TIP 1\n内置 DNS 服务器所发出的 DNS 查询请求，会自动根据路由配置进行转发。\n TIP 2\n只支持最基本的 IP 查询（A 和 AAAA 记录）。\n \nDNS 处理流程  DNS 服务器配置模块可以配置多个DNS服务器, 并且指定优先匹配列表.\n 查询的域名与某个 DNS 服务器指定的域名列表匹配时，Xray 会优先使用这个 DNS 服务器进行查询 无匹配时, 按从上往下的顺序进行查询 只返回匹配 expectIPs 的 IP 列表。  DNS 服务器的处理流程示意图如下：\n\nDnsObject  DnsObject 对应配置文件的 dns 项。\n{ \u0026#34;dns\u0026#34;: { \u0026#34;hosts\u0026#34;: { \u0026#34;baidu.com\u0026#34;: \u0026#34;127.0.0.1\u0026#34; }, \u0026#34;servers\u0026#34;: [ \u0026#34;8.8.8.8\u0026#34;, \u0026#34;8.8.4.4\u0026#34;, { \u0026#34;address\u0026#34;: \u0026#34;1.2.3.4\u0026#34;, \u0026#34;port\u0026#34;: 5353, \u0026#34;domains\u0026#34;: [\u0026#34;domain:xray.com\u0026#34;], \u0026#34;expectIPs\u0026#34;: [\u0026#34;geoip:cn\u0026#34;] }, \u0026#34;localhost\u0026#34; ], \u0026#34;clientIp\u0026#34;: \u0026#34;1.2.3.4\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;dns_inbound\u0026#34; } }  hosts: map{string: address}\n 静态 IP 列表，其值为一系列的 \u0026ldquo;域名\u0026rdquo;: \u0026ldquo;地址\u0026rdquo;。其中地址可以是 IP 或者域名。在解析域名时，如果域名匹配这个列表中的某一项:\n 当该项的地址为 IP 时，则解析结果为该项的 IP 当该项的地址为域名时，会使用此域名进行 IP 解析，而不使用原始域名。  域名的格式有以下几种形式：\n 纯字符串：当此字符串完整匹配目标域名时，该规则生效。例如 \u0026ldquo;xray.com\u0026rdquo; 匹配\u0026quot;xray.com\u0026quot; 但不匹配\u0026quot;www.xray.com\u0026quot;。 正则表达式：由 \u0026quot;regexp:\u0026quot; 开始，余下部分是一个正则表达式。当此正则表达式匹配目标域名时，该规则生效。例如 \u0026ldquo;regexp:\\\\.goo.*\\\\.com$\u0026rdquo; 匹配\u0026quot;www.google.com\u0026quot;或 \u0026ldquo;fonts.googleapis.com\u0026rdquo;，但不匹配 \u0026ldquo;google.com\u0026rdquo;。 子域名 (推荐)：由 \u0026quot;domain:\u0026quot; 开始，余下部分是一个域名。当此域名是目标域名或其子域名时，该规则生效。例如 “domain:xray.com” 匹配\u0026quot;www.xray.com\u0026quot;、“xray.com”，但不匹配 “wxray.com”。 子串：由 \u0026quot;keyword:\u0026quot; 开始，余下部分是一个字符串。当此字符串匹配目标域名中任意部分，该规则生效。比如 \u0026ldquo;keyword:sina.com\u0026rdquo; 可以匹配\u0026quot;sina.com\u0026quot;、\u0026ldquo;sina.com.cn\u0026rdquo; 和\u0026quot;www.sina.com\u0026quot;，但不匹配 \u0026ldquo;sina.cn\u0026rdquo;。 预定义域名列表：由 \u0026quot;geosite:\u0026quot; 开头，余下部分是一个名称，如 geosite:google 或者 geosite:cn。名称及域名列表参考 预定义域名列表。  servers: [string | ServerObject ]\n 一个 DNS 服务器列表，支持的类型有两种：DNS 地址（字符串形式）和 ServerObject 。\n当它的值是一个 DNS IP 地址时，如 \u0026quot;8.8.8.8\u0026quot;，Xray 会使用此地址的 53 端口进行 DNS 查询。\n当值为 \u0026quot;localhost\u0026quot; 时，表示使用本机预设的 DNS 配置。\n当值是 \u0026quot;https://host:port/dns-query\u0026quot; 的形式，如 \u0026quot;https://dns.google/dns-query\u0026quot;，Xray 会使用 DNS over HTTPS (RFC8484, 简称 DOH) 进行查询。有些服务商拥有 IP 别名的证书，可以直接写 IP 形式，比如 https://1.1.1.1/dns-query。也可使用非标准端口和路径，如 \u0026quot;https://a.b.c.d:8443/my-dns-query\u0026quot;\n当值是 \u0026quot;https+local://host:port/dns-query\u0026quot; 的形式，如 \u0026quot;https+local://dns.google/dns-query\u0026quot;，Xray 会使用 DOH本地模式 进行查询，即 DOH 请求不会经过 Routing/Outbound 等组件，直接对外请求，以降低耗时。一般适合在服务端使用。也可使用非标端口和路径。\n当值是 fakedns 时，将使用 FakeDNS 功能进行查询。\nTIP 1\n当使用 localhost 时，本机的 DNS 请求不受 Xray 控制，需要额外的配置才可以使 DNS 请求由 Xray 转发。\n TIP 2\n不同规则初始化得到的 DNS 客户端会在 Xray 启动日志中以 info 级别体现，比如 local DOH、remote DOH 和 udp 等模式。\n clientIp: string\n 用于 DNS 查询时通知服务器以指定IP位置。不能是私有地址。\ntag: string\n 由内置 DNS 发出的查询流量，除 localhost 和 DOHL_ 模式外，都可以用此标识在路由使用 inboundTag 进行匹配。\n\nServerObject  { \u0026#34;address\u0026#34;: \u0026#34;1.2.3.4\u0026#34;, \u0026#34;port\u0026#34;: 5353, \u0026#34;domains\u0026#34;: [ \u0026#34;domain:xray.com\u0026#34; ], \u0026#34;expectIPs\u0026#34;: [ \u0026#34;geoip:cn\u0026#34; ] }  address: address\n 一个 DNS 服务器列表，支持的类型有两种：DNS 地址（字符串形式）和 ServerObject 。\n当它的值是一个 DNS IP 地址时，如 \u0026ldquo;8.8.8.8\u0026rdquo;，Xray 会使用此地址的 53 端口进行 DNS 查询。\n当值为 \u0026ldquo;localhost\u0026rdquo; 时，表示使用本机预设的 DNS 配置。\n当值是 \u0026ldquo;https://host:port/dns-query\u0026rdquo; 的形式，如 \u0026ldquo;https://dns.google/dns-query\u0026quot;，Xray 会使用 DNS over HTTPS (RFC8484, 简称 DOH) 进行查询。有些服务商拥有 IP 别名的证书，可以直接写 IP 形式，比如 https://1.1.1.1/dns-query。也可使用非标准端口和路径，如 \u0026ldquo;https://a.b.c.d:8443/my-dns-query\u0026quot;\n当值是 \u0026ldquo;https+local://host:port/dns-query\u0026rdquo; 的形式，如 \u0026ldquo;https+local://dns.google/dns-query\u0026rdquo;，Xray 会使用 DOH本地模式 进行查询，即 DOH 请求不会经过 Routing/Outbound 等组件，直接对外请求，以降低耗时。一般适合在服务端使用。也可使用非标端口和路径。\n当值是 fakedns 时，将使用 FakeDNS 功能进行查询。\nport: number\n DNS 服务器端口，如 53。此项缺省时默认为 53。当使用 DOH 模式该项无效，非标端口应在 URL 中指定。\ndomains: [string]\n 一个域名列表，此列表包含的域名，将优先使用此服务器进行查询。域名格式和 路由配置 中相同。\nexpectIPs:[string]\n 一个 IP 范围列表，格式和 路由配置 中相同。\n当配置此项时，Xray DNS 会对返回的 IP 的进行校验，只返回包含 expectIPs 列表中的地址。\n如果未配置此项，会原样返回 IP 地址。\n"},{"uri":"https://xtls.github.io/guide/command/","title":"命令参数","tags":[],"description":"Project X 的文档.","content":" TIP\nXray 使用 go 风格的命令及参数\n 获取基本命令  您可以运行 xray help 来获得所有 xray 最基础的用法, 以及可用的命令及说明.\nXray is a platform for building proxies. Usage: xray \u0026lt;command\u0026gt; [arguments] The commands are: run Run Xray with config, the default command version Show current version of Xray api Call an API in an Xray process tls TLS tools uuid Generate new UUIDs Use \u0026#34;xray help \u0026lt;command\u0026gt;\u0026#34; for more information about a command. \nxray run  使用方法:\nxray run [-c config.json] [-confdir dir] Run Xray with config, the default command.\nThe -config=file, -c=file flags set the config files for Xray. Multiple assign is accepted.\nThe -confdir=dir flag sets a dir with multiple json config\nThe -format=json flag sets the format of config files. Default \u0026ldquo;json\u0026rdquo;.\nThe -test flag tells Xray to test config files only, without launching the server\n\nxray version  使用方法:\nxray version Version prints the build information for Xray executables.\n\nxray api  使用方法:\nxray api \u0026lt;command\u0026gt; [arguments] The commands are:\n restartlogger Restart the logger stats Get statistics statsquery Query statistics statssys Get system statistics adi Add inbounds ado Add outbounds rmi Remove inbounds rmo Remove outbounds  \nxray tls  使用方法:\nxray tls \u0026lt;command\u0026gt; [arguments] The commands are:\n cert Generate TLS certificates ping Ping the domain with TLS handshake  \nxray uuid  使用方法:\nxray uuid Generate new UUIDs.\n\n当-config没有指定时，Xray 将先后尝试从以下路径加载config.json:\n 工作目录（Working Directory） 环境变量中Xray.location.asset所指定的路径   "},{"uri":"https://xtls.github.io/config/base/","title":"基础配置模块","tags":[],"description":"Project X 的文档.","content":" 这个章节说明了所有的 Xray 基础配置模块的细节. 基础配置模块   log:LogObject\n 日志配置，控制 Xray输出日志的方式. api:ApiObject\n 提供了一些API接口供远程调用。 dns: DnsObject\n 内置的 DNS 服务器. 如果没有配置此项，则使用系统的 DNS 设置。 routing: RoutingObject\n 路由功能。可以设置规则分流数据从不同的outbound发出. policy: PolicyObject\n 本地策略，可以设置不同的用户等级和对应的策略设置。 inbounds: [ InboundObject ]\n 一个数组，每个元素是一个入站连接配置。 outbounds: [ OutboundObject ]\n 一个数组，每个元素是一个出站连接配置。 transport: TransportObject\n 用于配置 Xray 其它服务器建立和使用网络连接的方式。 stats: StatsObject\n 用于配置流量数据的统计。 reverse: ReverseObject\n 反向代理。可以把服务器端的流量向客户端转发，即逆向流量转发 fakedns: FakeDnsObject\n FakeDNS. 可配合透明代理使用，以获取实际域名。\n"},{"uri":"https://xtls.github.io/develop/intro/guide/","title":"开发规范","tags":[],"description":"Project X 的文档.","content":"基本  版本控制  project X 的代码被托管在github上:\n xray 核心 xray-core xray-flutter xray-flutter 安装脚本 Xray-install 数据文件 Xray-rules-dat 配置模板 Xray-examples xray文档 XTLS.github.io  您可以使用 Git 来获取代码.\n 分支（Branch）  本项目的主干分支为 main, main 分支也是发布时所使用的代码分支, 因此需要确保 master 在任一时刻都是可编译可使用的。\n如果需要开发新的功能\n 请新开分支进行开发, 在开发完成并且经过充分测试后, 合并回主干分支. 新开分支如没有必要再存在时, 可以去除.   发布（Release）  In progress\n 建立尝鲜版本和稳定版本两个发布通道  临时版本, 主要用于特定情况的测试(比如从分支build的), 于TG群内/issue回复等渠道 发布特定版本 尝鲜版本可以为daily build , 用于尝鲜和获得即时反馈和再改进. 稳定版本为定时更新(比如周更), 合并稳定的修改并发布.     引用其它项目   Golang  产品代码建议使用 Golang 标准库和 golang.org/x/ 下的库； 如需引用其它项目，请事先创建 issue 讨论；   其它  不违反双方的协议，且对项目有帮助的工具，都可以使用。     开发流程  写代码之前  发现任何问题，或对项目有任何想法，请创建 Issue 讨论以减少重复劳动和消耗在代码上的时间。\n 修改代码   Golang  请参考 Effective Go； 每一次 push 之前，请运行：go fmt ./... 和 go fmt -s -l -e -w $(find . -type f -name \u0026quot;*.go\u0026quot; ! -name \u0026quot;*.pb.go\u0026quot;)； 每一次 push 之前，请确保测试通过：go test ./...； 提交 pull request 之前，请确保新增代码有超过 70% 的代码覆盖率（code coverage）；   其它  请注意代码的可读性。     Pull Request   提交 PR 之前，请先运行 git pull https://github.com/xray/xray-core.git 以确保 merge 可顺利进行； 一个 PR 只做一件事，如有对多个 bug 的修复，请对每一个 bug 提交一个 PR； 由于 Golang 的特殊需求（Package path），Go 项目的 PR 流程和其它项目有所不同 ,建议流程如下：  先 Fork 本项目，创建自己的 github.com/your/Xray-core 仓库； 克隆自己的 Xray 仓库到本地：git clone https://github.com/your/Xray-core.git； 基于 main 分支创建新的分支； 在自行创建的分支上作修改并提交修改(commit)； 在推送(push)修改完成的分支到自己的仓库前，先切换到 main 分支，运行 git pull https://github.com/v2fly/Xray-core.git 拉取最新的远端代码； 如果上一步拉取得到了新的远端代码，则切换到之前自己创建的分支，运行 git rebase master 执行分支合并操作。如遇到文件冲突，则需要解决冲突； 上一步处理完毕后，就可以把自己创建的分支推送到自己的仓库：git push -u origin your-branch 最后，把自己仓库的新推送的分支往 xtls/Xray-core 的 main 分支发 PR 即可； 请在 PR 的标题和正文中，完整表述此次 PR 解决的问题 / 新增的功能 / 代码所做的修改的用意等； 耐心等待开发者的回应。    对代码的修改  功能性问题  请提交至少一个测试用例（Test Case）来验证对现有功能的改动。\n性能相关  请提交必要的测试数据来证明现有代码的性能缺陷，或是新增代码的性能提升。\n新功能   如果新增功能对已有功能不影响，请提供可以开启/关闭的开关（如 flag），并使新功能保持默认关闭的状态； 大型新功能（比如增加一个新的协议）开发之前，请先提交一个 issue，讨论完毕之后再进行开发。  其它  视具体情况而定。\n Xray 编码规范  以下内容适用于 Xray 中的 Golang 代码。\n代码结构  Xray-core ├── app // 应用模块 │ ├── router // 路由 ├── common // 公用代码 ├── proxy // 通讯协议 │ ├── blackhole │ ├── dokodemo-door │ ├── freedom │ ├── socks │ ├── vmess ├── transport // 传输模块 编码规范  基本与 Golang 官方所推荐做法一致，有一些例外。写在这里以方便大家熟悉 Golang。\n命名   文件和目录名尽量使用单个英文单词，比如 hello.go；  如果实在没办法，则目录使用连接线／文件名使用下划线连接两个（或多个单词），比如 hello-world/hello_again.go； 测试代码使用 _test.go 结尾；   类型使用 Pascal 命名法，比如 ConnectionHandler；  对缩写不强制小写，即 HTML 不必写成 Html；   公开成员变量也使用 Pascal 命名法； 私有成员变量使用 小驼峰式命名法 ，如 privateAttribute ； 为了方便重构，方法建议全部使用 Pascal 命名法；  完全私有的类型放入 internal 。     内容组织   一个文件包含一个主要类型，及其相关的私有函数等； 测试相关的文件，如 Mock 等工具类，放入 testing 子目录。  "},{"uri":"https://xtls.github.io/faq/performance/","title":"性能相关的问题","tags":[],"description":"Project X 的文档.","content":" Q: 我是瓜瓜, 我想问 Xray 是不是最快的?是.\n Q: 什么工具或协议组合最快啊?/我应该用什么工具协议组合啊?个人自建上网,首先考虑安全性和伪装性,然后选择能满足自己需求的最高性能组合\n上网速率的高低, 体感的快慢, 根本的决定因素是线路 因此所有的选择跟你的实际环境息息相关,有时候需要一些特殊手段处理, 比如\n 比如低质量的线路可用使用CF加速. 比如晚上高峰期严重丢包的情况下, 可用使用mkcp(上限很低), 让线路尽量跑的更流畅一些.  在通常的环境下, 各种工具/协议组合的性能的高低, 可以参考Xray性能对比测试\n Q: mac和win 使用splice是不是无解了？ Windows 提供了 TransmitFile，但似乎不能用于两个 TCP 对接 Windows 10 有 WSL  WSL 1 使用 Splice 性能捉急. 不清楚 WSL 2 会不会带来额外拷贝开销，需要更多勇士尝试并反馈.   macOS暂无计划   Q: 有无xtls+splice+ws的计划？XTLS 原理上不支持 WS\n不带 TLS 的 WS 理论上可以支持类似 XTLS 的东西，目前没有实现它的计划\n或者 看看这里\n \n"},{"uri":"https://xtls.github.io/documents/level-2/iptables_gid/","title":"透明代理通过gid规避Xray流量","tags":[],"description":"Project X 的文档.","content":"在现有的iptables透明代理白话文(新 V2Ray 白话文指南-透明代理 、 新 V2Ray 白话文指南-透明代理(TPROXY) 、 透明代理（TProxy）配置教程)教程中，对Xray流量的规避处理是打mark实现的。即对Xray出站流量打mark，通过设置iptables规则对对应mark的流量直连，来规避Xray流量，防止回环。\n这么做有以下几个问题：\n  莫名流量进入PREROUTING链\n  安卓系统有自己的mark机制，该方案在安卓上不可用\n  本教程的方案不需要设置mark，理论性能更高，同时也不存在上述问题。\n思路 tproxy流量只能被root权限用户(uid==0)或其他有CAP_NET_ADMIN权限的用户接收。\niptables规则可以通过uid(用户id)和gid(用户组id)分流。\n让Xray运行在一个uid==0但gid!=0的用户上，设置iptables规则不代理该gid的流量来规避Xray流量。\n配置过程 1. 前期准备 安卓系统\n  系统已root\n  安装 busybox\n  有一个可以执行命令的终端，可以使用adb shell，termux等。\n  其它Linux系统\n需要依赖sudo，iptables的tproxy模块和extra模块。\n一般系统都有自带，openwrt运行：\nopkg install sudo iptables-mod-tproxy iptables-mod-extra 另附上一些openwrt常用的依赖，缺少可能导致Xray无法运行\nopkg install libopenssl ca-certificates 2. 添加用户(安卓用户请忽略) 安卓系统不支持/etc/passwd文件来管理用户，请忽略，直接下一步。\ngrep -qw xray_tproxy /etc/passwd || echo \u0026#34;xray_tproxy:x:0:23333:::\u0026#34; \u0026gt;\u0026gt; /etc/passwd 其中xray_tproxy是用户名，0是uid，23333是gid，用户名和gid可以自己定，uid必须为0。 检查用户是否添加成功，运行\nsudo -u xray_tproxy id 显示的结果应该是uid为0，gid为23333\n3. 配置运行Xray，配置iptables规则 在现有的iptables透明代理白话文(新 V2Ray 白话文指南-透明代理 、 新 V2Ray 白话文指南-透明代理(TPROXY) 、 透明代理（TProxy）配置教程)教程的基础上修改：\n  修改json配置文件，删除mark相关内容\n  修改iptables规则，删除mark相关内容，并在OUTPUT链应用规则处添加选项\u0026quot;-m owner ! \u0026ndash;gid-owner 23333\u0026quot;。\n  如：\niptables -t mangle -A OUTPUT -j XRAY_SELF 改为\niptables -t mangle -A OUTPUT -m owner ! --gid-owner 23333 -j XRAY_SELF 修改运行Xray的方式，使其运行在uid为0，gid为23333的用户上，参考这里。  下面提供一个实现tproxy全局代理的完整配置过程 1. 完成 前期准备 和 添加用户 2. 准备Xray配置文件 配置Xray任意门监听12345，开启followRedirect和tproxy，不需要设置sniffing：\n{ \u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 12345, \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;tcp,udp\u0026#34;, \u0026#34;followRedirect\u0026#34;: true }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;sockopt\u0026#34;: { \u0026#34;tproxy\u0026#34;: \u0026#34;tproxy\u0026#34; } } } ], \u0026#34;outbounds\u0026#34;: [ { 你的服务器配置 } ] } 3. 配置最大文件大开数\u0026amp;运行Xray客户端 关于最大文件大开数问题见： too many open files 问题\n目前Xray服务端使用官方脚本安装的已经自动配置了最大文件大开数，无需再修改。\n安卓系统\nulimit -SHn 1000000 setuidgid 0:23333 \u0026#34;运行Xray的命令\u0026#34;\u0026amp; 其它Linux系统\nulimit -SHn 1000000 sudo -u xray_tproxy \u0026#34;运行Xray的命令\u0026#34;\u0026amp; 第一条命令：\n改变最大打开文件数，只对当前终端有效，每次启动Xray前都要运行，该命令是设置客户端的最大文件大开数\n第二条命令：\n以uid为0，gid不为0的用户来运行Xray客户端，后面加\u0026amp;代表放在后台运行\n检查最大文件大开数是否设置成功\ncat /proc/Xray的pid/limits 找到max open files一项，应该是你设置的数值。pid的获取方法为运行ps或ps -aux或ps -a\n服务端和客户端都要检查\n4. 设置iptables规则 代理ipv4\nip rule add fwmark 1 table 100 ip route add local 0.0.0.0/0 dev lo table 100 # 代理局域网设备 iptables -t mangle -N XRAY # \u0026#34;网关所在ipv4网段\u0026#34; 通过运行命令\u0026#34;ip address | grep -w inet | awk \u0026#39;{print $2}\u0026#39;\u0026#34;获得，一般有多个 iptables -t mangle -A XRAY -d 网关所在ipv4网段1 -j RETURN iptables -t mangle -A XRAY -d 网关所在ipv4网段2 -j RETURN ... # 组播地址直连 iptables -t mangle -A XRAY -d 224.0.0.0/4 -j RETURN iptables -t mangle -A XRAY -d 255.255.255.255/32 -j RETURN #如果网关作为主路由，则加上这一句，见：https://xtls.github.io/documents/level-2/transparent_proxy/transparent_proxy.md#iptables透明代理的其它注意事项 #网关LAN_IPv4地址段，运行命令\u0026#34;ip address | grep -w \u0026#34;inet\u0026#34; | awk \u0026#39;{print $2}\u0026#39;\u0026#34;获得，是其中的一个 iptables -t mangle -A XRAY ! -s 网关LAN_IPv4地址段 -j RETURN # 给 TCP 打标记 1，转发至 12345 端口 # mark只有设置为1，流量才能被Xray任意门接受 iptables -t mangle -A XRAY -p tcp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A XRAY -p udp -j TPROXY --on-port 12345 --tproxy-mark 1 # 应用规则 iptables -t mangle -A PREROUTING -j XRAY # 代理网关本机 iptables -t mangle -N XRAY_MASK iptables -t mangle -A XRAY_MASK -m owner --gid-owner 23333 -j RETURN iptables -t mangle -A XRAY_MASK -d 网关所在ipv4网段1 -j RETURN iptables -t mangle -A XRAY_MASK -d 网关所在ipv4网段2 -j RETURN ... iptables -t mangle -A XRAY_MASK -d 224.0.0.0/4 -j RETURN iptables -t mangle -A XRAY_MASK -d 255.255.255.255/32 -j RETURN iptables -t mangle -A XRAY_MASK -j MARK --set-mark 1 iptables -t mangle -A OUTPUT -p tcp -j XRAY_MASK iptables -t mangle -A OUTPUT -p udp -j XRAY_MASK 代理ipv6(可选)\nip -6 rule add fwmark 1 table 106 ip -6 route add local ::/0 dev lo table 106 # 代理局域网设备 ip6tables -t mangle -N XRAY6 # \u0026#34;网关所在ip6网段\u0026#34; 通过运行命令\u0026#34;ip address | grep -w inet6 | awk \u0026#39;{print $2}\u0026#39;\u0026#34;获得。 ip6tables -t mangle -A XRAY6 -d 网关所在ipv6网段1 -j RETURN ip6tables -t mangle -A XRAY6 -d 网关所在ipv6网段2 -j RETURN ... # 如果网关作为主路由，则加上这一句，见：https://xtls.github.io/documents/level-2/transparent_proxy/transparent_proxy.md#iptables透明代理的其它注意事项 # 网关LAN_IPv6地址段，运行命令\u0026#34;ip address | grep -w \u0026#34;inet6\u0026#34; | awk \u0026#39;{print $2}\u0026#39;\u0026#34;获得，是其中的一个 ip6tables -t mangle -A XRAY6 ! -s 网关LAN_IPv6地址段 -j RETURN ip6tables -t mangle -A XRAY6 -p udp -j TPROXY --on-port 12345 --tproxy-mark 1 ip6tables -t mangle -A XRAY6 -p tcp -j TPROXY --on-port 12345 --tproxy-mark 1 ip6tables -t mangle -A PREROUTING -j XRAY6 # 代理网关本机 ip6tables -t mangle -N XRAY6_MASK ip6tables -t mangle -A XRAY6_MASK -m owner --gid-owner 23333 -j RETURN ip6tables -t mangle -A XRAY6_MASK -d 网关所在ipv6网段1 -j RETURN ip6tables -t mangle -A XRAY6_MASK -d 网关所在ipv6网段2 -j RETURN ... ip6tables -t mangle -A XRAY6_MASK -j MARK --set-mark 1 ip6tables -t mangle -A OUTPUT -p tcp -j XRAY6_MASK ip6tables -t mangle -A OUTPUT -p udp -j XRAY6_MASK "},{"uri":"https://xtls.github.io/config/","title":"配置文件","tags":[],"description":"Project X 的文档.","content":" 这个章节将告诉您所有的 Xray 配置细节,掌握这些内容,在您手中 Xray 将发挥更大威力. 概述  Xray 的配置文件为 json 格式, 客户端和服务端的配置格式没有区别, 只是实际的配置内容不一样。\n形式如下:\n{ \u0026#34;log\u0026#34;: {}, \u0026#34;api\u0026#34;: {}, \u0026#34;dns\u0026#34;: {}, \u0026#34;routing\u0026#34;: {}, \u0026#34;policy\u0026#34;: {}, \u0026#34;inbounds\u0026#34;: [], \u0026#34;outbounds\u0026#34;: [], \u0026#34;transport\u0026#34;: {}, \u0026#34;stats\u0026#34;: {}, \u0026#34;reverse\u0026#34;: {}, \u0026#34;fakedns\u0026#34;:{} }  TIP\n如果你刚接触 Xray, 您可以先点击查看快速入门中的配置运行, 学习最基本的配置方式, 然后查看本章节内容以掌握所有 Xray 的配置方式.\n "},{"uri":"https://xtls.github.io/documents/level-0/ch04-security/","title":"【第4章】安全防护篇","tags":[],"description":"小小白白话文","content":"4.1 为什么要做安全防护  Linux服务器的安全防护是一个纷繁复杂的巨大课题。无数的网站、APP、服务、甚至线下基础设施都建立在Linux的基石之上，这背后牵涉到巨大的经济利益和商业价值，当然也就就意味着黑灰产有巨大的攻击动力。但是这些服务是如此重要、根本不允许出现重大的安全漏洞。于是无数的运维专业人员都在安全攻防的战场上拼搏努力，这才让大家能享受到基本稳定的现代化数字生活。\n现在，你拥有了一台VPS，并且将会敞开他的数据访问渠道来达到流量转发的目标，那就相当于你已经置身于安全攻防战场的第一线、直面所有风险。但与此同时，新人由于知识和信息的不足，看待安全问题是总是难免两极分化：要么觉得轻如鸿毛和自己没有半点关系，要么觉得重于泰山甚至惶惶不可终日。\n  对于前者，我的建议是：安全无小事，尽量多查一些安全方面的信息，免得自己真的受了损失才后悔莫及\n  对于后者，我的建议是：不用紧张，我们的服务器仍不具有太高的价值、一般不会吸引到高水平的攻击，需要面对的基本都是一些自动化脚本的恶意扫描和登录尝试，跟着本文做一些基础的防护即可\n   4.2 具体的风险到底是什么  就像我们在《远程登录篇》配置的一样，任何人只需要知道【IP地址】+【端口】+【用户名】+【密码】这四个要素，就能登录你的VPS服务器。那很显然，这四要素的安全就是我们要防护的底线。我们来逐一分析：\n  【IP地址】：恶意脚本会随机尝试和扫描IP段，可以简单认为是公开信息、无法隐藏\n  【端口】：如果使用默认端口，那么【端口 = 22】\n  【用户名】：如果使用默认用户，那么【用户名 = root】\n  【密码】：密码不存在默认值，一定是由VPS后台随机生成或由你自行设置的。也就是说，如果你的服务器都是默认设置，则四要素中的三个已经是已知的，那么你整个服务器的安全，就全部寄托在一串小小的密码上了。这时有几种情况：\n  如果你用了VPS管理后台随机生成密码，它一般包含随机的十几个大小写混杂的字母和符号，相对比较安全\n  如果你为了好记、把密码改成了类似123456这种超弱的密码，破解你的VPS服务器可谓不费吹灰之力\n  如果你为了好记、把密码改成了比较复杂、但在别的地方用过的密码，其实也并不安全。你要明白黑客手里有作弊器，比如说密码表，包含数万、数十万、数百万甚至更多曾经泄漏的真实密码）\n    但你要明白，没有哪个黑客真的要坐在电脑前一次一次的尝试你的密码，全部的攻击尝试都是恶意脚本自动进行的，它会24小时不眠不休的工作。也许每天你酣睡之时，你的服务器都在经受着一轮又一轮的冲击。\n一旦密码被成功撞破，意味着你的四要素全部被攻击者掌握，恶意脚本就会快速登录服务器、获取服务器的最高 root 控制权、安装部署它的恶意服务，然后就可以用你的服务器来24小时做各种坏事（比如挖矿、传播病毒、发送垃圾邮件、欺诈邮件、做BT中继、甚至暗网公众节点等等等等）。如果恶意脚本比较克制，其实可以做到相当的隐蔽性。而新人一般也不会去观察留意VPS的登录记录、进程变化、CPU占用变化、流量变化等指标，你其实就很难发现自己被黑了。直到你的VPS服务商封禁你的账号、或者收到律师函为止。\n  别忘了，你获得VPS时大概率需要使用真实的支付信息，你登录各种网站、社交平台时也会留下你的IP地址，这些都与你的身份有直接或者间接的关系。于是，一旦这些坏事发生，它们就不可避免的与你产生了关联。\n   4.3 我们要做的安全防护有哪些  基于上述分析，我们要做的，自然就是对【端口】、【用户名】、【密码】这三要素进行加强，来降低被攻破的风险：\n 【端口】：将SSH远程登录端口修改为【非22端口】 （4.4） 【用户名】：建立【非root】的新用户、并禁用root用户SSH远程登录 （4.5、4.6） 【密码】：SSH启用RSA密钥验证登录、同时禁用密码验证登录 （4.7）  记得按顺序来，别把自己锁在门外了。\n 4.4 将SSH远程登录端口修改为非22端口  现在，我们来解决【端口 = 22】的问题。（注意：有些VPS服务商，默认的端口已经是非22端口，那么你可以忽略这一步，当然也可以跟着本文改成别的端口）\n  小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-03 nano 文本编辑器   cmd-04 systemctl restart 重启某个服务      小小白白Linux基础配置文件\n   编号 配置文件位置 文件说明     conf-01 /etc/ssh/sshd_config SSH远程登录程序设置      我们要做的第一件事，当然就是【用nano这个文本编辑器打开SSH远程登录程序设置】，在Windows下，你会【找到文件并双击】，在Linux下该怎么办呢？仔细看看上面的命令说明，是不是就很简单了？没错，就是：\n# nano /etc/ssh/sshd_config   文件打开后，你就进入了nano的界面，稍微观察一下，你会发现，它把重要的快捷键都显示在屏幕下方了（下图红框内），直接开卷考试、不用死记硬背，是不是很贴心呢？\n  我们要做的第二件事，是【在打开的文件中找到Port这一项，并修改它的端口】。Port后面的数字就是SSH的端口，一般建议把它改成一个大于1024小于65535的整数（本文以9753为例）。请结合nano的快捷键，想一下该怎么操作呢？果然，你又说对了！就是：\n 使用 ctrl+w 进入搜索模式，然后输入 Port 22 并回车 删除 22 并改成 9753 说明：如果这一行开头有个#，证明这一行【不生效】（被注释掉了），你可像我一样在文件最后写一个不带#的，或者把#删掉就好。  注意： 本文以9753为例，就意味着随着本文的发布，这个端口会变成一个不大不小的特征，也许会被攻击者优先尝试、也许被GFW干扰、阻断。所以我强烈建议你用一个自己想到的其他端口，毕竟，你有6万多个端口可以自由选择。\n   我们要做的第三件事，是【保存文件并退出】\n 如果第3步你有仔细观察，就会发现保存并不是常见的 ctrl+s。 正确的快捷键：保存是 ctrl+o + 回车，退出是 ctrl+x    我们最后要做的事，是【重启ssh服务，使变更生效】\n# systemctl restart ssh   完整流程演示如下：\n  修改 PuTTY 配置\n现在新的端口已经生效，下次使用PuTTY登录时就要用9753了。所以现在请到PuTTY的设置中修改端口号码，然后保存Session。嗯，你应该知道去哪里改了吧？（如果不知道的话，要重读前面的内容了哦！）\n   4.5 建立非root的新用户  第二步，我们来解决【用户名 = root】的问题。\n首先你要理解， Linux系统中的root，不仅仅是一个管理员账号那么简单。它是整个系统的【根基】、是系统的主宰、至高无上的神。一旦root账号出现安全问题，整个系统都只能任人鱼肉、无处可逃。那么就跟随我进行操作吧：\n  小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-05 adduser 给系统新增用户   cmd-06 apt install 安装某个软件   cmd-07 visudo 修改sudo权限设置专用编辑器      我们要做的第一件事，是【新增一个用户并设定登录密码】，名字你可以随便起，我这里以vpsadmin为例：\n# adduser vpsadmin 执行命令后，根据提示操作即可。请务必设置一个用户密码（别忘记设置密码时你时看不到 ****** 的）。之后系统会询问你一些用户的附加信息，这些就可以无视，一路回车即可。\n注意： 本文以vpsadmin为例，就意味着随着本文的发布，这个用户名也会变成一个不大不小的特征，也许会被攻击者优先尝试。所以和端口一样，我强烈建议你用一个自己想到的其他用户名。\n   完整流程演示如下：\n  我们要做的第二件事，是【安装sudo功能】（sudo 就是在关键时刻，让普通账户临时获得 root 的神力，战力全开拯救世界）\n# apt update \u0026amp;\u0026amp; apt install sudo 聪明的你大概已经发现，这一行命令其实是两个命令。前一半 apt update 你之前已经见过并且用过了，是去服务器刷新软件版本信息。后面的 apt install 就是这一次要用到的【安装命令】。两条连接在一起，就是让系统去【刷新可用的最新软件，然后安装最新版的sudo程序】。 \u0026amp;\u0026amp; 则是把两个命令连起来执行的意思。\n  我们要做的第三件事，是【把vpsadmin用户加入sudo名单里，让他有资格借用root的神力】\n# visudo 在 User Privilege Specification 下加入一行 vpsadmin ALL=(ALL) NOPASSWD: ALL 即可。\n注意： 我要特别说明的是NOPASSWD这个设置，它的意思是vpsadmin用户临时使用root权限时，不用额外输入密码。这与一般的安全建议相反。我之所以如此推荐，是因为很多新人不顾危险坚持使用root账号就是因为用root时不用重复输入密码、觉得轻松。“两害相权取其轻”，我认为【直接用root用户的风险】大于【使用sudo时不用输密码的风险】，所以做了以上的建议。\n如果你希望遵守传统习惯、每次使用sudo时需要输入密码，那么这一行改成 vpsadmin ALL=(ALL:ALL) ALL 即可。\n   完整流程演示如下：\n   4.6 禁用root用户SSH远程登录    现在你已经逐渐熟悉Linux了，所以这次换你思考，我们要做的第一件事是什么呢？没错，还是【用nano编辑器打开SSH远程登录程序设置】，什么，你想不起来怎么操作了？那去复习一下上面的内容再回来吧！\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip; 正确答案：\n# nano /etc/ssh/sshd_config   找到PermitRootLogin Yes这一项，然后把它后面的设定值改为no即可。还记得怎么操作吗？\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip; 正确答案：\n 使用 ctrl+w 进入搜索模式，然后输入 PermitRootLogin 并回车 删除 yes 并改成 no    保存文件并退出。还记得怎么操作吗？\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip; 正确答案：\n 保存是 ctrl+o，然后 回车 确认 退出是 ctrl+x    重启ssh服务，让变更生效。还记得\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip; 算了直接公布正确答案：\n# systemctl restart ssh   完整流程演示如下：\n  下次通过PuTTY远程SSH登录的时候，root用户已无法连接，用户名就要换成vpsadmin了！方便起见，我们可以在PuTTY中把vpsadmin设置成默认登录用户名。（啰嗦君：别忘了保存Session）\n   4.7 使用RSA密钥登录并禁用密码登录  第三步，我们来解决【密码】可能被撞破的问题。\n前面我说过，黑客并不是很蠢的用穷举法破解你的密码，而是会用一些比如“密码表”的作弊手段。除非你用的是随机生成的超长密码（比如借助1Password，或者macOS的keychain等密码管理工具），否则很容易中招。\n超长随机密码虽然安全性有所提高，但是基本上无法记忆，手动输入也十分麻烦易错。为了解决这个困境，我们可以直接弃用【密码验证】方式，改用更安全的【密钥验证】。\n所谓的【密钥验证】，就是生成【一对】相关联的密钥文件（公钥和私钥），然后把【公钥】上传到VPS备用。每次登录时，SSH会将【公钥】和【私钥】进行匹配，若验证是正确的【密钥对】，则验证通过。（换言之，你无需记忆和输入复杂的密码，只要保护好【私钥】这个文件不外泄即可）\n注意： 本文以 RSA 密钥举例，是因为 RSA 密钥在各种设备、各种 SSH 客户端中有广泛悠久的支持历史，且目前依然能提供够用的安全性。但它绝非唯一选择。\n其他的常见密钥还有：\n DSA - 已经从数学层面被证明不安全，所以永远不要用它 ECDSA - 密钥小安全性高，但其算法被指留有NSA的后门，如果你的VPS上有值得NSA关注的东西就不要用它 Ed25519 - 这是一个与 ECDSA 十分类似的算法，故具有相似的性能优势。同时其文档全部公开，所以普遍认为无后门  所以，如果你的设备和软件都支持的话，我建议优先选择 Ed25519 密钥。\n 那我们现在就来配置【密钥验证】吧！\n  运行PuTTYgen (PuTTY密钥生成器)。位置是 开始菜单 \u0026ndash;\u0026gt; 所有程序 \u0026ndash;\u0026gt; PuTTY (64-bit) \u0026ndash;\u0026gt; PuTTYgen\n  点击Generate开始生成（在界面空白处乱晃鼠标增加随机数） 注意： 本图中是以 2048 位的 RSA 密钥为例的。但实际上，如果要获得与 EDCSA/Ed25519 的 256 位密钥相同的安全性，你需要使用 3072 位的 RSA 密钥。（即右下角的数字改成 3072）\n   你可以给私钥设置密码，增加一层安全性\n  点击 Save public key 保存公钥，文件名为 id_rsa.pub\n  点击 Save private key 保存私钥，文件名为 id_rsa (PuTTY私钥自带.ppk后缀)\n  最重要的，将上方红框内的内容，向下滚动全部复制出来并保存，文件名为 authorized_keys。（用vscode保存，默认会变成带txt后缀的文本文件，这没关系，之后上传VPS时我们会把后缀名去掉）     将公钥上传至VPS的vpsadmin用户下\n  这一步就需要用到之前准备的WinSCP了。\n  去官网下载并安装，会提示你导入PuTTY的设置，当然一键导入啦！   如果没有提示导入或者你已经提前安装好了，那按照下图进行配置即可   WinSCP左边的目录就是本地电脑上的文件夹和文件，请定位到密钥所在的文件夹\n  WinSCP右边的目录则是VPS服务器上的文件夹和文件，默认就在 /home/vpsadmin/ 文件夹，此时在请点击右下角 X hidden 来显示隐藏文件   在右边（VPS中）点击右键并新建文件夹，起名.ssh （注意有一个.）   将【公钥】authorized_keys上传到.ssh文件夹内   在上传时，将【公钥】从 authorized_keys.txt 改名为 authorized_keys（去掉.txt这个后缀名）   完整流程演示如下：     在VPS端设置SSH启用RSA密钥验证登录、同时禁用密码验证登录\n  小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-08 sudo 用root权限运行某个命令   cmd-09 chmod 修改目标文件/文件夹的权限      SSH远程连接到VPS上（PuTTY）\n  修改 authorized_keys 文件权限为 600 （仅所有者可读可写）\n$ chmod 600 ~/.ssh/authorized_keys   修改 SSH 配置。这个我们已经用了很多次，但现在我们已经从无所不能的root变成了普通用户vpsadmin，此时的我们是没有权限直接编辑SSH配置的。这时候就需要使用sudo命令了：\n$ sudo nano /etc/ssh/sshd_config   找到(ctrl+w) PasswordAuthentication 改成 no\n  找到(ctrl+w) PubkeyAuthentication 改成 yes，然后保存(ctrl+o)退出(ctrl+x)\n  重启SSH服务。（啰嗦君：别忘了现在需要使用sudo来获得权限）\n$ sudo systemctl restart ssh   完整流程如下：\n    VPS端已经设置好了公钥，现在要给PuTTY指定私钥位置供登录时使用（啰嗦君：别忘了保存Session）\n  至此，【密钥登录】已成功开启、【密码验证】已成功关闭、并且还给PuTTY保存了默认的登录用户名和私钥。未来使用PuTTY登录时，载入VPS-SERVER配置后，点击Open就可以一键登录了。\n如果你给私钥设置了密码保护，登录时当然还需要输入这个密码才能使用密钥，如下图：\n  别忘了给WinSCP也做对应的密钥设置，否则之后想要传输文件时就无法登录了：\n注意： 任何需要借助SSH进行登录的软件都需要密钥验证了，软件过多，无法逐一展示，请根据你的需要自行设置好哦\n    4.8 你的进度  到这里为止，你的VPS已经完成了【端口】、【用户名】、【密码】这三要素的基本安全保障，虽然远称不上固若金汤，但一般的恶意脚本应该已经无法对你造成伤害了！\n现在我们终于有了一个安全的系统基础，下一章，我们就可以开始逐步安装配置Xray需要的基础设施了！（什么基础设施呢？一个网页，一张证书）\nPROGRESS⬛⬛⬛⬛⬜⬜⬜⬜ 50%\n "},{"uri":"https://xtls.github.io/config/outbound-protocols/http/","title":"HTTP","tags":[],"description":"Project X 的文档.","content":"HTTP 协议。\nimportanthttp 协议没有对传输加密，不适宜经公网中传输，更容易成为被人用作攻击的肉鸡。\nhttp inbound 更有意义的用法是在局域网或本机环境下监听，为其他程序提供本地服务。\n TIP\nhttp proxy 只能代理 tcp 协议，udp 系的协议均不能通过。\n OutboundConfigurationObject  { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;192.168.108.1\u0026#34;, \u0026#34;port\u0026#34;: 3128, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; } ] } ] }  TIP\n目前 HTTP 协议 outbound 中 streamSettings 设置 security 和 tlsSettings 是生效的。\n servers: [ ServerObject ]\n HTTP 服务器列表，其中每一项是一个服务器配置，若配置多个，循环使用 (RoundRobin)。\n\nServerObject  { \u0026#34;address\u0026#34;: \u0026#34;192.168.108.1\u0026#34;, \u0026#34;port\u0026#34;: 3128, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; } ] }  address: string\n HTTP 代理服务器地址，必填。\nport: int\n HTTP 代理服务器端口，必填。\nuser: [AccountObject]\n 一个数组，数组中每个元素为一个用户帐号。默认值为空。\n\nAccountObject  { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; }  user: string\n 用户名，字符串类型。必填。\npass: string\n 密码，字符串类型。必填。\n"},{"uri":"https://xtls.github.io/config/transports/mkcp/","title":"mKCP","tags":[],"description":"Project X 的文档.","content":"mKCP 使用 UDP 来模拟 TCP 连接。\nmKCP 牺牲带宽来降低延迟。传输同样的内容，mKCP 一般比 TCP 消耗更多的流量。\nTIP\n请确定主机上的防火墙配置正确\n KcpObject  KcpObject 对应传输配置的 kcpSettings 项。\n{ \u0026#34;mtu\u0026#34;: 1350, \u0026#34;tti\u0026#34;: 20, \u0026#34;uplinkCapacity\u0026#34;: 5, \u0026#34;downlinkCapacity\u0026#34;: 20, \u0026#34;congestion\u0026#34;: false, \u0026#34;readBufferSize\u0026#34;: 1, \u0026#34;writeBufferSize\u0026#34;: 1, \u0026#34;header\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }, \u0026#34;seed\u0026#34;: \u0026#34;Password\u0026#34; }  mtu: number\n 最大传输单元（maximum transmission unit）\n请选择一个介于 576 - 1460 之间的值。\n默认值为 1350。\ntti: number\n 传输时间间隔（transmission time interval），单位毫秒（ms），mKCP 将以这个时间频率发送数据。\n请选译一个介于 10 - 100 之间的值。\n默认值为 50。\nuplinkCapacity: number\n 上行链路容量，即主机发出数据所用的最大带宽，单位 MB/s，注意是 Byte 而非 bit。\n可以设置为 0，表示一个非常小的带宽。\n默认值 5。\ndownlinkCapacity: number\n 下行链路容量，即主机接收数据所用的最大带宽，单位 MB/s，注意是 Byte 而非 bit。\n可以设置为 0，表示一个非常小的带宽。\n默认值 20。\nTIP\nuplinkCapacity 和 downlinkCapacity 决定了 mKCP 的传输速度。\n以客户端发送数据为例，客户端的 uplinkCapacity 指定了发送数据的速度，而服务器端的 downlinkCapacity 指定了接收数据的速度。两者的值以较小的一个为准。\n推荐把 downlinkCapacity 设置为一个较大的值，比如 100，而 uplinkCapacity 设为实际的网络速度。当速度不够时，可以逐渐增加 uplinkCapacity 的值，直到带宽的两倍左右。\n congestion: true | false\n 是否启用拥塞控制。\n开启拥塞控制之后，Xray 会自动监测网络质量，当丢包严重时，会自动降低吞吐量；当网络畅通时，也会适当增加吞吐量。\n默认值为 false\nreadBufferSize: number\n 单个连接的读取缓冲区大小，单位是 MB。\n默认值为 2。\nwriteBufferSize: number\n 单个连接的写入缓冲区大小，单位是 MB。\n默认值为 2。\nTIP\nreadBufferSize 和 writeBufferSize 指定了单个连接所使用的内存大小。\n在需要高速传输时，指定较大的 readBufferSize 和 writeBufferSize 会在一定程度上提高速度，但也会使用更多的内存。\n在网速不超过 20MB/s 时，默认值 1MB 可以满足需求；超过之后，可以适当增加 readBufferSize 和 writeBufferSize 的值，然后手动平衡速度和内存的关系。\n header: HeaderObject\n 数据包头部伪装设置\nseed: string\n 可选的混淆密码，使用 AES-128-GCM 算法混淆流量数据，客户端和服务端需要保持一致。\n本混淆机制不能用于保证通信内容的安全，但可能可以对抗部分封锁。 TIP\n目前测试环境下开启此设置后没有出现原版未混淆版本的封端口现象\n \nHeaderObject  { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }  type: string\n 伪装类型，可选的值有：\n \u0026quot;none\u0026quot;：默认值，不进行伪装，发送的数据是没有特征的数据包。 \u0026quot;srtp\u0026quot;：伪装成 SRTP 数据包，会被识别为视频通话数据（如 FaceTime）。 \u0026quot;utp\u0026quot;：伪装成 uTP 数据包，会被识别为 BT 下载数据。 \u0026quot;wechat-video\u0026quot;：伪装成微信视频通话的数据包。 \u0026quot;dtls\u0026quot;：伪装成 DTLS 1.2 数据包。 \u0026quot;wireguard\u0026quot;：伪装成 WireGuard 数据包。（并不是真正的 WireGuard 协议）  \n鸣谢   @skywind3000 发明并实现了 KCP 协议。 @xtaci 将 KCP 由 C 语言实现翻译成 Go。 @xiaokangwang 测试 KCP 与 Xray 的整合并提交了最初的 PR。  \n对 KCP 协议的改进  更小的协议头  原生 KCP 协议使用了 24 字节的固定头部，而 mKCP 修改为数据包 18 字节，确认（ACK）包 16 字节。更小的头部有助于躲避特征检查，并加快传输速度。\n另外，原生 KCP 的单个确认包只能确认一个数据包已收到，也就是说当 KCP 需要确认 100 个数据已收到时，它会发出 24 * 100 = 2400 字节的数据。其中包含了大量重复的头部数据，造成带宽的浪费。mKCP 会对多个确认包进行压缩，100 个确认包只需要 16 + 2 + 100 * 4 = 418 字节，相当于原生的六分之一。\n确认包重传  原生 KCP 协议的确认（ACK）包只发送一次，如果确认包丢失，则一定会导致数据重传，造成不必要的带宽浪费。而 mKCP 会以一定的频率重发确认包，直到发送方确认为止。单个确认包的大小为 22 字节，相比起数据包的 1000 字节以上，重传确认包的代价要小得多。\n连接状态控制  mKCP 可以有效地开启和关闭连接。当远程主机主动关闭连接时，连接会在两秒钟之内释放；当远程主机断线时，连接会在最多 30 秒内释放。\n原生 KCP 不支持这个场景。\n"},{"uri":"https://xtls.github.io/develop/protocols/mkcp/","title":"mKCP 协议","tags":[],"description":"Project X 的文档.","content":"mKCP 是流式传输协议，由 KCP 协议修改而来，可以按顺序传输任意的数据流。\n\n版本  mKCP 没有版本号，不保证版本之间兼容性。\n\n依赖  底层协议  mKCP 是一个基于 UDP 的协议，所有通讯使用 UDP 传输。\n\n函数   fnv: FNV-1a 哈希函数  输入参数为任意长度的字符串； 输入出一个 32 位无符号整数；    \n通讯过程   mKCP 将数据流拆成若干个数据包进行发送。一个数据流有一个唯一标识，用以区分不同的数据流。数据流中的每一个数据包都携带了同样的标识。 mKCP 没有握手过程，当收到一个数据包时，根据其携带的数据流的标识来判断是否为新的通话，或是正在进行中的通话。 每一个数据包中包含若干个片段（Segment），片段分为三类：数据（Data）、确认（ACK）、心跳（Ping）。每个片段需要单独处理。  \n数据格式  数据包     4 字节 2 字节 L 字节     认证信息 A 数据长度 L 片段部分    其中：\n 认证信息 A = fnv(片段部分），big endian； 片段部分可能包含多个片段；  \n数据片段     2 字节 1 字节 1 字节 4 字节 4 字节 4 字节 2 字节 Len 字节     标识 Conv 指令 Cmd 选项 Opt 时间戳 Ts 序列号 Sn 未确认序列号 Una 长度 Len 数据    其中：\n 标识 Conv: mKCP 数据流的标识 指令 Cmd: 常量 0x01 选项 Opt: 可选的值有：  0x00: 空选项 0x01: 对方已发出所有数据   时间戳 Ts: 当前片段从远端发送出来时的时间，big endian 序列号 Sn: 该数据片段时数据流中的位置，起始片段的序列号为 0，之后每个新片段按顺序加 1 未确认序列号 Una: 远端主机正在发送的，且尚未收到确认的最小的 Sn  \n确认片段     2 字节 1 字节 1 字节 4 字节 4 字节 4 字节 2 字节 Len * 4 字节     标识 Conv 指令 Cmd 选项 Opt 窗口 Wnd 下一接收序列号 Sn 时间戳 Ts 长度 Len 已收到的序列号    其中：\n 标识 Conv: mKCP 数据流的标识 指令 Cmd: 常量 0x00 选项 Opt: 同上 窗口 Wnd: 远端主机可以接收的最大序列号 下一接收序列号 Sn: 远端主机未收到的数据片段中的最小序列号 时间戳 Ts: 远端主机最新收到的数据片段的时间戳，可用于计算延迟 已收到的序列号: 每个 4 字节，表示此序列号的数据已经确认收到  注释：\n 远程主机期待收到序列号 [Sn, Wnd) 范围内的数据  \n心跳片段     2 字节 1 字节 1 字节 4 字节 4 字节 4 字节     标识 Conv 指令 Cmd 选项 Opt 未确认序列号 Una 下一接收序列号 Sn 延迟 Rto    其中：\n 标识 Conv: mKCP 数据流的标识 指令 Cmd: 可选的值有  0x02: 远端主机强行终止会话 0x03: 正常心跳   选项 Opt: 同上 未确认序列号 Una: 同数据片段的 Una 下一接收序列号 Sn: 同确认片段的 Sn 延迟 Rto: 远端主机自己计算出的延迟  "},{"uri":"https://xtls.github.io/config/inbound-protocols/socks/","title":"Socks","tags":[],"description":"Project X 的文档.","content":"标准 Socks 协议实现，兼容 Socks 4、Socks 4a 和 Socks 5。\nimportantsocks 协议没有对传输加密，不适宜经公网中传输\nsocks inbound 更有意义的用法是在局域网或本机环境下监听，为其他程序提供本地服务。\n InboundConfigurationObject { \u0026#34;auth\u0026#34;: \u0026#34;noauth\u0026#34;, \u0026#34;accounts\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; } ], \u0026#34;udp\u0026#34;: false, \u0026#34;ip\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;userLevel\u0026#34;: 0 }  auth: \u0026ldquo;noauth\u0026rdquo; | \u0026ldquo;password\u0026rdquo;\n Socks 协议的认证方式，支持 \u0026quot;noauth\u0026quot; 匿名方式和 \u0026quot;password\u0026quot; 用户密码方式。\n默认值为 \u0026quot;noauth\u0026quot;。\naccounts: [ AccountObject ]\n 一个数组，数组中每个元素为一个用户帐号。\n此选项仅当 auth 为 password 时有效。\n默认值为空。\nudp: true | false\n 是否开启 UDP 协议的支持。\n默认值为 false。\nip: address\n 当开启 UDP 时，Xray 需要知道本机的 IP 地址。\n默认值为 \u0026quot;127.0.0.1\u0026quot;。\nuserLevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n\nAccountObject  { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; }  user: string\n 用户名，字符串类型。必填。\npass: string\n 密码，字符串类型。必填。\n"},{"uri":"https://xtls.github.io/documents/level-1/work/","title":"Xray的工作模式","tags":[],"description":"Project X 的文档.","content":"单服务器模式  与其它的网络代理工具一样，你需要一台配置了 Xray 的服务器，然后在自己的设备上安装并配置 Xray 客户端，然后即可流畅地访问互联网。\nmermaid.initialize({startOnLoad:true}); graph LR; A(PC) -.- B(防火墙); B -.- C(墙外网站); A -- D(Xray/VPS); D -- C; A -- E(墙内网站);  一个 Xray 服务器可同时支持多台设备使用不同的代理协议访问。同时，经过合理的配置，Xray 可以识别并区分需要代理以及不需要代理的流量，直连的流量不需要绕路。\n\n桥接模式  如果你不想在每一台设备上都配置路由，你也可以设置一台中转服务器，用于接收客户端发来的所有流量，然后在服务器中进行转发判断。\nmermaid.initialize({startOnLoad:true}); graph LR; A(PC) -.- B(防火墙); B -.- C(墙外网站); A -- D(墙内 VPS); D -- E(墙外 VPS); E -- C; D -- F(墙内网站);  \n工作原理  在配置 Xray 之前，不妨先来看一下 Xray 的工作原理，以下是单个 Xray 进程的内部结构示意图。多个 Xray 之间相互独立，互不影响。\nmermaid.initialize({startOnLoad:true}); graph LR; A1(inbound) -- D(Dispatcher / Router / DNS); A2(inbound) -- D; A3(inbound) -- D; A4(inbound) -- D; D -- B1(outbound); D -- B2(outbound); D -- B3(outbound); D -- B4(outbound);   需要配置至少一个入站连接（Inbound）和一个出站连接（Outbound）才可以正常工作。  入站连接负责与客户端（如浏览器）通信：  入站连接通常可以配置用户认证，如 ID 和密码等； 入站连接收到数据之后，会交给分发器（Dispatcher）进行分发；   出站连接负责将数据发给服务器，如另一台主机上的 Xray。   当有多个出站连接时，可以配置路由（Routing）来指定某一类流量由某一个出站连接发出。  路由会在必要时查询 DNS 以获取更多信息来进行判断。    "},{"uri":"https://xtls.github.io/documents/","title":"使用心得","tags":[],"description":"Project X 的文档.","content":" 这个章节包含各种使用技巧,使用心得,大多来自于实际使用中的经验 小小白白话文 给予新手指导的使用心得\n请点击小小白白话文以进行查看\n 入门技巧 具备了基础之后，你就可以通过入门技巧来探索更多的使用方式了  进阶文档 给予进阶用户指导的使用技巧\n点击进阶文档以进行查看\n  \n致谢非常感谢大家无私分享使用技巧和心得, 使得Xray日益强大.\n "},{"uri":"https://xtls.github.io/guide/document/","title":"使用文档","tags":[],"description":"Project X 的文档.","content":"查看文档   您可以使用左侧的菜单选择您要看的相关分类\n  选择某一项菜单之后, 可以在正文区顶部的导航栏快速切换此分类中的文章.\n   在查看文章时, 可以通过右边的标题列表, 快速切换到其中一个标题.\n   改进文档  Project X 的文档托管在github上.\n您可以通过以下步骤, 提交您对文档的改动:\n  从project X 文档仓库打开仓库, 点击右上角的 fork, fork 一份文档仓库的镜像到您自己的 github 仓库.\n  使用任何您喜欢的工具, 从您克隆的仓库获得文档的克隆, 如:\n    git clone https://github.com/yours/XTLS.github.io   基于 main 分支创建新的分支, 如:    git checkout -b your-branch    在新分支上做修改, 完成后提交修改\n  推送创建的分支到您的仓库\n    git push -u origin your-branch    打开 github, 点击 \u0026lsquo;Pull request\u0026rsquo; 向 project X 文档仓库发出PR.\n  请在 PR 的标题和正文中，概述此次 PR 新增/修改的内容等；\n  等待回应, 如果 PR 被 merge, 您做的修改将直接呈现在 Project X 文档网站。\n  "},{"uri":"https://xtls.github.io/config/base/routing/","title":"路由","tags":[],"description":"Project X 的文档.","content":"路由功能模块可以将入站数据按不同规则由不同的出站连接发出，以达到按需代理的目的。\n如常见用法是分流国内外流量，Xray 可以通过内部机制判断不同地区的流量，然后将它们发送到不同的出站代理。\nRoutingObject  RoutingObject 对应配置文件的 routing 项。\n{ \u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;rules\u0026#34;: [], \u0026#34;balancers\u0026#34;: [] } }  domainStrategy: \u0026ldquo;AsIs\u0026rdquo; | \u0026ldquo;IPIfNonMatch\u0026rdquo; | \u0026ldquo;IPOnDemand\u0026rdquo;\n 域名解析策略，根据不同的设置使用不同的策略。\n \u0026quot;AsIs\u0026quot;：只使用域名进行路由选择。默认值。 \u0026quot;IPIfNonMatch\u0026quot;：当域名没有匹配任何规则时，将域名解析成 IP（A 记录或 AAAA 记录）再次进行匹配；  当一个域名有多个 A 记录时，会尝试匹配所有的 A 记录，直到其中一个与某个规则匹配为止； 解析后的 IP 仅在路由选择时起作用，转发的数据包中依然使用原始域名；   \u0026quot;IPOnDemand\u0026quot;：当匹配时碰到任何基于 IP 的规则，将域名立即解析为 IP 进行匹配；  rules: [RuleObject]\n 对应一个数组，数组中每一项是一个规则。\n对于每一个连接，路由将根据这些规则依次进行判断，当一个规则生效时，即将这个连接转发至它所指定的 outboundTag或 balancerTag。\nTIP\n当没有匹配到任何规则时，流量默认由第一个outbound发出。\n balancers: [ BalancerObject ]\n 一个数组，数组中每一项是一个负载均衡器的配置。\n当一个规则指向一个负载均衡器时，Xray 会通过此负载均衡器选出一个outbound, 然后由它转发流量。\n\nRuleObject  { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;baidu.com\u0026#34;, \u0026#34;qq.com\u0026#34;, \u0026#34;geosite:cn\u0026#34; ], \u0026#34;ip\u0026#34;: [ \u0026#34;0.0.0.0/8\u0026#34;, \u0026#34;10.0.0.0/8\u0026#34;, \u0026#34;fc00::/7\u0026#34;, \u0026#34;fe80::/10\u0026#34;, \u0026#34;geoip:cn\u0026#34; ], \u0026#34;port\u0026#34;: \u0026#34;53,443,1000-2000\u0026#34;, \u0026#34;sourcePort\u0026#34;: \u0026#34;53,443,1000-2000\u0026#34;, \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;source\u0026#34;: [ \u0026#34;10.0.0.1\u0026#34; ], \u0026#34;user\u0026#34;: [ \u0026#34;love@xray.com\u0026#34; ], \u0026#34;inboundTag\u0026#34;: [ \u0026#34;tag-vmess\u0026#34; ], \u0026#34;protocol\u0026#34;: [ \u0026#34;http\u0026#34;, \u0026#34;tls\u0026#34;, \u0026#34;bittorrent\u0026#34; ], \u0026#34;attrs\u0026#34;: \u0026#34;attrs[\u0026#39;:method\u0026#39;] == \u0026#39;GET\u0026#39;\u0026#34;, \u0026#34;outboundTag\u0026#34;: \u0026#34;direct\u0026#34;, \u0026#34;balancerTag\u0026#34;: \u0026#34;balancer\u0026#34; } \nimportant当多个属性同时指定时，这些属性需要 同时 满足，才可以使当前规则生效。\n type: \u0026ldquo;field\u0026rdquo;\n 目前只支持\u0026quot;field\u0026quot;这一个选项。\ndomain: [string]\n 一个数组，数组每一项是一个域名的匹配。有以下几种形式：\n 纯字符串：当此字符串匹配目标域名中任意部分，该规则生效。比如 \u0026ldquo;sina.com\u0026rdquo; 可以匹配 \u0026ldquo;sina.com\u0026rdquo;、\u0026ldquo;sina.com.cn\u0026rdquo; 和\u0026quot;www.sina.com\u0026quot;，但不匹配 \u0026ldquo;sina.cn\u0026rdquo;。 正则表达式：由 \u0026quot;regexp:\u0026quot; 开始，余下部分是一个正则表达式。当此正则表达式匹配目标域名时，该规则生效。例如 \u0026ldquo;regexp:\\\\.goo.*\\\\.com$\u0026rdquo; 匹配\u0026quot;www.google.com\u0026quot;或 \u0026ldquo;fonts.googleapis.com\u0026rdquo;，但不匹配 \u0026ldquo;google.com\u0026rdquo;。 子域名（推荐）：由 \u0026quot;domain:\u0026quot; 开始，余下部分是一个域名。当此域名是目标域名或其子域名时，该规则生效。例如 \u0026ldquo;domain:xray.com\u0026rdquo; 匹配\u0026quot;www.xray.com\u0026quot;、\u0026ldquo;xray.com\u0026rdquo;，但不匹配 \u0026ldquo;wxray.com\u0026rdquo;。 完整匹配：由 \u0026quot;full:\u0026quot; 开始，余下部分是一个域名。当此域名完整匹配目标域名时，该规则生效。例如 \u0026ldquo;full:xray.com\u0026rdquo; 匹配 \u0026ldquo;xray.com\u0026rdquo; 但不匹配\u0026quot;www.xray.com\u0026quot;。 预定义域名列表：由 \u0026quot;geosite:\u0026quot; 开头，余下部分是一个名称，如 geosite:google 或者 geosite:cn。名称及域名列表参考 预定义域名列表。 从文件中加载域名：形如 \u0026quot;ext:file:tag\u0026quot;，必须以 ext:（小写）开头，后面跟文件名和标签，文件存放在 资源目录 中，文件格式与 geosite.dat 相同，标签必须在文件中存在。 TIP\n\u0026quot;ext:geoip.dat:cn\u0026quot; 等价于 \u0026quot;geoip:cn\u0026quot;\n   ip: [string]\n 一个数组，数组内每一项代表一个 IP 范围。当某一项匹配目标 IP 时，此规则生效。有以下几种形式：\n IP：形如 \u0026quot;127.0.0.1\u0026quot;。 CIDR：形如 \u0026quot;10.0.0.0/8\u0026quot;。 预定义IP列表：此列表预置于每一个 Xray 的安装包中，文件名为 geoip.dat。使用方式形如 \u0026quot;geoip:cn\u0026quot;，必须以 geoip:（小写）开头，后面跟双字符国家代码，支持几乎所有可以上网的国家。  特殊值：\u0026quot;geoip:private\u0026quot;，包含所有私有地址，如 127.0.0.1。   从文件中加载 IP：形如 \u0026quot;ext:file:tag\u0026quot;，必须以 ext:（小写）开头，后面跟文件名和标签，文件存放在 资源目录 中，文件格式与 geoip.dat 相同标签必须在文件中存在。  port：number | string\n 目标端口范围，有三种形式：\n \u0026quot;a-b\u0026quot;：a 和 b 均为正整数，且小于 65536。这个范围是一个前后闭合区间，当目标端口落在此范围内时，此规则生效。 a：a 为正整数，且小于 65536。当目标端口为 a 时，此规则生效。 以上两种形式的混合，以逗号 \u0026ldquo;,\u0026rdquo; 分隔。形如：\u0026quot;53,443,1000-2000\u0026quot;。  sourcePort：number | string\n 来源端口，有三种形式：\n \u0026quot;a-b\u0026quot;：a 和 b 均为正整数，且小于 65536。这个范围是一个前后闭合区间，当目标端口落在此范围内时，此规则生效。 a：a 为正整数，且小于 65536。当目标端口为 a 时，此规则生效。 以上两种形式的混合，以逗号 \u0026ldquo;,\u0026rdquo; 分隔。形如：\u0026quot;53,443,1000-2000\u0026quot;。  network: \u0026ldquo;tcp\u0026rdquo; | \u0026ldquo;udp\u0026rdquo; | \u0026ldquo;tcp,udp\u0026rdquo;\n 可选的值有 \u0026ldquo;tcp\u0026rdquo;、\u0026ldquo;udp\u0026rdquo; 或 \u0026ldquo;tcp,udp\u0026rdquo;，当连接方式是指定的方式时，此规则生效。\nsource: [string]\n 一个数组，数组内每一项代表一个 IP 范围，形式有 IP、CIDR、GeoIP 和从文件中加载 IP。当某一项匹配来源 IP 时，此规则生效。\nuser: [string]\n 一个数组，数组内每一项是一个邮箱地址。当某一项匹配来源用户时，此规则生效。\ninboundTag: [string]\n 一个数组，数组内每一项是一个标识。当某一项匹配入站协议的标识时，此规则生效。\nprotocol: [ \u0026ldquo;http\u0026rdquo; | \u0026ldquo;tls\u0026rdquo; | \u0026ldquo;bittorrent\u0026rdquo; ]\n 一个数组，数组内每一项表示一种协议。当某一个协议匹配当前连接的协议类型时，此规则生效。 TIP\n必须开启入站代理中的 sniffing 选项, 才能嗅探出连接所使用的协议类型.\n attrs: string\n 一段脚本，用于检测流量的属性值。当此脚本返回真值时，此规则生效。\n脚本语言为 Starlark，它的语法是 Python 的子集。脚本接受一个全局变量 attrs，其中包含了流量相关的属性。\n目前只有 http 入站代理会设置这一属性。\n示例：\n 检测 HTTP GET：\u0026quot;attrs[':method'] == 'GET'\u0026quot; 检测 HTTP Path：\u0026quot;attrs[':path'].startswith('/test')\u0026quot; 检测 Content Type：\u0026quot;attrs['accept'].index('text/html') \u0026gt;= 0\u0026quot;  outboundTag: string\n 对应一个outbound的标识。\nbalancerTag: string\n 对应一个Balancer的标识。\nTIP\nbalancerTag 和 outboundTag 须二选一。当同时指定时，outboundTag 生效。\n \nBalancerObject  负载均衡器配置。当一个负载均衡器生效时，它会从指定的outbound中，按配置选出一个最合适的outbound，进行流量转发。\n{ \u0026#34;tag\u0026#34;: \u0026#34;balancer\u0026#34;, \u0026#34;selector\u0026#34;: [] }  tag: string\n 此负载均衡器的标识，用于匹配 RuleObject 中的 balancerTag。\nselector: [ string ]\n 一个字符串数组，其中每一个字符串将用于和outbound标识的前缀匹配。在以下几个outbound标识中：[ \u0026quot;a\u0026quot;, \u0026quot;ab\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;ba\u0026quot; ]，\u0026quot;selector\u0026quot;: [\u0026quot;a\u0026quot;] 将匹配到 [ \u0026quot;a\u0026quot;, \u0026quot;ab\u0026quot; ]。\n如果匹配到多个outbound，负载均衡器目前会从中随机选出一个作为最终的outbound。\n\n预定义域名列表  此列表预置于每一个 Xray 的安装包中，文件名为 geosite.dat。这个文件包含了一些常见的域名，使用方式：geosite:filename，如 geosite:google 表示对文件内符合 google 内包含的域名，进行路由筛选或 DNS 筛选。\n常见的域名有：\n category-ads：包含了常见的广告域名。 category-ads-all：包含了常见的广告域名，以及广告提供商的域名。 cn：相当于 geolocation-cn 和 tld-cn 的合集。 apple：包含了 Apple 旗下绝大部分域名。 google：包含了 Google 旗下绝大部分域名。 microsoft：包含了 Microsoft 旗下绝大部分域名。 facebook：包含了 Facebook 旗下绝大部分域名。 twitter：包含了 Twitter 旗下绝大部分域名。 telegram：包含了 Telegram 旗下绝大部分域名。 geolocation-cn：包含了常见的大陆站点域名。 geolocation-!cn：包含了常见的非大陆站点域名，同时包含了 tld-!cn。 tld-cn：包含了 CNNIC 管理的用于中国大陆的顶级域名，如以 .cn、.中国 结尾的域名。 tld-!cn：包含了非中国大陆使用的顶级域名，如以 .hk（香港）、.tw（台湾）、.jp（日本）、.sg（新加坡）、.us（美国）.ca（加拿大）等结尾的域名。  "},{"uri":"https://xtls.github.io/documents/level-2/","title":"进阶文档","tags":[],"description":"Project X 的文档.","content":" 这个章节包含进阶级的Xray使用心得分享, 如果您已经熟悉Xray, 那么这里的经验可以让您更加发挥Xray的威力 \n 透明代理入门 by @kirin\n 透明代理（TProxy）的入门篇章。\n 透明代理（TProxy）配置教程  by @BioniCosmos\n 基于Xray的透明代理（TProxy）配置完整教程。\n [透明代理]通过gid规避Xray流量 by @kirin\n 在iptables/nftables实现的透明代理中，一种新的规避Xray流量的方式。\n"},{"uri":"https://xtls.github.io/faq/tproxy/","title":"透明代理相关问题","tags":[],"description":"Project X 的文档.","content":" Q: 我搭建了透明代理给我和我同宿舍/隔壁宿舍的同学用, 日志中出现很多 too many open files .怎么办? 急,在线等.让你的同学少用BT过代理下载American Video 在 /etc/systemd/system/xray.service 的 [Service] 下加 LimitNPROC=10000 和 LimitNOFILE=1000000.\n Q: sniffing的具体功能是什么，什么时候发挥作用?sniffing流量探测主要作用是用在透明代理等用途.\n他的一个典型工作流程是这样的.\n比如你有一个设备上网,去访问abc.com, 首先设备通过DNS查询得到abc.com的IP是1.2.3.4,然后设备会向1.2.3.4发起连接.\n 透明代理不设置嗅探的话,收到的连接请求是1.2.3.4,是不能走域名规则的路由分流的. 透明代理设置了sniffing,处理这个流量时,会从这个流量的数据中,嗅探出域名,abc.com. 然后把1.2.3.4重置为abc.com. 路由就可以根据域名进行符合域名规则的分流, 或者做更多的事情.  因为变成了一个向abc.com请求的连接,就可以做更多的事情,包括路由域名规则分流, 重新做DNS解析等等\u0026hellip;\n另一个sniffing的作用是可以嗅探BT流量的标识,把流量归类成BT类型. 然后可以在路由中根据BT类型来做规则,比如服务端用来拦截BT流量,比如客户端把BT流量固定发送到某个VPS去代理等.\n "},{"uri":"https://xtls.github.io/documents/level-0/ch05-webpage/","title":"【第5章】网站建设篇","tags":[],"description":"小小白白话文","content":"5.1 为什么要做一个网站？  新人也许会迷惑，为什么科学上网还要建一个网站？我不会编程啊，是不是特别麻烦？\n先回答第一个问题，建网站的原因有：\n 申请合法的TLS证书（非常重要） 提供合理的回落，防止主动探测攻击，提高安全性 建设一个伪装站（如博客、私人网盘、多媒体网站、游戏网站等），直接访问时有合理的前台，使流量使用看上去更合理。  再回答第二个问题：\n 本文作为演示，仅仅使用了一个最简单的【单文件html页面 + Nginx】来搭建，以此完成上面的目标，所以【非常简单】 这个网站完全可以不仅仅是伪装，而是真的做大做强，这个复杂性就完全取决于你了 对于“伪装”和“网站运营”这个目标，需要的就是各不相同、秀出真我，需要的同学可以自行搜索学习。这个内容已经完全偏离了科学上网，本文就不深入解析了。   5.2 登录VPS、安装运行Nginx    这里用到的，都是之前已经详解过的命令，所以就不重复讲解了。看不懂的同学可以看看前面的章节哦。\n$ sudo apt update \u0026amp;\u0026amp; sudo apt install nginx   完成后，Nginx已经自动运行。此时打开Windows上的浏览器并输入 http://100.200.300.400:80，若看到下图的界面就说明Nginx已经正常在运行了。\n   5.3 创建一个最简单的网页    小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-10 mkdir 新建文件夹   cmd-11 systemctl reload 重新加载某个服务      小小白白Linux基础配置文件：\n   编号 配置文件位置 文件说明     conf-02 /etc/nginx/nginx.conf Nginx程序设置      创建一个网站专用的文件夹/home/vpsadmin/www/webpage/并建立网页文件index.html\n$ mkdir -p ~/www/webpage/ \u0026amp;\u0026amp; nano ~/www/webpage/index.html  注意： 如果你用的不是 vpsadmin 这个用户名，请务必理解这条命令中 “~” 符号的意义（这关系到【第5步】你要写的内容）：\n 如果是 【非 root 用户】，“~” 就等价于 /home/用户名 如果是 【 root 用户】，“~” 就等价于 /root     把下面的内容完整的复制进去，然后保存(ctrl+o)退出(ctrl+x)\n\u0026lt;html\u0026gt; \u0026lt;!-- Text between angle brackets is an HTML tag and is not displayed. Most tags, such as the HTML and /HTML tags that surround the contents of a page, come in pairs; some tags, like HR, for a horizontal rule, stand alone. Comments, such as the text you\u0026#39;re reading, are not displayed when the Web page is shown. The information between the HEAD and /HEAD tags is not displayed. The information between the BODY and /BODY tags is displayed.--\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Enter a title, displayed at the top of the window.\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;!-- The information between the BODY and /BODY tags is displayed.--\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Enter the main heading, usually the same as the title.\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Be \u0026lt;b\u0026gt;bold\u0026lt;/b\u0026gt; in stating your key points. Put them in a list: \u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;The first item in your list\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;The second item; \u0026lt;i\u0026gt;italicize\u0026lt;/i\u0026gt; key words\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;p\u0026gt;Improve your image by including an image. \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;img src=\u0026#34;https://i.imgur.com/SEBww.jpg\u0026#34; alt=\u0026#34;A Great HTML Resource\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Add a link to your favorite \u0026lt;a href=\u0026#34;https://www.dummies.com/\u0026#34;\u0026gt;Web site\u0026lt;/a\u0026gt;. Break up your page with a horizontal rule or two. \u0026lt;/p\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;p\u0026gt;Finally, link to \u0026lt;a href=\u0026#34;page2.html\u0026#34;\u0026gt;another page\u0026lt;/a\u0026gt; in your own Web site.\u0026lt;/p\u0026gt; \u0026lt;!-- And add a copyright notice.--\u0026gt; \u0026lt;p\u0026gt;\u0026amp;#169; Wiley Publishing, 2011\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   修改 nginx.conf 并重启 Nginx 服务，将80端口的http访问定位到刚才建立的 html 页面上\n  修改 nginx.conf 。\n$ sudo nano /etc/nginx/nginx.conf   将下面一段，添加在 http{} 内，然后保存(ctrl+o)退出(ctrl+x)。（记得将域名替换为之前准备好的、包含二级域名的真实域名）\nserver { listen 80; server_name 二级域名.你的域名.com; root /home/vpsadmin/www/webpage; index index.html; }  特别注意！ 如我在【第3步】中的提示所说，请务必确保 /home/vpsadmin/www/webpage 改成你的实际文件路径。\n   让 nginx 重新载入配置使其生效\n$ sudo systemctl reload nginx   完整的设置流程如下：\n  此时如果你访问 http://二级域名.你的域名.com，你看到这样的页面则说明成功：\n     5.4 常见错误的说明 首先，如果你一路按照文章的说明来操作，并且足够细心，那肯定不会出错。所以，我并不打算修改本文的写法。\n那为什么依然有很多同学卡在了这一步，网页怎么也打不开呢？基本上就是两个字：粗心。因为这里配置可能出现的问题只有两种，原因也只有两个。\n一、两种问题：\n nginx.conf 里面的 /home/vpsadmin/www/webpage 这一条，与你的实际文件路径不符，nginx 找不到文件 路径正确，但 nginx 无权读取  二、两个原因：\n 使用了【非 root 用户】，但仍然直接拷贝文中的命令不加修改。（这基本就等于抄答案时把同学的名字一起抄过去了） 坚持使用【 root 用户】  碰到错误的同学，就回过头仔细看一下【5.3】中【第3步】和【第5-2步】的说明吧。\n本文前期已经用了大量篇幅说明了使用【非 root 用户】对安全的重要性，全文也是基于此而写。所以，因使用【 root 用户】而导致的问题并不在本文的设计范围里。\n但我相信，坚持使用【 root 用户】的同学应该是有主见、动手能力强、或者有一定 Linux 基础的同学。问题的症结我已经全部说明了，我相信你一定可以自行解决。\n  5.5 你的进度  至此，Xray的第一个基础设施【网页】已经就位，我们马上就进入第二个基础设施【证书】吧！\nPROGRESS⬛⬛⬛⬛⬛⬜⬜⬜ 62.5%\n "},{"uri":"https://xtls.github.io/config/transports/h2/","title":"HTTP/2","tags":[],"description":"Project X 的文档.","content":"基于 HTTP/2 的传输方式。\n它完整按照 HTTP/2 标准实现，可以通过其它的 HTTP 服务器（如 Nginx）进行中转。\n由 HTTP/2 的建议，客户端和服务器必须同时开启 TLS 才可以正常使用这个传输方式。\nTIP\n当前版本的 HTTP/2 的传输方式并不强制要求服务器端有 TLS 配置.\n这使得可以在特殊用途的分流部署环境中，由外部网关组件完成 TLS 层对话，Xray 作为后端应用，网关和 Xray 间使用称为 h2c 的明文 http/2 进行通讯。\n HttpObject  HttpObject 对应传输配置的 httpSettings 项。\n{ \u0026#34;host\u0026#34;: [\u0026#34;xray.com\u0026#34;], \u0026#34;path\u0026#34;: \u0026#34;/random/path\u0026#34; }  host: [string]\n 一个字符串数组，每一个元素是一个域名。\n客户端会随机从列表中选出一个域名进行通信，服务器会验证域名是否在列表中。\npath string\n HTTP 路径，由 / 开头, 客户端和服务器必须一致。\n默认值为 \u0026quot;/\u0026quot;。\n"},{"uri":"https://xtls.github.io/config/inbound-protocols/","title":"Inbounds 可用协议列表","tags":[],"description":"Project X 的文档.","content":" 这个章节包含了目前所有可用于 Inbounds 的协议及具体配置细节. 协议列表   Dokodemo-door\n Dokodemo door（任意门）可以监听一个本地端口，并把所有进入此端口的数据发送至指定服务器的一个端口，从而达到端口映射的效果。 HTTP\n HTTP 协议 Socks\n 标准 Socks 协议实现，兼容 Socks 4、Socks 4a 和 Socks 5。 VLESS\n VLESS 是一个无状态的轻量传输协议，可以作为 Xray 客户端和服务器之间的桥梁。 VMess\n VMess 是一个加密传输协议，，可以作为 Xray 客户端和服务器之间的桥梁。 Trojan\n Trojan 协议 Shadowsocks\n Shadowsocks 协议。\n"},{"uri":"https://xtls.github.io/config/outbound-protocols/socks/","title":"Socks","tags":[],"description":"Project X 的文档.","content":"标准 Socks 协议实现，兼容 Socks 4、Socks 4a 和 Socks 5。\nimportantsocks 协议没有对传输加密，不适宜经公网中传输\nsocks inbound 更有意义的用法是在局域网或本机环境下监听，为其他程序提供本地服务。\n OutboundConfigurationObject  { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;test user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;test pass\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }  servers: [ ServerObject ]\n Socks 服务器列表，其中每一项是一个服务器配置。\nServerObject { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;test user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;test pass\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] }  address: address\n 服务器地址, 必填\nTIP\n仅支持连接到 Socks 5 服务器。\n port: number\n 服务器端口, 必填\nusers: [ UserObject ]\n 一个数组表示的用户列表，数组中每个元素为一个用户配置。\n当列表不为空时，Socks 客户端会使用用户信息进行认证；如未指定，则不进行认证。\n默认值为空。\n\nUserObject  { \u0026#34;user\u0026#34;: \u0026#34;test user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;test pass\u0026#34;, \u0026#34;level\u0026#34;: 0 }  user: string\n 用户名，字符串类型。必填。\npass: string\n 密码，字符串类型。必填。\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0\n"},{"uri":"https://xtls.github.io/config/inbound-protocols/vless/","title":"VLESS","tags":[],"description":"Project X 的文档.","content":" important目前 VLESS 没有自带加密，请用于可靠信道，如 TLS。 目前 VLESS 不支持分享。\n VLESS 是一个无状态的轻量传输协议，它分为入站和出站两部分，可以作为 Xray 客户端和服务器之间的桥梁。\n与 VMess 不同，VLESS 不依赖于系统时间，认证方式同样为 UUID，但不需要 alterId。\nInboundConfigurationObject { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34; } ], \u0026#34;decryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;fallbacks\u0026#34;: [ { \u0026#34;dest\u0026#34;: 80 } ] }  clients: [ ClientObject ]\n 一个数组，代表一组服务端认可的用户.\n其中每一项是一个用户 ClientObject。\n decryption: \u0026ldquo;none\u0026rdquo;\n 现阶段需要填 \u0026quot;none\u0026quot;，不能留空。 若未正确设置 decryption 的值，使用 Xray 或 -test 时会收到错误信息。\n注意这里是 decryption，和 clients 同级。 decryption 和 vmess 协议的 encryption 的位置不同，是因为若套一层约定加密，服务端需要先解密才能知道是哪个用户。\nfallbacks: [ FallbackObject ]\n 一个数组，包含一系列强大的回落分流配置（可选）。\nfallbacks 的具体配置请点击FallbackObject\n ClientObject  { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34; }  id: string\n VLESS 的用户 ID，可以是任意小于30字节的字符串, 也可以是一个合法的UUID.  自定义字符串和其映射的 UUID 是等价的, 这意味着你将可以这样在配置文件中写id来标识同一用户,即\n 写 \u0026ldquo;id\u0026rdquo;: \u0026ldquo;我爱🍉老师1314\u0026rdquo;, 或写 \u0026ldquo;id\u0026rdquo;: \u0026ldquo;5783a3e7-e373-51cd-8642-c83782b807c5\u0026rdquo; (此UUID是 我爱🍉老师1314 的 UUID 映射)  其映射标准在VLESS UUID 映射标准：将自定义字符串映射为一个 UUIDv5\n你可以使用命令 xray uuid -map \u0026quot;自定义字符串\u0026quot; 生成自定义字符串所映射的的 UUID. 也可以使用命令 xray uuid 生成随机的UUID.\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nemail: string\n 用户邮箱，用于区分不同用户的流量（会体现在日志、统计中）。\nflow: string\n 流控模式，用于选择 XTLS 的算法。\n目前入站协议中有以下流控模式可选：\n xtls-rprx-origin：最初的流控模式，此时客户端仅可选择 xtls-rprx-origin 和 xtls-rprx-origin-udp443 这两种流控模式。该模式纪念价值大于实际使用价值 xtls-rprx-direct：推荐，所有平台皆可使用的典型流控方式，此时客户端可选择任何流控模式  注意\n当 flow 被指定时，还需要将该入站协议的 streamSettings.security 一项指定为 xtls，tlsSettings 改为 xtlsSettings。详情请参考 streamSettings。\n此外，目前 XTLS 仅支持 TCP、mKCP、DomainSocket 这三种传输方式。\n "},{"uri":"https://xtls.github.io/faq/fallback/","title":"回落相关问题","tags":[],"description":"Project X 的文档.","content":" Q: 回落是个啥?好吃吗?Fallback 是 Xray 的最强大功能之一, 可有效防止主动探测, 自由配置常用端口多服务共享\n点此查看详情 回落\n Q: 为什么我回落以后nginx日志的IP是 127.0.0.1?需要开启 proxy protocol. 参见fallbacks配置的xver参数\n Q: 我还是上一题的提问者, 那么我如何使用proxy protocol,达到所有日志都有源IP的目的呢?等待好心人写一篇小小白白话文\n Q: Wordpress 是 Mixed Content, 回落到配置的Wordpress看起来怪怪的, 怎么办?@Ardentwheel :\n需要在nginx的配置中加入以下内容，才可以修复\nadd_header Content-Security-Policy \u0026#34;upgrade-insecure-requests\u0026#34;; \n "},{"uri":"https://xtls.github.io/develop/","title":"开发指南","tags":[],"description":"Project X 的文档.","content":"In progress\n"},{"uri":"https://xtls.github.io/config/base/policy/","title":"本地策略","tags":[],"description":"Project X 的文档.","content":"本地策略，可以设置不同的用户等级和对应的策略设置，比如连接超时设置。Xray 处理的每一个连接都对应一个用户，按照用户的等级（level）应用不同的策略。\nPolicyObject  PolicyObject 对应配置文件的 policy 项。\n{ \u0026#34;policy\u0026#34;: { \u0026#34;levels\u0026#34;: { \u0026#34;0\u0026#34;: { \u0026#34;handshake\u0026#34;: 4, \u0026#34;connIdle\u0026#34;: 300, \u0026#34;uplinkOnly\u0026#34;: 2, \u0026#34;downlinkOnly\u0026#34;: 5, \u0026#34;statsUserUplink\u0026#34;: false, \u0026#34;statsUserDownlink\u0026#34;: false, \u0026#34;bufferSize\u0026#34;: 4 } }, \u0026#34;system\u0026#34;: { \u0026#34;statsInboundUplink\u0026#34;: false, \u0026#34;statsInboundDownlink\u0026#34;: false, \u0026#34;statsOutboundUplink\u0026#34;: false, \u0026#34;statsOutboundDownlink\u0026#34;: false } } }  level: map{string: LevelPolicyObject}\n 一组键值对，每个键是一个字符串形式的数字（JSON 的要求），比如 \u0026quot;0\u0026quot;、\u0026quot;1\u0026quot; 等，双引号不能省略，此数字对应用户等级。每一个值是一个 LevelPolicyObject.\nTIP\n每个入站出站代理现在都可以设置用户等级，Xray 会根据实际的用户等级应用不同的本地策略。\n system: SystemPolicyObject\n Xray系统级别的策略\n\nLevelPolicyObject  { \u0026#34;handshake\u0026#34;: 4, \u0026#34;connIdle\u0026#34;: 300, \u0026#34;uplinkOnly\u0026#34;: 2, \u0026#34;downlinkOnly\u0026#34;: 5, \u0026#34;statsUserUplink\u0026#34;: false, \u0026#34;statsUserDownlink\u0026#34;: false, \u0026#34;bufferSize\u0026#34;: 10240 }  handshake: number\n 连接建立时的握手时间限制。单位为秒。默认值为 4。在入站代理处理一个新连接时，在握手阶段如果使用的时间超过这个时间，则中断该连接。\nconnIdle: number\n 连接空闲的时间限制。单位为秒。默认值为 300。inbound/outbound处理一个连接时，如果在 connIdle 时间内，没有任何数据被传输（包括上行和下行数据），则中断该连接。\nuplinkOnly: number\n 当连接下行线路关闭后的时间限制。单位为秒。默认值为 2。当服务器（如远端网站）关闭下行连接时，出站代理会在等待 uplinkOnly 时间后中断连接。\ndownlinkOnly: number\n 当连接上行线路关闭后的时间限制。单位为秒。默认值为 5。当客户端（如浏览器）关闭上行连接时，入站代理会在等待 downlinkOnly 时间后中断连接。\nTIP\n在 HTTP 浏览的场景中，可以将 uplinkOnly 和 downlinkOnly 设为 0，以提高连接关闭的效率。\n statsUserUplink: true | false\n 当值为 true 时，开启当前等级的所有用户的上行流量统计。\nstatsUserDownlink: true | false\n 当值为 true 时，开启当前等级的所有用户的下行流量统计。\nbufferSize: number\n 每个连接的内部缓存大小。单位为 kB。当值为 0 时，内部缓存被禁用。\n默认值:\n 在 ARM、MIPS、MIPSLE 平台上，默认值为 0。 在 ARM64、MIPS64、MIPS64LE 平台上，默认值为 4。 在其它平台上，默认值为 512。  TIP\nbufferSize 选项会覆盖 环境变量中 Xray.ray.buffer.size 的设定。\n -- \nSystemPolicyObject  { \u0026#34;statsInboundUplink\u0026#34;: false, \u0026#34;statsInboundDownlink\u0026#34;: false, \u0026#34;statsOutboundUplink\u0026#34;: false, \u0026#34;statsOutboundDownlink\u0026#34;: false }  statsInboundUplink: true | false\n 当值为 true 时，开启所有入站代理的上行流量统计。 statsInboundDownlink: true | false\n 当值为 true 时，开启所有入站代理的下行流量统计。 statsOutboundUplink: true | false\n 当值为 true 时，开启所有出站代理的上行流量统计。 statsOutboundDownlink: true | false\n 当值为 true 时，开启所有出站代理的下行流量统计。\n"},{"uri":"https://xtls.github.io/documents/level-0/ch06-certificates/","title":"【第6章】证书管理篇","tags":[],"description":"小小白白话文","content":"6.1 申请TLS证书  接下来我们要做的，是为我们的域名申请一个真实的TLS证书，使网站具备标准TLS加密的能力及HTTPS访问的能力。这就是Xray等现阶段安全代理工具确保流量充分加密最重要的工具。\n注意： 请不要轻易使用自签证书。它并没有让操作简单太多，但增加了无谓的风险（如中间人攻击）。\n 这里我会使用一个叫做 acme.sh 的证书管理工具，它简单、轻量、高效，并可完成证书自动更新。\n另外，我相信，现在你已经逐渐熟悉了Linux的基础操作，所以已经多次出现的命令从本章开始不再重复截图、只做简单的描述。如果实在想不起来怎么用的话，就稍微复习一下前面的章节吧。\n 6.2 安装 acme.sh    小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-12 wget 访问（或下载）某个网页文件   cmd-13 acme.sh acme.sh证书管理相关的命令      运行安装脚本\n$ wget -O - https://get.acme.sh | sh   让 acme.sh 命令生效\n$ . .bashrc   开启 acme.sh 的自动升级\n$ acme.sh --upgrade --auto-upgrade   到这一步的完整流程如下图：\n   6.3 测试证书申请 在正式申请证书之前，我们先用测试命令(--issue --test)来验证是否可以成功申请，这样可以避免在本地配置有误时，反复申请证书失败，超过 Let\u0026rsquo;s Encrypt 的频率上限（比如，每小时、每个域名、每个用户失败最多5次），导致后面的步骤无法进行。\n  测试证书申请的命令如下（本文均以 ECC 证书为例，因为时至今日，实在没什么理由不用它）：\n$ acme.sh --issue --test -d 二级域名.你的域名.com -w /home/vpsadmin/www/webpage --keylength ec-256  说明： ECC证书的主要优势在于它的Keysize更小，意味着同等大小下安全性的提升和加密解密速度的加快。如 ECC-256bit 的强度大约相当于 RSA-3072bit，何乐而不为呢？当然，有人说ECC证书握手会明显更快，这我觉得就有些夸张了，因为RSA握手也没有太慢，就算有差别应该也是毫秒级，很难直接感知。\n另外，如果有些网站确实需要兼容某些古老设备的，那也还是请按需选择RSA证书。\n   你最终应该看到类似这样的提示：\n[Wed 30 Dec 2022 04:25:12 AM EST] Using ACME_DIRECTORY: https://acme-staging-v02.api.letsencrypt.org/directory [Wed 30 Dec 2022 04:25:13 AM EST] Using CA: https://acme-staging-v02.api.letsencrypt.org/directory [Wed 30 Dec 2022 04:25:13 AM EST] Create account key ok. [Wed 30 Dec 2022 04:25:13 AM EST] Registering account: https://acme-staging-v02.api.letsencrypt.org/directory [Wed 30 Dec 2022 04:25:13 AM EST] Registered [Wed 30 Dec 2022 04:25:13 AM EST] ACCOUNT_THUMBPRINT=\u0026#39;CU6qmPKuRqhyTAIrF4swosR375194z_1ddUlWef8xDc\u0026#39; [Wed 30 Dec 2022 04:25:13 AM EST] Creating domain key [Wed 30 Dec 2022 04:25:13 AM EST] The domain key is here: /home/vpsadmin/.acme.sh/二级域名.你的域名.com_ecc/二级域名.你的域名.com.key [Wed 30 Dec 2022 04:25:13 AM EST] Single domain=\u0026#39;二级域名.你的域名.com\u0026#39; [Wed 30 Dec 2022 04:25:13 AM EST] Getting domain auth token for each domain [Wed 30 Dec 2022 04:25:14 AM EST] Getting webroot for domain=\u0026#39;二级域名.你的域名.com\u0026#39; [Wed 30 Dec 2022 04:25:14 AM EST] Verifying: 二级域名.你的域名.com [Wed 30 Dec 2022 04:25:23 AM EST] Pending [Wed 30 Dec 2022 04:25:25 AM EST] Success [Wed 30 Dec 2022 04:25:25 AM EST] Verify finished, start to sign. [Wed 30 Dec 2022 04:25:25 AM EST] Lets finalize the order. [Wed 30 Dec 2022 04:25:25 AM EST] Le_OrderFinalize=\u0026#39;https://acme-staging-v02.api.letsencrypt.org/acme/finalize/490205995/7730242871\u0026#39; [Wed 30 Dec 2022 04:25:25 AM EST] Downloading cert. [Wed 30 Dec 2022 04:25:25 AM EST] Le_LinkCert=\u0026#39;https://acme-staging-v02.api.letsencrypt.org/acme/cert/xujss5xt8i38waubafz2xujss5xt8i38waubz2\u0026#39; [Wed 30 Dec 2022 15:21:52 AM EST] Cert success. -----BEGIN CERTIFICATE----- sxlYqPvWreKgD5b8JyOQX0Yg2MLoRUoDyqVkd31PthIiwzdckoh5eD3JU7ysYBtN cTFK4LGOfjqi8Ks87EVJdK9IaSAu7ZC6h5to0eqpJ5PLhaM3e6yJBbHmYA8w1Smp wAb3tdoHZ9ttUIm9CrSzvDBt6BBT6GqYdDamMyCYBLooMyDEM4CUFsOzCRrEqqvC 2mTTEmhvpojo5rhdTSJxibozyNWTGwoTj0v9pTUeQcGqLIzqi4DowjBHD5guwRid SjAFnm6JT2xUQgWFm58A1gv1OhbH1TRPUUmtE1nFEN7YiSjI4xgxqAXT3CLD2EUb wXlUrO6c75zSsQP4bRMzgOjJUqHtSb6IEqELzt4M7KzL5iCOruCChCo2DZxUwvVX tOoaAyQJzCbTqE6aUqwiKi3gVyoxvDP9mI5JdRYzsDL6GVud7EHPnYeMl9ubLZAK 0vg84mbMP3f6mYM4KRa1cqiyOIcQPT4AzGFYVv4sm049bZQg7sd0Bz9CaFvE7yDA 1y17XlgCDnsjxl66bqI1vkENN9XT5xeFHONqc18b5fZEKSIvdX7iWPFWp1PyMPpG 0pMCP1EymZNFxIMJLgbWqExwLWfPc5Ib3PjBaIqhXPnw6sT2MQSxXwDupq1UJVhV 7E3hQRVlwI4CXi6WLHJMNvNRyyK87gCrLH1bKYsPeRVaz77poWBq49zwBCts6hPY IeF4ltGXyANNIOPEi8vy138fRU4LYh81d8FjOtFfJZogMjwhfNvapqxPMsioPlmX TnZu0n7setrVNUEfTMHWqPpDgk5MPrWLA4LapqaDfEX4pwnQJLMwMi6s94z165c0 iMRSKA1yU5zqv8aNsDfPoY4OkSPWs4MaXgRRSLBsUfZ15DwQXPk76kegHIyxWvwF tYw9HKR5QCMK66fa0z4aJoFVFLK0IIOGEZOanRFUCnkLUDd3QZ3YU8lEcrj7Uxos haiRNICyC6UfsCJ94a8vcNyMosPv3xBLMp19WXgiFYqEFQkntkv1FLRI35fjeJmg 0fmD9VG9bkzGPHihJgQLRlCHasGf6XrdfkSsODAyCUHUHJ0RzqF4YEZMcxDxzuQ2 YO7bFwj7S3mUdVPZ6MPasjxdyBjJgEBMch2uy4AhmudXfEBQBye8W6ZI4ztZjLVV FmP4SIuaNUmMe20TjR8b9NVC96AhxOanWT3mRROsdokpKQGTJvl27EHH8KuAbUOc G6KtPy4wslNZNXWcBy9n63RcWak12r7kAIFn38tZxmlw2WUKoRSMAH64GcDTjRQd Am65hBHzvGrj93wEuVNIebvNIsJOlng3HFjpIxVqKGMCIfWIKGDE3YzK3p4LbGZ6 NZFQWYJLNVf2M9CCJfbEImPYgvctrxl39H6KVYPCw1SAdaj9NneUqmREOQkKoEB0 x6PmNirbMscHhQPSC0JQaqUgaQFgba1ALmzRYAnYhNb0twkTxWbY7DBkAarxqMIp yiLKcBFc5H7dgJCImo7us7aJeftC44uWkPIjw9AKH= -----END CERTIFICATE----- [Wed 30 Dec 2022 15:21:52 AM EST] Your cert is in /home/vpsadmin/.acme.sh/二级域名.你的域名.com_ecc/二级域名.你的域名.com.cer [Wed 30 Dec 2022 15:21:52 AM EST] Your cert key is in /home/vpsadmin/.acme.sh/二级域名.你的域名.com_ecc/二级域名.你的域名.com.key [Wed 30 Dec 2022 15:21:52 AM EST] The intermediate CA cert is in /home/vpsadmin/.acme.sh/二级域名.你的域名.com_ecc/ca.cer [Wed 30 Dec 2022 15:21:52 AM EST] And the full chain certs is there: /home/vpsadmin/.acme.sh/二级域名.你的域名.com_ecc/fullchain.cer   注意：这里申请的是测试证书，没办法直接用的，只是用来证明你的域名、配置全都正确。仔细观察，你会发现给你发证书的域名是 https://acme-staging-v02.api.letsencrypt.org，这个 staging 你就理解成【测试服】吧！\n  如果这一步出错的话，你可以运行下面的命令，来查看详细的申请过程和具体的错误。（看不懂就隐藏掉敏感信息后，去Xray群里问吧）\n$ acme.sh --issue --test -d 二级域名.你的域名.com -w /home/vpsadmin/www/webpage --keylength ec-256 --debug 嗯没错，就是在命令的最后加了一个 --debug 参数\n  这一步确定成功之后，就可以申请正式的证书了。（测试证书不需要删除，它会自动被正式证书覆盖）\n   6.4 正式证书申请    申请正式证书的命令如下（即删掉 --test 参数，并在最后加入 --force参数）：\n$ acme.sh --issue -d 二级域名.你的域名.com -w /home/vpsadmin/www/webpage --keylength ec-256 --force  说明： --force 参数的意思就是，在现有证书到期前，手动（强行）更新证书。上一步我们从“测试服”申请的证书虽然不能直接用，但是它本身是尚未过期的，所以需要用到这个参数。\n   你最终应该看到跟上面很像的提示：\nvpsadmin@vps-server:~$ acme.sh --issue -d 二级域名.你的域名.com -w /home/vpsadmin/www/webpage --keylength ec-256 [Wed 30 Dec 2022 15:22:51 AM EST] Using CA: https://acme-v02.api.letsencrypt.org/directory [Wed 30 Dec 2022 15:22:51 AM EST] Creating domain key [Wed 30 Dec 2022 15:22:51 AM EST] The domain key is here: /home/vpsadmin/.acme.sh/二级域名.你的域名.com_ecc/二级域名.你的域名.com.key [Wed 30 Dec 2022 15:22:51 AM EST] Single domain=\u0026#39;二级域名.你的域名.com\u0026#39; [Wed 30 Dec 2022 15:22:51 AM EST] Getting domain auth token for each domain [Wed 30 Dec 2022 15:22:51 AM EST] Getting webroot for domain=\u0026#39;二级域名.你的域名.com\u0026#39; [Wed 30 Dec 2022 15:22:51 AM EST] Verifying: 二级域名.你的域名.com [Wed 30 Dec 2022 15:22:51 AM EST] Pending [Wed 30 Dec 2022 15:22:51 AM EST] Success [Wed 30 Dec 2022 15:22:51 AM EST] Verify finished, start to sign. [Wed 30 Dec 2022 15:22:51 AM EST] Lets finalize the order. [Wed 30 Dec 2022 15:22:51 AM EST] Le_OrderFinalize=\u0026#39;https://acme-v02.api.letsencrypt.org/acme/finalize/490205996/7730242872\u0026#39; [Wed 30 Dec 2022 15:22:51 AM EST] Downloading cert. [Wed 30 Dec 2022 15:22:51 AM EST] Le_LinkCert=\u0026#39;https://acme-v02.api.letsencrypt.org/acme/cert/vsxvk0oldnuobe51ayxz4dms62sk2dwmw9zhuw\u0026#39; [Wed 30 Dec 2022 15:22:51 AM EST] Cert success. -----BEGIN CERTIFICATE----- sxlYqPvWreKgD5b8JyOQX0Yg2MLoRUoDyqVkd31PthIiwzdckoh5eD3JU7ysYBtN cTFK4LGOfjqi8Ks87EVJdK9IaSAu7ZC6h5to0eqpJ5PLhaM3e6yJBbHmYA8w1Smp wAb3tdoHZ9ttUIm9CrSzvDBt6BBT6GqYdDamMyCYBLooMyDEM4CUFsOzCRrEqqvC 2mTTEmhvpojo5rhdTSJxibozyNWTGwoTj0v9pTUeQcGqLIzqi4DowjBHD5guwRid SjAFnm6JT2xUQgWFm58A1gv1OhbH1TRPUUmtE1nFEN7YiSjI4xgxqAXT3CLD2EUb wXlUrO6c75zSsQP4bRMzgOjJUqHtSb6IEqELzt4M7KzL5iCOruCChCo2DZxUwvVX tOoaAyQJzCbTqE6aUqwiKi3gVyoxvDP9mI5JdRYzsDL6GVud7EHPnYeMl9ubLZAK 0vg84mbMP3f6mYM4KRa1cqiyOIcQPT4AzGFYVv4sm049bZQg7sd0Bz9CaFvE7yDA 1y17XlgCDnsjxl66bqI1vkENN9XT5xeFHONqc18b5fZEKSIvdX7iWPFWp1PyMPpG 0pMCP1EymZNFxIMJLgbWqExwLWfPc5Ib3PjBaIqhXPnw6sT2MQSxXwDupq1UJVhV 7E3hQRVlwI4CXi6WLHJMNvNRyyK87gCrLH1bKYsPeRVaz77poWBq49zwBCts6hPY IeF4ltGXyANNIOPEi8vy138fRU4LYh81d8FjOtFfJZogMjwhfNvapqxPMsioPlmX TnZu0n7setrVNUEfTMHWqPpDgk5MPrWLA4LapqaDfEX4pwnQJLMwMi6s94z165c0 iMRSKA1yU5zqv8aNsDfPoY4OkSPWs4MaXgRRSLBsUfZ15DwQXPk76kegHIyxWvwF tYw9HKR5QCMK66fa0z4aJoFVFLK0IIOGEZOanRFUCnkLUDd3QZ3YU8lEcrj7Uxos haiRNICyC6UfsCJ94a8vcNyMosPv3xBLMp19WXgiFYqEFQkntkv1FLRI35fjeJmg 0fmD9VG9bkzGPHihJgQLRlCHasGf6XrdfkSsODAyCUHUHJ0RzqF4YEZMcxDxzuQ2 YO7bFwj7S3mUdVPZ6MPasjxdyBjJgEBMch2uy4AhmudXfEBQBye8W6ZI4ztZjLVV FmP4SIuaNUmMe20TjR8b9NVC96AhxOanWT3mRROsdokpKQGTJvl27EHH8KuAbUOc G6KtPy4wslNZNXWcBy9n63RcWak12r7kAIFn38tZxmlw2WUKoRSMAH64GcDTjRQd Am65hBHzvGrj93wEuVNIebvNIsJOlng3HFjpIxVqKGMCIfWIKGDE3YzK3p4LbGZ6 NZFQWYJLNVf2M9CCJfbEImPYgvctrxl39H6KVYPCw1SAdaj9NneUqmREOQkKoEB0 x6PmNirbMscHhQPSC0JQaqUgaQFgba1ALmzRYAnYhNb0twkTxWbY7DBkAarxqMIp yiLKcBFc5H7dgJCImo7us7aJeftC44uWkPM= -----END CERTIFICATE----- [Wed 30 Dec 2022 15:22:52 AM EST] Your cert is in /home/vpsadmin/.acme.sh/二级域名.你的域名.com_ecc/二级域名.你的域名.com.cer [Wed 30 Dec 2022 15:22:52 AM EST] Your cert key is in /home/vpsadmin/.acme.sh/二级域名.你的域名.com_ecc/二级域名.你的域名.com.key [Wed 30 Dec 2022 15:22:52 AM EST] The intermediate CA cert is in /home/vpsadmin/.acme.sh/二级域名.你的域名.com_ecc/ca.cer [Wed 30 Dec 2022 15:22:52 AM EST] And the full chain certs is there: /home/vpsadmin/.acme.sh/二级域名.你的域名.com_ecc/fullchain.cer   仔细观察，你会发现这次给你发证书的域名是 https://acme-v02.api.letsencrypt.org，少了 staging，自然就是【正式服】了！\n   6.5 你的进度  至此，Xray所需要的两个基础设施终于全部就位！千呼万唤始出来的Xray马上就要揭开面纱，我们终于要进入最激动人心章节啦！\nPROGRESS⬛⬛⬛⬛⬛⬛⬜⬜ 75%\n "},{"uri":"https://xtls.github.io/config/base/inbounds/","title":"Inbounds","tags":[],"description":"Project X 的文档.","content":"入站连接用于接收发来的数据，可用的协议请见inbound 可用协议列表。\nInboundObject  InboundObject 对应配置文件中 inbounds 项的一个子元素。\n{ \u0026#34;inbounds\u0026#34;: [ { \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1080, \u0026#34;protocol\u0026#34;: \u0026#34;协议名称\u0026#34;, \u0026#34;settings\u0026#34;: {}, \u0026#34;streamSettings\u0026#34;: {}, \u0026#34;tag\u0026#34;: \u0026#34;标识\u0026#34;, \u0026#34;sniffing\u0026#34;: { \u0026#34;enabled\u0026#34;: true, \u0026#34;destOverride\u0026#34;: [\u0026#34;http\u0026#34;, \u0026#34;tls\u0026#34;] }, \u0026#34;allocate\u0026#34;: { \u0026#34;strategy\u0026#34;: \u0026#34;always\u0026#34;, \u0026#34;refresh\u0026#34;: 5, \u0026#34;concurrency\u0026#34;: 3 } } ] }  listen: address\n 监听地址，IP 地址或 Unix domain socket，默认值为 \u0026quot;0.0.0.0\u0026quot;，表示接收所有网卡上的连接.\n可以指定一个系统可用的 IP 地址。\n支持填写 Unix domain socket，格式为绝对路径，形如 \u0026quot;/dev/shm/domain.socket\u0026quot;，可在开头加 \u0026quot;@\u0026quot; 代表 abstract，\u0026quot;@@\u0026quot; 则代表带 padding 的 abstract。\n填写 Unix domain socket 时，port 和 allocate 将被忽略，协议目前可选 VLESS、VMess、Trojan，传输方式可选 TCP、WebSocket、HTTP/2。\nport: number | \u0026ldquo;env:variable\u0026rdquo; | string\n 端口。接受的格式如下:\n 整型数值：实际的端口号。 环境变量：以 \u0026quot;env:\u0026quot; 开头，后面是一个环境变量的名称，如 \u0026quot;env:PORT\u0026quot;。Xray 会以字符串形式解析这个环境变量。 字符串：可以是一个数值类型的字符串，如 \u0026quot;1234\u0026quot;；或者一个数值范围，如 \u0026quot;5-10\u0026quot; 表示端口 5 到端口 10，这 6 个端口。  当只有一个端口时，Xray 会在此端口监听入站连接。当指定了一个端口范围时，取决于 allocate 设置。\nprotocol: string\n 连接协议名称，可选的协议类型见inbound 可用协议列表。\nsettings: InboundConfigurationObject\n 具体的配置内容，视协议不同而不同。详见每个协议中的 InboundConfigurationObject。\nstreamSettings: StreamSettingsObject\n 底层传输方式（transport）是当前 Xray 节点和其它节点对接的方式\n tag: string\n 此入站连接的标识，用于在其它的配置中定位此连接。\nimportant当其不为空时，其值必须在所有 tag 中 唯一。\n sniffing: SniffingObject\n 流量探测主要作用于在透明代理等用途. 比如一个典型流程如下:\n 如有一个设备上网,去访问abc.com,首先设备通过DNS查询得到abc.com的IP是1.2.3.4,然后设备会向1.2.3.4去发起连接. 如果不设置嗅探,Xray收到的连接请求是1.2.3.4,并不能用于域名规则的路由分流. 当设置了sniffing中的enable为true,Xray处理此连接的流量时,会从流量的数据中,嗅探出域名,即abc.com Xray会把1.2.3.4重置为abc.com.路由就可以根据域名去进行路由的域名规则的分流  因为变成了一个向abc.com请求的连接, 就可以做更多的事情, 除了路由域名规则分流, 还能重新做DNS解析等其他工作.\n当设置了sniffing中的enable为true, 还能嗅探出bittorrent类型的流量, 然后可以在路由中配置\u0026quot;protocol\u0026quot;项来设置规则处理BT流量, 比如服务端用来拦截BT流量, 或客户端固定转发BT流量到某个VPS去等.\nallocate: AllocateObject\n 当设置了多个port时, 端口分配的具体设置\n\nSniffingObject  { \u0026#34;enabled\u0026#34;: true, \u0026#34;destOverride\u0026#34;: [\u0026#34;http\u0026#34;, \u0026#34;tls\u0026#34;, \u0026#34;fakedns\u0026#34;], \u0026#34;metadataOnly\u0026#34;: false }  enabled: true | false\n 是否开启流量探测。\ndestOverride: [\u0026ldquo;http\u0026rdquo; | \u0026ldquo;tls\u0026rdquo; | \u0026ldquo;fakedns\u0026rdquo; ]\n 当流量为指定类型时，按其中包括的目标地址重置当前连接的目标。\nmetadataOnly: true | false\n 当启用时，将仅使用连接的元数据嗅探目标地址。此时，http 与 tls 将不能使用。\n\nAllocateObject  { \u0026#34;strategy\u0026#34;: \u0026#34;always\u0026#34;, \u0026#34;refresh\u0026#34;: 5, \u0026#34;concurrency\u0026#34;: 3 }  strategy: \u0026ldquo;always\u0026rdquo; | \u0026ldquo;random\u0026rdquo;\n 端口分配策略。\n \u0026quot;always\u0026quot; 表示总是分配所有已指定的端口，port 中指定了多少个端口，Xray 就会监听这些端口。 \u0026quot;random\u0026quot; 表示随机开放端口，每隔 refresh 分钟在 port 范围中随机选取 concurrency 个端口来监听。  refresh: number\n 随机端口刷新间隔，单位为分钟。最小值为 2，建议值为 5。这个属性仅当 strategy 设置为 \u0026quot;random\u0026quot; 时有效。 concurrency: number\n 随机端口数量。最小值为 1，最大值为 port 范围的三分之一。建议值为 3。\n"},{"uri":"https://xtls.github.io/config/outbound-protocols/","title":"Outbounds 可用协议列表","tags":[],"description":"Project X 的文档.","content":" 这个章节包含了目前所有可用于 Outbounds 的协议及具体配置细节. 协议列表   Blackhole\n Blackhole（黑洞）是一个出站数据协议，它会阻碍所有数据的出站，配合 路由（Routing） 一起使用，可以达到禁止访问某些网站的效果。 DNS\n DNS 是一个出站协议，主要用于拦截和转发 DNS 查询。此出站协议只能接收 DNS 流量（包含基于 UDP 和 TCP 协议的查询），其它类型的流量会导致错误。 Freedom\n Freedom 是一个出站协议，可以用来向任意网络发送（正常的） TCP 或 UDP 数据。 HTTP\n HTTP 协议 Socks\n 标准 Socks 协议实现，兼容 Socks 4、Socks 4a 和 Socks 5。 VLESS\n VLESS 是一个无状态的轻量传输协议，可以作为 Xray 客户端和服务器之间的桥梁。 VMess\n VMess 是一个加密传输协议，可以作为 Xray 客户端和服务器之间的桥梁。 Trojan\n Trojan 协议。 Shadowsocks\n Shadowsocks 协议。\n"},{"uri":"https://xtls.github.io/config/transports/quic/","title":"QUIC","tags":[],"description":"Project X 的文档.","content":"QUIC 全称 Quick UDP Internet Connection，是由 Google 提出的使用 UDP 进行多路并发传输的协议。其主要优势是:\n 减少了握手的延迟（1-RTT 或 0-RTT） 多路复用，并且没有 TCP 的阻塞问题 连接迁移，（主要是在客户端）当由 Wifi 转移到 4G 时，连接不会被断开。  QUIC 目前处于实验期，使用了正在标准化过程中的 IETF 实现，不能保证与最终版本的兼容性。\n 默认设定:  12 字节的 Connection ID 30 秒没有数据通过时自动断开连接 (可能会影响一些长连接的使用)    QuicObject  QuicObject 对应传输配置的 quicSettings 项。\nimportant对接的两端的配置必须完全一致，否则连接失败。 QUIC 强制要求开启 TLS，在传输配置中没有开启 TLS 时，Xray 会自行签发一个证书进行 TLS 通讯。\n { \u0026#34;security\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;header\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; } }  security: \u0026ldquo;none\u0026rdquo; | \u0026ldquo;aes-128-gcm\u0026rdquo; | \u0026ldquo;chacha20-poly1305\u0026rdquo;\n 加密方式。\n此加密是对 QUIC 数据包的加密，加密后数据包无法被探测。\n默认值为不加密。\nkey: string\n 加密时所用的密钥。\n可以是任意字符串。当 security 不为 \u0026quot;none\u0026quot; 时有效。\nheader: HeaderObject\n 数据包头部伪装设置\n\nHeaderObject  { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }  type: string\n 伪装类型，可选的值有：\n \u0026quot;none\u0026quot;：默认值，不进行伪装，发送的数据是没有特征的数据包。 \u0026quot;srtp\u0026quot;：伪装成 SRTP 数据包，会被识别为视频通话数据（如 FaceTime）。 \u0026quot;utp\u0026quot;：伪装成 uTP 数据包，会被识别为 BT 下载数据。 \u0026quot;wechat-video\u0026quot;：伪装成微信视频通话的数据包。 \u0026quot;dtls\u0026quot;：伪装成 DTLS 1.2 数据包。 \u0026quot;wireguard\u0026quot;：伪装成 WireGuard 数据包。（并不是真正的 WireGuard 协议）  TIP\n当加密和伪装都不启用时，数据包即为原始的 QUIC 数据包，可以与其它的 QUIC 工具对接。\n为了避免被探测，建议加密或伪装至少开启一项。\n "},{"uri":"https://xtls.github.io/config/outbound-protocols/vless/","title":"VLESS","tags":[],"description":"Project X 的文档.","content":" important目前 VLESS 没有自带加密，请用于可靠信道，如 TLS。 目前 VLESS 不支持分享。\n VLESS 是一个无状态的轻量传输协议，它分为入站和出站两部分，可以作为 Xray 客户端和服务器之间的桥梁。\n与 VMess 不同，VLESS 不依赖于系统时间，认证方式同样为 UUID，但不需要 alterId。\nOutboundConfigurationObject  { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;example.com\u0026#34;, \u0026#34;port\u0026#34;: 443, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34;, \u0026#34;encryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }  vnext: [ ServerObject ]\n 一个数组, 表示 VLESS 服务器列表，包含一组指向服务端的配置, 其中每一项是一个服务器配置。\n\nServerObject  { \u0026#34;address\u0026#34;: \u0026#34;example.com\u0026#34;, \u0026#34;port\u0026#34;: 443, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34;, \u0026#34;encryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] }  address: address\n 服务端地址，指向服务端，支持域名、IPv4、IPv6。\nport: number\n 服务端端口，通常与服务端监听的端口相同。\nusers: [ UserObject ]\n 数组, 一组服务端认可的用户列表, 其中每一项是一个用户配置\n\nUserObject  { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34;, \u0026#34;encryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0 }  id: string\n VLESS 的用户 ID，可以是任意小于30字节的字符串, 也可以是一个合法的UUID.  自定义字符串和其映射的 UUID 是等价的, 这意味着你将可以这样在配置文件中写id来标识同一用户,即\n 写 \u0026ldquo;id\u0026rdquo;: \u0026ldquo;我爱🍉老师1314\u0026rdquo;, 或写 \u0026ldquo;id\u0026rdquo;: \u0026ldquo;5783a3e7-e373-51cd-8642-c83782b807c5\u0026rdquo; (此UUID是 我爱🍉老师1314 的 UUID 映射)  其映射标准在VLESS UUID 映射标准：将自定义字符串映射为一个 UUIDv5\n你可以使用命令 xray uuid -map \u0026quot;自定义字符串\u0026quot; 生成自定义字符串所映射的的 UUID. 也可以使用命令 xray uuid 生成随机的UUID.\nencryption: \u0026ldquo;none\u0026rdquo;\n 需要填 \u0026quot;none\u0026quot;，不能留空。\n该要求是为了提醒使用者没有加密，也为了以后出加密方式时，防止使用者填错属性名或填错位置导致裸奔。 若未正确设置 encryption 的值，使用 Xray 或 -test 时会收到错误信息。\nflow: string\n 流控模式，用于选择 XTLS 的算法。\n目前出站协议中有以下流控模式可选：\n xtls-rprx-origin：最初的流控模式。该模式纪念价值大于实际使用价值 xtls-rprx-origin-udp443：同 xtls-rprx-origin, 但放行了目标为 443 端口的 UDP 流量 xtls-rprx-direct：所有平台皆可使用的典型流控模式 xtls-rprx-direct-udp443：同 xtls-rprx-direct, 但是放行了目标为 443 端口的 UDP 流量 xtls-rprx-splice：Linux 平台下最建议使用的流控模式 xtls-rprx-splice-udp443：同 xtls-rprx-splice, 但是放行了目标为 443 端口的 UDP 流量  注意\n当 flow 被指定时，还需要将该出站协议的 streamSettings.security 一项指定为 xtls，tlsSettings 改为 xtlsSettings。详情请参考 streamSettings。\n此外，目前 XTLS 仅支持 TCP、mKCP、DomainSocket 这三种传输方式。\n 关于 xtls-rprx-*-udp443 流控模式\n启用了 Xray-core 的 XTLS 时，通往 UDP 443 端口的流量默认会被拦截（一般情况下为 QUIC），这样应用就不会使用 QUIC 而会使用 TLS，XTLS 才会真正生效。实际上，QUIC 本身也不适合被代理，因为 QUIC 自带了 TCP 的功能，它作为 UDP 流量在通过 VLESS 协议传输时，底层协议为 TCP，就相当于两层 TCP 了。\n若不需要拦截，请在客户端填写 xtls-rprx-*-udp443，服务端不变。\n importantSplice 是 Linux Kernel 提供的函数，系统内核直接转发 TCP，不再经过 Xray 的内存，大大减少了数据拷贝、CPU 上下文切换的次数。\nSplice 模式的的使用限制：\n Linux 环境 入站协议为 Dokodemo door、Socks、HTTP 等纯净的 TCP 连接, 或其它使用了 XTLS 的入站协议 出站协议为 VLESS + XTLS 或 Trojan + XTLS  此外，使用 Splice 时网速显示会滞后，这是特性，不是 bug。\n需要注意的是，使用 mKCP 协议时不会使用 Splice（是的，虽然没有报错，但实际上根本没用到）。\n level: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n\n"},{"uri":"https://xtls.github.io/config/inbound-protocols/vmess/","title":"VMess","tags":[],"description":"Project X 的文档.","content":"VMess 是一个加密传输协议，通常作为 Xray 客户端和服务器之间的桥梁。\nimportantVMess 依赖于系统时间，请确保使用 Xray 的系统 UTC 时间误差在 90 秒之内，时区无关。在 Linux 系统中可以安装ntp服务来自动同步系统时间。\n InboundConfigurationObject  { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;alterId\u0026#34;: 0, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34; } ], \u0026#34;default\u0026#34;: { \u0026#34;level\u0026#34;: 0, \u0026#34;alterId\u0026#34;: 0 }, \u0026#34;detour\u0026#34;: { \u0026#34;to\u0026#34;: \u0026#34;tag_to_detour\u0026#34; }, \u0026#34;disableInsecureEncryption\u0026#34;: false }  clients: [ ClientObject ]\n 一个数组，代表一组服务端认可的用户.\n其中每一项是一个用户ClientObject。\n当此配置用作动态端口时，Xray 会自动创建用户。\ndetour: DetourObject\n 指示对应的出站协议使用另一个服务器。\ndefault: DefaultObject\n 可选，clients 的默认配置。仅在配合detour时有效。\ndisableInsecureEncryption: true | false\n 是否禁止客户端使用不安全的加密方式，如果设置为 true 当客户端指定下列加密方式时，服务器会主动断开连接。\n \u0026quot;none\u0026quot; \u0026quot;aes-128-cfb\u0026quot;  默认值为false。\n\nClientObject  { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;alterId\u0026#34;: 4, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34; }  id: string\n Vmess 的用户 ID，可以是任意小于30字节的字符串, 也可以是一个合法的UUID.  自定义字符串和其映射的 UUID 是等价的, 这意味着你将可以这样在配置文件中写id来标识同一用户,即\n 写 \u0026ldquo;id\u0026rdquo;: \u0026ldquo;我爱🍉老师1314\u0026rdquo;, 或写 \u0026ldquo;id\u0026rdquo;: \u0026ldquo;5783a3e7-e373-51cd-8642-c83782b807c5\u0026rdquo; (此UUID是 我爱🍉老师1314 的 UUID 映射)  其映射标准在VLESS UUID 映射标准：将自定义字符串映射为一个 UUIDv5\n你可以使用命令 xray uuid -map \u0026quot;自定义字符串\u0026quot; 生成自定义字符串所映射的的 UUID. 也可以使用命令 xray uuid 生成随机的UUID.\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nalterId: number\n 为了进一步防止被探测，一个用户可以在主 ID 的基础上，再额外生成多个 ID。这里只需要指定额外的 ID 的数量，推荐值为 0 代表启用 VMessAEAD。\n最大值 65535。这个值不能超过服务器端所指定的值。\n不指定的话，默认值是 0。\nTIP\n客户端 AlterID 设置为 0 代表启用 VMessAEAD ；服务端为自动适配，可同时兼容启用和未开启 VMessAEAD 的客户端。\n客户端可通过设置环境变量 Xray_VMESS_AEAD_DISABLED=true 强行禁用 VMessAEAD\n email: string\n 用户邮箱地址，用于区分不同用户的流量。\n\nDetourObject  { \u0026#34;to\u0026#34;: \u0026#34;tag_to_detour\u0026#34; }  to: string\n 一个 inbound 的tag, 指定的 inbound 的必须是使用 VMess 协议的 inbound.\n\nDefaultObject  { \u0026#34;level\u0026#34;: 0, \u0026#34;alterId\u0026#34;: 0 }  level: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nalterId: number\n 动态端口的默认alterId，默认值为0。\n\nVMess MD5 认证信息 玷污机制  为了进一步对抗可能的探测和封锁，每个 VMess 认证数据的服务端结构都会包含一个一次写入的玷污状态标记，初始状态为无瑕状态，当服务器检测到重放探测时或者因为其他原因入站连接出错以致校验数据不正确时，该连接所对应的请求认证数据会被玷污。\n被玷污的认证数据无法被用于建立连接，当攻击者或客户端使用被玷污的认证数据建立连接时，服务器会输出包含 \u0026ldquo;invalid user\u0026rdquo; \u0026ldquo;ErrTainted\u0026rdquo; 的错误信息，并阻止该连接。\n当服务器没有受到重放攻击时，该机制对正常连接的客户端没有影响。\n如果服务器正在被重放攻击，可能会出现连接不稳定的情况。\nTIP\n拥有服务器 UUID 以及其他连接数据的恶意程序可能根据此机制对服务器发起拒绝服务攻击，受到此类攻击的服务可以通过修改 proxy/vmess/validator.go 文件中 func (v *TimedUserValidator) BurnTaintFuse(userHash []byte) error 函数的 atomic.CompareAndSwapUint32(pair.taintedFuse, 0, 1) 语句为 atomic.CompareAndSwapUint32(pair.taintedFuse, 0, 0) 来解除服务器对此类攻击的安全保护机制。使用 VMessAEAD 认证机制的客户端不受到 VMess MD5 认证信息 玷污机制 的影响。\n "},{"uri":"https://xtls.github.io/faq/xtls/","title":"XTLS相关问题","tags":[],"description":"Project X 的文档.","content":" Q: XTLS是个啥?好吃吗?XTLS 是 Xray 的原创黑科技, 也是使 Xray 性能一骑绝尘的核心动力\n点此查看详情 XTLS\n Q: TLS和XTLS有啥区别?XTLS会不安全吗?安全性没有区别. 传输的数据都是完全加密的\nTLS / XTLS 是目前最安全的传输加密方案, 且外部看来流量类型和正常上网具有一致性.\n性能有区别. XTLS比TLS快的多的多的多.\n启用 XTLS 并且配置合适的XTLS流控模式, 可以在保持和 TLS 相同的安全性的前提下, 性能达到数倍甚至十几倍的提升.\n Q: 听说XTLS的数据是不完全加密的，是这样的吗?此说法错误，XTLS传输的数据是完全加密的，和TLS没有区别。\nXTLS去掉了旧时代翻墙模式中不必要的对加密数据的重复加密。即:\n 如果原始数据是已经经过TLS加密的数据（通常上网，绝大部分数据都是已经TLS加密过的数据了），此时XTLS不再和旧时代工具一样进行无用的重复加密，从而获得卓越性能。 如果原始数据不是经过TLS加密的，而是明文数据，XTLS会进行TLS加密。   因此XTLS数据仍然是完全TLS加密的，并且去掉了毫无意义的不必要的重复加密，而不是所谓的不完全加密。\n同时外部看来流量类型和正常上网具有一致性，更具隐蔽性，是最安全的模式。\n Q: 配置了XTLS, 出现 failed to use xtls-rprx-splice, maybe security is not xtls 的错误怎么办? 首先请确定你的设置正确, 比如XTLS设置的位置是否写对,拼写有无错误等等. 去掉 HTTP 伪装.   Q: XTLS的direct和origin模式似乎不能混用?不能, 建议使用 direct 模式.\n "},{"uri":"https://xtls.github.io/faq/","title":"常见问答","tags":[],"description":"Project X 的文档.","content":" 如果您有任何疑问, 不妨先到这里看看是不是有人遇到了同样的问题, 并且已经解决了. 下载和安装中的问题 首先您可以点击查看下载和安装Xray\n如果碰到问题, 可以点击这里下载和安装中的问题\n 配置和运行时的问题 首先您可以点击查看配置和运行Xray\n如果碰到问题, 可以点击这里配置和运行时的问题\n 性能相关的问题 速率, 延迟, CPU占用, 内存占用\u0026hellip;\n这些相关的问题请点击这里性能相关的问题\n 透明代理的问题 如果您使用了透明代理\n遇到问题不妨点击这里透明代理的问题\n  \n回落相关的问题 回落是Xray最强大功能之一, 灵活且强大, 可以玩很多杂技\n如有相关问题可以点击回落相关的问题\n XTLS相关的问题 XTLS 是 Xray独创的新科技, 因此 Xray 的性能一骑绝尘.\n如有相关问题可以点击XTLS相关的问题\n  关于 Xray Xray 的非技术问题\n点击查看Xray 的非技术问题\n  \n如果在这里找不到你要的答案或者觉得答案不够细致, 不妨再去翻一翻大案牍术\n "},{"uri":"https://xtls.github.io/documents/level-0/ch07-xray-server/","title":"【第7章】Xray服务器篇","tags":[],"description":"小小白白话文","content":"7.1 博观而约取，厚积而薄发  本文撰写过程中，大佬开玩笑的吐槽到：你这教程，居然连载了6章都还没到Xray，不知道的还以为你是“手把手教你建网站”教程呢。（我竟无法反驳.jpg!）\n其实这样的结构是我多番思考之后的决定，毕竟只有打好基础，才能在后面事半功倍快速反超。我在群里看到许多新人连nano都无法正确使用，也不会用WinSCP，远程手写编辑出来的config.json自然错误百出，连查错也变得举步维艰。\n经过了前6章的准备，各位已经跟我一起翻越了Linux基本操作、VPS远程管理、网页搭建、域名管理、证书申请等等几座大山。是不是回头看看，觉得其实非常简单呢？现在我们有了如此扎实的准备，接下来安装和配置Xray时会有一种【水到渠成】的轻快感觉。\n 后面要做的事情非常简单：\n 安装 配置（如安装TLS证书、config.json） 运行 优化（如更新内核、开启bbr、网站http访问自动跳转https等）   7.2 安装Xray  首先，Xray的官方载体，就是 xray-core 开源项目（基于 MPL 2.0 开源协议）生成的二进制程序。你把这个二进制放在服务器运行，它就是服务器端；你把它下载到本地电脑运行，它就是客户端。主要区别来源于【配置】。\n安装时，直接使用官方安装脚本就很简单直接。它提供了多种安装选项，有兴趣的可以去官方的安装脚本仓库中看看脚本的说明，本文使用的是【非root用户】安装模式。\n写本文时，安装脚本在使用非root账户时有一些小bug，所以我决定正好把这几步分开操作，可以顺便说明一下Linux下的删除命令。\n  小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-14 rm 删除命令      将安装脚本下载至本地：\n$ wget https://github.com/XTLS/Xray-install/raw/main/install-release.sh   执行安装命令\n$ sudo bash install-release.sh   使用完成之后可以删除该脚本\n$ rm ~/install-release.sh  注意： 使用 rm 命令删除文件的时候，默认其实就是删除现在所在的文件夹下的文件。但是，我依然写了完整的路径： ~/install-release.sh，这是我使用 rm 时的一个安全习惯、也是我把安装分成几步之后想强调一下的内容。如果你听过一些“程序员从删库到跑路”之类的段子，大概就知道为什么了。\n   完整流程演示如下：\n   7.3 给Xray配置TLS证书  虽然我们前面已经申请好了TLS证书，但是按照 acme.sh的官方说明，申请后的证书不建议直接使用。正确的方法是使用 --install-cert 命令安装给需要的程序。我们现在就来把证书安装给 xray-core 使用。\n  为了规避非root账户的各种潜在的权限困扰，我们在vpsadmin账户下建立一个证书文件夹\n$ mkdir ~/xray_cert   使用acme.sh的--install-cert正确安装（拷贝）证书文件\n$ acme.sh --install-cert -d 二级域名.你的域名.com --ecc \\ --fullchain-file ~/xray_cert/xray.crt \\ --key-file ~/xray_cert/xray.key   xray.key文件默认对其他用户不可读，所以需要赋予其可读性权限\n$ chmod +r ~/xray_cert/xray.key   过程比较简单就不放动图了：\n  acme.sh 会每60天检查一次证书并自动更新临期证书。但据我所知是它并不会自动将新证书安装给 xray-core，所以我们需要新增一个系统的自动周期任务来完成这一步。\n  小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-15 crontab -e 编辑当前用户的定时任务      建立一个脚本文件（xray-cert-renew.sh）\n$ nano ~/xray_cert/xray-cert-renew.sh   把下面的内容复制进去，记得替换你的真实域名，然后保存退出\n#!/bin/bash  /home/vpsadmin/.acme.sh/acme.sh --install-cert -d a-name.yourdomain.com --ecc --fullchain-file /home/vpsadmin/xray_cert/xray.crt --key-file /home/vpsadmin/xray_cert/xray.key echo \u0026#34;Xray Certificates Renewed\u0026#34; chmod +r /home/vpsadmin/xray_cert/xray.key echo \u0026#34;Read Permission Granted for Private Key\u0026#34; sudo systemctl restart xray echo \u0026#34;Xray Restarted\u0026#34;  注意： 经大家提醒，acme.sh 有一个 reloadcmd 命令，可以在证书更新时自动执行特定命令，那么就可以指定自动给 Xray 安装证书，但因为 crontab 是 Linux 系统中一个非常有用、非常常用的功能，所以本文保留 crontab 的方式来更新 Xray 证书。（对 reloadcmd 感兴趣的同学可以查看 acme.sh 的官方文档）\n另外，录制动图时，脚本中没有加入重启 Xray 的命令，是因为 Xray 计划支持【证书热更新】功能，即 Xray 会自动识别证书更新并重载证书、无需手动重启。待功能加入后，我将适当修改 config.json 开启此设置，并删除脚本中的重启命令。\n   给这个文件增加【可执行】权限\n$ chmod +x ~/xray_cert/xray-cert-renew.sh   运行 crontab -e，添加一个自动任务【每月自动运行一次xray-cert-renew.sh】 (注意不要加sudo，因为我们增加的是vpsadmin账户的自动任务。初次运行时会让你选择编辑器，当然是选择熟悉的nano啦！)\n$ crontab -e   把下面的内容增加在文件最后，保存退出即可。\n# 1:00am, 1st day each month, run `xray-cert-renew.sh` 0 1 1 * * bash /home/vpsadmin/xray_cert/xray-cert-renew.sh   完整流程演示如下：\n     7.4 配置Xray  首先，各种配置都可以参考官方VLESS配置示例。本文会基于官方示例，配置一个最精简的方式：【单 VLESS 协议入站 + 80 端口回落】，满足大多数场景的最大速度及必要安全。\n  生成一个合法的 UUID 并保存备用（UUID可以简单粗暴的理解为像指纹一样几乎不会重复的ID）\n$ xray uuid   建立日志文件及文件夹备用\n  小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-16 touch 建立空白文件      在vpsadmin的文件夹内建立一个【日志专用文件夹】\n$ mkdir ~/xray_log   生成所需的两个日志文件（访问日志、错误日志）\n$ touch ~/xray_log/access.log \u0026amp;\u0026amp; touch ~/xray_log/error.log  注意： 这个位置不是Xray标准的日志文件位置，放在这里是避免权限问题对新人的操作带来困扰。当你熟悉之后，建议回归默认位置： /var/log/xray/access.log 和 /var/log/xray/error.log 。\n   因为Xray默认是nobody用户使用，所以我们需要让其他用户也有“写”的权限（*.log 就是所有文件后缀是log的文件，此时CLI界面的效率优势就逐渐出现了）\n$ chmod a+w ~/xray_log/*.log     使用nano创建Xray的配置文件\n$ sudo nano /usr/local/etc/xray/config.json   将下面的文件全部复制进去，并将之前生成的UUID填入第61行 \u0026quot;id\u0026quot;: \u0026quot;\u0026quot;, 之中。（填好之后的样子是 \u0026quot;id\u0026quot;: \u0026quot;uuiduuid-uuid-uuid-uuid-uuiduuiduuid\u0026quot;），本文的这个配置文件中增加了我的各种啰嗦注解，以方便你理解每一个配置模块的功能是什么。\n// REFERENCE: // https://github.com/XTLS/Xray-examples // https://xtls.github.io/config/ // 常用的config文件，不论服务器端还是客户端，都有5个部分。外加小小白解读： // ┌─ 1_log 日志设置 - 日志写什么，写哪里（出错时有据可查） // ├─ 2_dns DNS-设置 - DNS怎么查（防DNS污染、防偷窥、避免国内外站匹配到国外服务器等） // ├─ 3_routing 分流设置 - 流量怎么分类处理（是否过滤广告、是否国内外分流） // ├─ 4_inbounds 入站设置 - 什么流量可以流入Xray // └─ 5_outbounds 出站设置 - 流出Xray的流量往哪里去 { // 1_日志设置 \u0026#34;log\u0026#34;: { \u0026#34;loglevel\u0026#34;: \u0026#34;warning\u0026#34;, // 内容从少到多: \u0026#34;none\u0026#34;, \u0026#34;error\u0026#34;, \u0026#34;warning\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;debug\u0026#34; \u0026#34;access\u0026#34;: \u0026#34;/home/vpsadmin/xray_log/access.log\u0026#34;, // 访问记录 \u0026#34;error\u0026#34;: \u0026#34;/home/vpsadmin/xray_log/error.log\u0026#34; // 错误记录 }, // 2_DNS设置 \u0026#34;dns\u0026#34;: { \u0026#34;servers\u0026#34;: [ \u0026#34;https+local://1.1.1.1/dns-query\u0026#34;, // 首选1.1.1.1的DoH查询，牺牲速度但可防止ISP偷窥 \u0026#34;localhost\u0026#34; ] }, // 3_分流设置 \u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;rules\u0026#34;: [ // 3.1 防止服务器本地流转问题：如内网被攻击或滥用、错误的本地回环等 { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [ \u0026#34;geoip:private\u0026#34; // 分流条件：geoip文件内，名为\u0026#34;private\u0026#34;的规则（本地） ], \u0026#34;outboundTag\u0026#34;: \u0026#34;block\u0026#34; // 分流策略：交给出站\u0026#34;block\u0026#34;处理（黑洞屏蔽） }, // 3.2 屏蔽广告 { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:category-ads-all\u0026#34; // 分流条件：geosite文件内，名为\u0026#34;category-ads-all\u0026#34;的规则（各种广告域名） ], \u0026#34;outboundTag\u0026#34;: \u0026#34;block\u0026#34; // 分流策略：交给出站\u0026#34;block\u0026#34;处理（黑洞屏蔽） } ] }, // 4_入站设置 // 4.1 这里只写了一个最简单的vless+xtls的入站，因为这是Xray最强大的模式。如有其他需要，请根据模版自行添加。 \u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 443, \u0026#34;protocol\u0026#34;: \u0026#34;vless\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;\u0026#34;, // 填写你的 UUID \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;email\u0026#34;: \u0026#34;vpsadmin@yourdomain.com\u0026#34; } ], \u0026#34;decryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;fallbacks\u0026#34;: [ { \u0026#34;dest\u0026#34;: 80 // 默认回落到防探测的代理 } ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;xtls\u0026#34;, \u0026#34;xtlsSettings\u0026#34;: { \u0026#34;allowInsecure\u0026#34;: false, // 正常使用应确保关闭 \u0026#34;minVersion\u0026#34;: \u0026#34;1.2\u0026#34;, // TLS最低版本设置 \u0026#34;alpn\u0026#34;: [ \u0026#34;http/1.1\u0026#34; ], \u0026#34;certificates\u0026#34;: [ { \u0026#34;certificateFile\u0026#34;: \u0026#34;/home/vpsadmin/xray_cert/xray.crt\u0026#34;, \u0026#34;keyFile\u0026#34;: \u0026#34;/home/vpsadmin/xray_cert/xray.key\u0026#34; } ] } } } ], // 5_出站设置 \u0026#34;outbounds\u0026#34;: [ // 5.1 第一个出站是默认规则，freedom就是对外直连（vps已经是外网，所以直连） { \u0026#34;tag\u0026#34;: \u0026#34;direct\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34; }, // 5.2 屏蔽规则，blackhole协议就是把流量导入到黑洞里（屏蔽） { \u0026#34;tag\u0026#34;: \u0026#34;block\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;blackhole\u0026#34; } ] }   完整流程演示如下：\n   7.5 启动Xray服务！！（并查看服务状态）  如果你是跟随本文一步步设置过来，其实就已经避开了最常见日志文件权限不足、证书文件权限不足 这两个大坑。那么现在运行Xray自然应该无比顺利。\n  输入下面的命令，享受启动Xray的历史性时刻吧！！！\n$ sudo systemctl start xray   仅仅start我们并不能确定是否成功的开启了Xray的服务，要确定它的状态，就要用到下面的命令。\n$ sudo systemctl status xray 看到那个绿色的、令人愉悦的 active (running) 了吗？它就是说 Xray 已经在正确的运行了\n  完整流程演示如下：\n   7.6 回顾 systemd 进行基本的服务管理  到现在为止，我们已经使用过了systemctl相关的start, status, reload 等命令，这些都是基于systmed管理模块对Linux系统中各种服务进行管理的通用命令。现在正好熟悉一下相关的其他几个命令。\n  若你需要暂时关闭 Xray 的服务，那就用stop命令\n$ sudo systemctl stop xray   若你需要重启Xray的服务，那就用restart命令\n$ sudo systemctl restart xray   若你需要禁用Xray的服务（电脑重启后禁止Xray自动运行），那就用disable命令\n$ sudo systemctl disable xray   若你需要启用Xray的服务（电脑重启后确保Xray自动运行），那就用enable命令\n$ sudo systemctl enable xray    7.7 服务器优化之一：开启BBR    传说中的BBR\n我相信，你在搜索各种科学上网技术的时候，肯定不止一次的听过bbr这个东西，在各种博客添油加醋之下，让人觉得它神乎其神。更有bbrplus, bbr2, 魔改bbr 等一大堆衍生品。仿佛神油一般，用了就能野鸡线路变专线。\n那么，这东西究竟是什么？它有没有用？又该用哪一个版本呢？\n  实际的BBR\nBBR = Bottleneck Bandwidth and Round-trip propagation time，是一种TCP的拥塞控制算法。简单粗暴的理解就是数据流量的交通管理：当公路不再塞车的时候，每辆车自然就能保持较快的车速了。\n那么它有没有用呢？一般而言，有BBR 和 没有BBR 会有可以感知的差别（速度、稳定性、延迟方面都会有一些改善），所以 【非常建议开启 BBR】。\n但开启之后，BBR 在 4.x 和 5.x 之间的差异往往比较微妙、见仁见智，造成体验差别的决定性因素仍然是线路质量。所以 【不必纠结版本、不必盲目追新、跟随你的发行版更新内核即可】\n  bbrplus, bbr2, 魔改bbr 和其他各种听起来就酷炫的版本是不是更好？\n一句话：不是！不要用这些！这些都为了吸引眼球乱起的名字！\nBBR 的更新和发布，都是跟随Linux的内核（Kernel）进行的。换言之，只要你用的是比较新的内核，就自然会使用到新版BBR。\n而这些名字看起来很酷炫的东西，说白了就是仍未正式发布的、尚在测试阶段的内核及其对应的BBR版本。这些脚本也仅仅就是通过下载预览版的内核（甚至第三方魔改内核）来率先开启而已。\n内核的稳定是一台服务器稳定运行的基石。【BBR测试版带来的细微性能差异绝对不值得更换不稳定的内核。】 请选择你所在的Linux发行版所支持的最新内核，这样可以最大限度的保持服务器的长期稳定和兼容。\n注意： 所谓魔改bbr的【领先】是有非常强的时效性的。比如很多 bbrplus 脚本，因为几年来都没有更新，到现在还会把你的内核换成 4.19，要知道现在稳定如 Debian 已经是 5.9 的时代了，那么这个脚本放在2018年1月也许领先了一点，到2018年10月4.19正发布时就已经失去了意义，放在现在甚至可以说是完完全全的【降级】和【劣化】\n   fq, fq_codel, fq_pie, cake和其他算法哪个好？\n一句话：看不懂的话，请保持fq，足够、且不会劣化你的线路\n  锐速、Finalspeed、LotServer和其他“加速工具”\n一句话：不要用这些！把他们丢进历史的垃圾桶吧！\n它能解决的也只有丢包率的问题。不太准确的比喻，就是本来你用一辆车送你的货，有时候车半路就坏了（丢包），用了这些以后，你直接派出3份一样的货，让三辆车同时送，只要有一辆没坏就能送到。马路上都是你的车，自然就能把别人挤下去。但可想而知，你挤别人的时候，别人也会来挤你，而整个机房的出口道路一共就那么宽，最终势必就变成集体大堵车了。\n说明： 它们的原理不是算法优化、不是提速、大多数是简单粗暴的多倍发包。对于【丢包率非常高】的差线路可能有一点作用，但【对丢包率低的好线路没有任何优化作用，反而会成倍的消耗你的流量】，进而造成服务器和你的邻居不必要的压力。\n如果你的线路真的丢包率奇高，真正靠谱的解决方案是【换线路】。\n   啰嗦了这么多，就是因为围绕 BBR 忽悠小白的错误概念和坑人脚本实在是太多了。我希望你们现在对 BBR 有了相对清晰的理解。接下来，我们就动手安装最新的Debian内核并开启BBR 吧！（真的很简单）\n  给 Debian 10 添加官方 backports 源，获取更新的软件库\n$ sudo nano /etc/apt/sources.list  说明： 本文以 Debian 10 为例，所以使用 /etc/apt/sources.list 仍无问题，但如果你并不是根据本文从头开始，或者使用了其他Linux发行版，那么建议你建立 /etc/apt/sources.list.d/ 文件夹，并在这个文件夹内建立自己的配置文件，形如 /etc/apt/sources.list.d/vpsadmin.list，以此保证兼容性，也可避免默认文件在不可预见的情况下被覆盖而导致配置丢失。\n   然后把下面这一条加在最后，并保存退出。\ndeb http://deb.debian.org/debian buster-backports main   刷新软件库并查询 Debian 官方的最新版内核并安装。请务必安装你的VPS对应的版本（本文以比较常见的【amd64】为例）。\n$ sudo apt update \u0026amp;\u0026amp; sudo apt -t buster-backports install linux-image-amd64  注意： 如果你的VPS支持，可以尝试【云服务器专用内核】linux-image-cloud-amd64，优点就是精简、资源占用低，缺点嘛是有同学反馈不支持的系统强行安装会导致无法开机（Kernel无法识别）。\n为了避免无法识别的悲剧，请确保：\n 尝试前做一个系统快照，或者 你有 vnc 可以救场（并且你知道怎么用）     修改 kernel 参数配置文件 sysctl.conf 并指定开启 BBR\n$ sudo nano /etc/sysctl.conf  说明： 本文以 Debian 10 为例，所以使用 /etc/sysctl.conf 仍无问题，但如果你并不是跟着本文从头开始，或者使用了其他Linux发行版，那么建议你建立 /etc/sysctl.d/ 文件夹，并在这个文件夹内建立自己的配置文件，形如 /etc/sysctl.d/vpsadmin.conf，以此保证兼容性，因为部分发行版在 systemd 207 版本之后便不再从 /etc/sysctl.conf 读取参数。使用自定义配置文件也可避免默认文件在不可预见的情况下被覆盖而导致配置丢失。\n   把下面的内容添加进去\nnet.core.default_qdisc=fq net.ipv4.tcp_congestion_control=bbr   重启VPS、使内核更新和BBR设置都生效\n$ sudo reboot   完整流程演示如下：\n啰嗦君： 因为我做展示的VPS支持云服务器专用内核，所以动图中我用了 linux-image-cloud-amd64 。如果你不确定你的VPS是否支持，那请务必按照第3步的命令，使用常规内核 linux-image-amd64。\n   确认BBR开启\n如果你想确认 BBR 是否正确开启，可以使用下面的命令：\n$ lsmod | grep bbr 此时应该返回这样的结果：\ntcp_bbr 如果你想确认 fq 算法是否正确开启，可以使用下面的命令：\n$ lsmod | grep fq 此时应该返回这样的结果：\nsch_fq      7.8 服务器优化之二：开启HTTP自动跳转HTTPS    之前我们已经搭建了 80 端口的 http 网页，并以此申请了TLS证书。\n但如果你尝试过用浏览器访问我们的这个界面，就会发现 http 访问并不会像大多数网站一样自动升级为 https 访问。换言之，我们现在的设置下，http(80) 和 https(443)之间完全是独立的。如果要解决这个问题，就需要做一些修改。\n  编辑Nginx的配置文件\n$ sudo nano /etc/nginx/nginx.conf   在我们设置过的80端口Server中加入下面的语句，并保存退出（可同时删除root和index两行）\nreturn 301 https://$http_host$request_uri;   在与 80 端口同级的位置增加一个本地端口监听来提供网页展示。本文以 8080 端口做演示。（可以是任意端口）\nserver { listen 127.0.0.1:8080; root /home/vpsadmin/www/webpage; index index.html; add_header Strict-Transport-Security \u0026#34;max-age=63072000\u0026#34; always; }   重启 Nginx 服务\n$ sudo systemctl restart nginx   修改Xray的回落设置，将回落从 80 端口改为 8080 端口。（找到 \u0026quot;dest\u0026quot;: 80, 并改成 \u0026quot;dest\u0026quot;: 8080）\n$ sudo nano /usr/local/etc/xray/config.json   重启 Xray 服务，即完成了设置\n$ sudo systemctl restart xray   完整流程演示如下：\n  当你输入 http://a-name.yourdomain.com的时候，它应该已经会自动跳转https了\n   7.9 服务器优化之三：更丰富的回落  如果你需要更丰富的回落功能，可以参考 《回落 (fallbacks) 功能简析》\n 7.10 你的进度  恭喜！！到这一步，你已经拥有了可以正常科学上网的服务器、同时也有了可以防止主动探测攻击的伪装网站。接下来，只要给你的客户端装上合适的软件，就可以享受顺畅的网络了！\nPROGRESS⬛⬛⬛⬛⬛⬛⬛⬜ 87.5%\n   7.11 重要勘误    初版中Xray配置文件config.json文件夹位置错误。若你已经根据之前的位置进行了操作，Xray会无法正确启动。故勘误说明于此，请自查，造成不便十分抱歉！\n 正确位置：/usr/local/etc/xray/config.json 错误位置：/usr/local/etc/config.json  受影响章节：\n 7.4 配置Xray - 3. 使用nano创建Xray的配置文件 7.8 服务器优化之二 - 6. 修改Xray的回落设置    初版中修改Nginx配置文件nginx.conf时内容错误（网页文件夹位置错误），若你已经根据之前的位置进行了操作，Nginx会无法找到正确的网站。请自查，造成不便十分抱歉！\n 正确文件夹位置：root /home/vpsadmin/www/webpage; 错误文件夹位置：root /var/www/website/html  受影响章节：\n 7.8 服务器优化之二 - 4. 在与 80 端口同级的位置增加一个本地端口监听来提供网页展示    "},{"uri":"https://xtls.github.io/config/base/outbounds/","title":"Outbounds","tags":[],"description":"Project X 的文档.","content":"出站连接用于发送数据，可用的协议请见outbound 可用协议列表。\nOutboundObject  OutboundObject 对应配置文件中 outbounds 项的一个子元素。 TIP\n列表中的第一个元素作为主outbound。当路由匹配不存在或没有匹配成功时，流量由主outbound发出。\n { \u0026#34;outbounds\u0026#34;: [ { \u0026#34;sendThrough\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;协议名称\u0026#34;, \u0026#34;settings\u0026#34;: {}, \u0026#34;tag\u0026#34;: \u0026#34;标识\u0026#34;, \u0026#34;streamSettings\u0026#34;: {}, \u0026#34;proxySettings\u0026#34;: { \u0026#34;tag\u0026#34;: \u0026#34;another-outbound-tag\u0026#34; }, \u0026#34;mux\u0026#34;: {} } ] }  sendThrough: address\n 用于发送数据的 IP 地址，当主机有多个 IP 地址时有效，默认值为 \u0026quot;0.0.0.0\u0026quot;。 protocol: string\n 连接协议名称，可选的协议类型见outbound 可用协议列表。 settings: OutboundConfigurationObject\n 具体的配置内容，视协议不同而不同。详见每个协议中的 OutboundConfigurationObject。 tag: string\n 此出站连接的标识，用于在其它的配置中定位此连接。\nimportant当其不为空时，其值必须在所有 tag 中 唯一。\n streamSettings: StreamSettingsObject\n 底层传输方式（transport）是当前 Xray 节点和其它节点对接的方式\nproxySettings: ProxySettingsObject\n 出站代理配置。当出站代理生效时，此outbound的 streamSettings 将不起作用。\nmux: MuxObject\n Mux 相关的具体配置。\n\nProxySettingsObject  { \u0026#34;tag\u0026#34;: \u0026#34;another-outbound-tag\u0026#34; }  tag: string\n 当指定另一个outbound的标识时，此outbound发出的数据，将被转发至所指定的outbound发出。\n这种转发方式不经过底层传输方式。如果需要使用支持底层传输方式的转发，请使用 SockOpt.dialerProxy。\n 此选项与 SockOpt.dialerProxy 不兼容\n  兼容 v2fly/v2ray-core 的配置 transportLayer\n MuxObject  Mux 功能是在一条 TCP 连接上分发多个 TCP 连接的数据。实现细节详见 Mux.Cool。Mux 是为了减少 TCP 的握手延迟而设计，而非提高连接的吞吐量。使用 Mux 看视频、下载或者测速通常都有反效果。Mux 只需要在客户端启用，服务器端自动适配。\nMuxObject 对应 OutboundObject 中的 mux 项。\n{ \u0026#34;enabled\u0026#34;: false, \u0026#34;concurrency\u0026#34;: 8 }  enabled: true | false\n 是否启用 Mux 转发请求，默认值 false。 concurrency: number\n 最大并发连接数。最小值 1，最大值 1024，默认值 8。\n这个数值表示了一个 TCP 连接上最多承载的 Mux 连接数量。比如设置 concurrency=8 时，当客户端发出了 8 个 TCP 请求，Xray 只会发出一条实际的 TCP 连接，客户端的 8 个请求全部由这个 TCP 连接传输。\nTIP\n填负数时，如 -1，不加载 mux 模块。\n "},{"uri":"https://xtls.github.io/config/inbound-protocols/trojan/","title":"Trojan","tags":[],"description":"Project X 的文档.","content":"Trojan 协议\nimportantTrojan 被设计工作在正确配置的加密 TLS 隧道\n InboundConfigurationObject  { \u0026#34;clients\u0026#34;: [ { \u0026#34;password\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34; } ], \u0026#34;fallbacks\u0026#34;: [ { \u0026#34;dest\u0026#34;: 80 } ] }  clients: [ ClientObject ]\n 一个数组，代表一组服务端认可的用户.\n其中每一项是一个用户 ClientObject。\nfallbacks: [ FallbackObject ]\n 一个数组，包含一系列强大的回落分流配置（可选）。\nfallbacks 的具体配置请点击FallbackObject\nTIP\nXray 的 Trojan 有完整的 fallbacks 支持，配置方式完全一致。 触发回落的条件也与VLESS类似：首包长度 \u0026lt; 58 或第 57 个字节不为 \u0026lsquo;\\r\u0026rsquo;（因为 Trojan 没有协议版本）或身份认证失败。\n \nClientObject  { \u0026#34;password\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34; }  password: string\n 必填，任意字符串。\nemail: string\n 邮件地址，可选，用于标识用户\nimportant如果存在多个 ClientObject, 请注意 email 不可以重复。\n level: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nflow: string\n 流控模式，用于选择 XTLS 的算法。\n目前入站协议中有以下流控模式可选：\n xtls-rprx-origin：最初的流控模式，此时客户端仅可选择 xtls-rprx-origin 和 xtls-rprx-origin-udp443 这两种流控模式。该模式纪念价值大于实际使用价值 xtls-rprx-direct：推荐，所有平台皆可使用的典型流控方式，此时客户端可选择任何流控模式  注意\n当 flow 被指定时，还需要将该入站协议的 streamSettings.security 一项指定为 xtls，tlsSettings 改为 xtlsSettings。详情请参考 streamSettings。\n此外，目前 XTLS 仅支持 TCP、mKCP、DomainSocket 这三种传输方式。\n \n"},{"uri":"https://xtls.github.io/config/outbound-protocols/vmess/","title":"VMess","tags":[],"description":"Project X 的文档.","content":"VMess VMess 是一个加密传输协议，通常作为 Xray 客户端和服务器之间的桥梁。\nimportantVMess 依赖于系统时间，请确保使用 Xray 的系统 UTC 时间误差在 90 秒之内，时区无关。在 Linux 系统中可以安装ntp服务来自动同步系统时间。\n OutboundConfigurationObject  { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 37192, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34;, \u0026#34;alterId\u0026#34;: 0, \u0026#34;security\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }  vnext：[ ServerObject ]\n 一个数组，包含一组的服务端配置.\n其中每一项是一个服务端配置ServerObject。\n\nServerObject  { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 37192, \u0026#34;users\u0026#34;: [] }  address: address\n 服务端地址，支持 IP 地址或者域名。\nport: number\n 服务端监听的端口号, 必填。\nusers: [ UserObject ]\n 一个数组，代表一组服务端认可的用户.\n其中每一项是一个用户UserObject。\n\nUserObject  { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34;, \u0026#34;alterId\u0026#34;: 0, \u0026#34;security\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;level\u0026#34;: 0 }  id：string\n Vmess 的用户 ID，可以是任意小于30字节的字符串, 也可以是一个合法的UUID.  自定义字符串和其映射的 UUID 是等价的, 这意味着你将可以这样在配置文件中写id来标识同一用户,即\n 写 \u0026ldquo;id\u0026rdquo;: \u0026ldquo;我爱🍉老师1314\u0026rdquo;, 或写 \u0026ldquo;id\u0026rdquo;: \u0026ldquo;5783a3e7-e373-51cd-8642-c83782b807c5\u0026rdquo; (此UUID是 我爱🍉老师1314 的 UUID 映射)  其映射标准在VLESS UUID 映射标准：将自定义字符串映射为一个 UUIDv5\n你可以使用命令 xray uuid -map \u0026quot;自定义字符串\u0026quot; 生成自定义字符串所映射的的 UUID. 也可以使用命令 xray uuid 生成随机的UUID.\nalterId：number\n 为了进一步防止被探测，一个用户可以在主 ID 的基础上，再额外生成多个 ID。这里只需要指定额外的 ID 的数量，推荐值为 0 代表启用 VMessAEAD。\n最大值 65535。这个值不能超过服务器端所指定的值。\n不指定的话，默认值是 0。\nTIP\n客户端 AlterID 设置为 0 代表启用 VMessAEAD ；服务端为自动适配，可同时兼容启用和未开启 VMessAEAD 的客户端。\n客户端可通过设置环境变量 Xray_VMESS_AEAD_DISABLED=true 强行禁用 VMessAEAD\n level: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nsecurity: \u0026ldquo;aes-128-gcm\u0026rdquo; | \u0026ldquo;chacha20-poly1305\u0026rdquo; | \u0026ldquo;auto\u0026rdquo; | \u0026ldquo;none\u0026rdquo;\n 加密方式，客户端将使用配置的加密方式发送数据，服务器端自动识别，无需配置。\n \u0026quot;aes-128-gcm\u0026quot;：推荐在 PC 上使用 \u0026quot;chacha20-poly1305\u0026quot;：推荐在手机端使用 \u0026quot;auto\u0026quot;：默认值，自动选择（运行框架为 AMD64、ARM64 或 s390x 时为 aes-128-gcm 加密方式，其他情况则为 Chacha20-Poly1305 加密方式） \u0026quot;none\u0026quot;：不加密  TIP\n推荐使用\u0026quot;auto\u0026quot;加密方式，这样可以永久保证安全性和兼容性。\n "},{"uri":"https://xtls.github.io/config/transports/","title":"传输方式列表","tags":[],"description":"Project X 的文档.","content":" 这个章节包含了目前所有的传输方式及相关的具体配置. 传输方式列表 tcpSettings: TcpObject\n 针对 TCP 连接的配置。\nwsSettings: WebSocketObject\n 针对 WebSocket 连接的配置。\ndsSettings: DomainSocketObject\n 针对 Domain Socket 连接的配置。\nkcpSettings: KcpObject\n 针对 mKCP 连接的配置。\nhttpSettings: HttpObject\n 针对 HTTP/2 连接的配置。\nquicSettings: QuicObject\n 针对 QUIC 连接的配置。\ngrpcSettings: GRPCObject\n 针对 gRPC 连接的配置。\n"},{"uri":"https://xtls.github.io/caseslip/","title":"大案牍术","tags":[],"description":"Project X 的文档.","content":" 大案牍术记载了 Xray 历史上经过大量研究而破解的迷案, 虽然有些卷宗也许已经迷失在时空里… \n卷宗一览  结案 《大案牍术 卷宗一》\u0026ndash; \u0026ndash; 流量统计引起性能离奇下降事件\n 在开启统计以后居然发现性能有了出乎意外的变化. 数据显示各种协议组合,性能的折损各不相同. 隐藏在这些变化之后的秘密究竟是什么呢? 名侦探们经过了深入研究, 发现了秘密, 掌握了大量优化性能的新技能. 相关卷宗 流量统计功能会使裸协议的 ReadV 和 WriteV 同时失效 开启各种姿势的统计对各种协议组合性能影响的测试   经办@rprx @Arthur Morgan\n    结案 《大案牍术 卷宗二》\u0026ndash; \u0026ndash; IPv6 TCP无法使用tproxy 模式透明代理事件\n 一直以来 IPv6 TCP 都无法使用tproxy 模式透明代理. 名侦探抽丝剥茧解开了其中的隐秘, 解开了事件. 甚至发现了一些其他的代码的秘密. 相关卷宗 任意门 tproxy 模式无法透明代理 IPv6 TCP #48 有一部分丢失在时空中   经办@rprx @Arthur Morgan\n    结案 《大案牍术 卷宗三》 \u0026ndash; \u0026ndash; 我们是如何破解Splice性能下降甚至低于Direct之谜的\n splice上线以后,陆陆续续有一些用户反映\u0026quot;splice模式为什么比direct还慢\u0026quot; 反复测试后终于偶然复现了这个现象 于是进行了令人想哭的各种测试, 发现凶手竟然是\u0026hellip; 相关卷宗 我们是如何破解Splice性能下降甚至低于Direct之谜的 HARDWARE NAT   经办@rprx @Arthur Morgan\n    未结案 《大案牍术 卷宗五》 \u0026ndash; \u0026ndash; DS性能之谜?  DS应该更快, 然而事实不是想象的那样\u0026hellip; 究竟为何? 相关卷宗 DS 可能存在性能问题 DS性能测试   经办@rprx @Arthur Morgan\n    结案 《大案牍术 卷宗六》 \u0026ndash; \u0026ndash; 启动内存之优化优化再优化]\n 启动内存占用有人很少, 有人很多, 有人忽大忽小 名侦探们为了寻求真相, 开始了探索, 然而他们一开始甚至摸索到了错误的方向\u0026hellip; 当然最终, 他们解开了谜底, 并且让启动内存占用终于完美. 相关卷宗 希望能够优化一下内存占用   经办@rprx @AT!Mi @SekiBetu\n    结案 《大案牍术 卷宗七》 \u0026ndash; \u0026ndash; 一核有难, 多核围观?\n 从远古时代开始就有人说CPU会出现一核有难N核围观的现象,有人见过,也有人从来没见过 有一天这个现象终于被100%复现了, 于是名侦探们进行了深入的研究测试和分析. 在没有新的报告之前也许可以认为已经解决了\u0026hellip; 相关卷宗 虛擬機4核測速，只有1核跑滿，其餘3核沒盡全力跑 #81 多核服务端单核心负载问题 CPUNum测试   经办@rprx @Chris Chau @Arthur Morgan @ldmlz\n    结案 《大案牍术 卷宗八》 \u0026ndash; \u0026ndash; 彩虹六号! 消失的UDP!\n 某玩家在玩彩虹六号时会出现打一把就掉线的情况. 经过了无数次的测试和分析日志,对话了近百层,发现原因竟然是\u0026hellip; 名侦探们完美的解决了这个问题. 相关卷宗 用xray的shadowsocks协议玩彩虹六号会出现打一把就掉线的情况 #129   经办@rprx @GleenJi\n    结案 《大案牍术 卷宗九》 \u0026ndash; \u0026ndash; 充满疑惑的透明代理!  为何CPU资源占用率居高不下? 为何路由器自身不能解析域名? 名侦探们围绕这一系列问题展开了深入浅出的讨论. 相关卷宗 1.2.1版本的CPU资源占用率高的问题 #163 openwrt主路由iptables透明代理时，路由器自身不能解析域名 #185 openwrt主路由运行xray客户端启用doh后大量出现context deadline exceeded错误信息 #186   经办@nJhEqnvK @BioniCosmos @Ray Lin @Arthur Morgan @70599 @kirin10000\n    结案 《大案牍术 卷宗十》 \u0026ndash; \u0026ndash; 迷失的DNS请求回包! 再次消失的UDP!  gole的透明代理执行dig查询DNS时,只能对本地服务器有效,其余的服务器全部超时 子曦曦的透明代理亦是如此. 名侦探们开始再次寻找消失的UDP. 终于构建了100% 可以复现的场景. @Arthur Morgan : 能复现就等于能解决 @rprx : 又不难 简单改改 相关卷宗丢失在时空中\n 经办@rprx @Arthur Morgan\n    "},{"uri":"https://xtls.github.io/config/transports/grpc/","title":"gRPC","tags":[],"description":"Project X 的文档.","content":"基于 gRPC 的传输方式。\n它基于 HTTP/2 协议，理论上可以通过其它支持 HTTP/2 的服务器（如 Nginx）进行中转。\n 如果您使用 Caddy 或 Nginx 等反向代理，请务必使用 HTTP/2 或 h2c 连接到 Xray。 如果您使用回落，请留意 (x)tlsSettings.alpn 的值\n GRPCObject  GRPCObject 对应传输配置的 grpcSettings 项。\n{ \u0026#34;serviceName\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;multiMode\u0026#34;: false }  serviceName: string\n 一个字符串，指定服务路径，相当于 HTTP/2 与 WebSocket 中的 Path。\n客户端会使用此名称进行通信，服务器会验证服务名称是否匹配。\nmultiMode: bool\n 一个布尔值。表示是否启用 multiMode。 这是一个 实验性 选项，可能不会被长期保留，也不保证跨版本兼容。此模式在 测试环境中 能够带来约 20% 的性能提升，实际效果因传输速率不同而不同。\n"},{"uri":"https://xtls.github.io/links/","title":"常用链接","tags":[],"description":"Project X 的文档.","content":"安装脚本   Linux Script  Xray-install Xray-script 感谢@kirin   Docker  teddysun/xray 感谢@秋水逸冰 Xray-dockerIn progress   One Click  ProxySU 感谢@ProxySu Xray-agent 感谢@mack-a   Magisk  Xray4Magisk 感谢@子曦曦 Xray_For_Magisk 感谢@E7KMbb   Homebrew  Repository 0 感谢@N4FA Repository 1 感谢@Xirui Zhao    \n配置模板  所有的模板请传送至: Xray-examples\n包含了各种用法示范的终极配置: VLESS-TCP-XTLS-WHATEVER\n\n图形化客户端   OpenWrt  PassWall Hello World ShadowSocksR Plus+ luci-app-xray (openwrt-xray)   Windows  v2rayN Qv2ray   Android  v2rayNG Kitsunebi   iOS / Mac  Shadowrocket    \nUUID 生成器  第三方的 UUID 生成器 uuidgenerator.net\n"},{"uri":"https://xtls.github.io/documents/level-0/ch08-xray-clients/","title":"【第8章】Xray客户端篇","tags":[],"description":"小小白白话文","content":"8.1 Xray的工作原理简述  要正确的配置和使用Xray，就需要正确的理解其工作原理，对于新人，可以先看看下面简化的示意图（省略了许多复杂的设置）：\n这其中的关键点是：\n  APP要主动或借助转发工具，将数据【流入(inbounds)】Xray 客户端\n  流量进入客户端后，会被【客户端路由(routing)】按规则处理后，向不同方向【流出(outbounds)】Xray 客户端。比如：\n 国内流量直连（direct） 国外流量转发VPS（proxy） 广告流量屏蔽（block）    向VPS转发的国外流量，会跨过防火墙，【流入(inbounds)】 Xray 服务器端\n  流量进入服务器端后，与客户端一样，会被【服务器端路由(routing)】按规则处理后，向不同方向【流出(outbounds)】：\n 因为已经在防火墙之外，所以流量默认直连，你就可以访问到不存在网站们了（direct） 如果需要在不同的VPS之间做链式转发，就可以继续配置转发规则（proxy） 你可以在服务器端继续禁用各种你想禁用的流量，如广告、BT下载等（block）    注意： 请务必记得，Xray 的路由配置非常灵活，上面的说明只是无限可能性中的一种。\n借助 geosite.dat 和 geoip.dat 这两个文件，可以很灵活的从【域名】和【IP】这两个角度、不留死角的控制流量流出的方向。这比曾经单一笼统的 GFWList 强大很多很多，可以做到非常细致的微调：比如可以指定Apple域名直连或转发、指定亚马逊域名代理或转发，百度的域名屏蔽等等。。。）\n现在，《路由 (routing) 功能简析》 已经上线，我建议对路由功能有兴趣的同学，先继续跟着本文完成客户端的基础配置，之后再去这里详细学习。\n  8.2 客户端与服务器端正确连接  现在你已经理解了 Xray 的工作原理，那么接下来的配置，其实就是【告诉你的客户端如何连接VPS服务器】。这和你已经很熟悉的、告诉PuTTY如何远程连接服务器是一样的。只不过Xray连接时的要素不止是【IP地址】+【端口】+【用户名】+【密码】这四要素了。\n实际上，Xray的连接要素是由不同的协议决定的。本文在第7章的配置文件 config.json 里，我们使用 Xray 下独特而强大的 VLESS 协议 + XTLS 流控。所以看看那个配置文件的内容就能知道，这个协议组合的连接要素有：\n 服务器【地址】: a-name.yourdomain.com 服务器【端口】: 443 连接的【协议】: vless 连接的【流控】: xtls-rprx-direct (direct模式适合全平台，若是Linux/安卓用户，可改成 xtls-rprx-splice 性能全开) 连接的【验证】: uuiduuid-uuid-uuid-uuiduuiduuid 连接的【安全】: \u0026quot;allowInsecure\u0026quot;: false  鉴于新人一般都会使用手机APP或者电脑的GUI客户端，我就把常用的客户端罗列在下面。每个客户端都有自己独特的配置界面，逐一截图展示并不现实，所以请你务必仔细阅读这些客户端的说明、然后把上述要素填入合适的地方即可。\n注意： 许多工具其实是同时支持 xray-core 和 v2fly-core 的，但默认内置的不一定是哪个，所以别忘记检查一下是否是你想要的那个在工作哦！\n   v2rayN - 适用于Windows平台\n 请从它的GitHub仓库Release页面获取最新版 请根据该客户端的说明进行设置    v2rayNG - 适用于Android平台\n 请从它的GitHub仓库Release页面获取最新版 请根据该客户端的说明进行设置    Shadowrocket - 适用于iOS, 基于苹果M芯片的macOS\n 你需要注册一个【非中国区】的iCloud账户 你需要通过 App Store 搜索并购买 请根据该客户端的说明进行设置    Qv2ray - 跨平台图形界面，适用于Linux, Windows, macOS\n 请从它的GitHub仓库Release页面获取最新版（还可以从它的GitHub自动构建仓库寻找更新的版本） 请从它的项目主页学习文档 请根据该客户端的说明进行设置    到这一步，你的全套配置就已经可以正常使用啦！\n 8.3 附加题 1：在PC端手工配置 xray-core  虽然到上面一步已经可以结束了，但是如果你是个好奇心强、记忆力好的的同学，一定会想起来我在上一章说过，你把xray-core 的二进制文件“放在服务器运行，它就是服务器端；你把它下载到本地电脑运行，它就是客户端。” 那究竟要怎样直接使用 xray-core 做客户端呢？\n为了回答这个问题，我加入了附加题章节，有一点点超纲，有一点点麻烦，但费这个笔墨是因为这个方式有它的优势：\n  第一时间获得最新版而无需等待APP升级适配\n  灵活自由的路由配置能力（当然GUI客户端中Qv2ray的高级路由编辑器非常强大，也可以完整实现xray-core的路由配置功能）\n  节约系统资源 （GUI界面一定会有资源消耗，消耗的多少则取决于客户端的实现）\n  它的劣势应该就是【需要手写配置文件】有点麻烦了。但其实，你想想，服务器上你已经成功的写过一次了，现在又有什么区别呢？接下来，还是老样子，我们分解一下步骤：\n  首先请从Xray官方的 GitHub仓库Release页面 获取对应平台的版本，并解压缩到合适的文件夹\n  在合适的文件夹建立空白配置文件：config.json （自己常用平台下新建文件大家肯定都会，这就真不用啰嗦了）\n  至于什么是“合适的文件夹”？这就取决于具体的平台了~\n  填写客户端配置\n 我就以 8.1 原理说明里展示的基本三类分流（国内流量直连、国际流量转发VPS、广告流量屏蔽），结合 8.2 的连接要素，写成一个配置文件 请将 uuid 替换成与你服务器一致的 uuid 请将 address 替换成你的真实域名 请将 serverName 替换成你的真实域名 各个配置模块的说明我都已经（很啰嗦的）放在对应的配置点上了  // REFERENCE: // https://github.com/XTLS/Xray-examples // https://xtls.github.io/config/ // 常用的config文件，不论服务器端还是客户端，都有5个部分。外加小小白解读： // ┌─ 1_log 日志设置 - 日志写什么，写哪里（出错时有据可查） // ├─ 2_dns DNS-设置 - DNS怎么查（防DNS污染、防偷窥、避免国内外站匹配到国外服务器等） // ├─ 3_routing 分流设置 - 流量怎么分类处理（是否过滤广告、是否国内外分流） // ├─ 4_inbounds 入站设置 - 什么流量可以流入Xray // └─ 5_outbounds 出站设置 - 流出Xray的流量往哪里去 { // 1_日志设置 // 注意，本例中我默认注释掉了日志文件，因为windows, macOS, Linux 需要写不同的路径，请自行配置 \u0026#34;log\u0026#34;: { // \u0026#34;access\u0026#34;: \u0026#34;/home/local/xray_log/access.log\u0026#34;, // 访问记录 // \u0026#34;error\u0026#34;: \u0026#34;/home/local/xray_log/error.log\u0026#34;, // 错误记录 \u0026#34;loglevel\u0026#34;: \u0026#34;warning\u0026#34; // 内容从少到多: \u0026#34;none\u0026#34;, \u0026#34;error\u0026#34;, \u0026#34;warning\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;debug\u0026#34; }, // 2_DNS设置 \u0026#34;dns\u0026#34;: { \u0026#34;servers\u0026#34;: [ // 2.1 国外域名使用国外DNS查询 { \u0026#34;address\u0026#34;: \u0026#34;1.1.1.1\u0026#34;, \u0026#34;domains\u0026#34;: [ \u0026#34;geosite:geolocation-!cn\u0026#34; ] }, // 2.2 国内域名使用国内DNS查询，并期待返回国内的IP，若不是国内IP则舍弃，用下一个查询 { \u0026#34;address\u0026#34;: \u0026#34;223.5.5.5\u0026#34;, \u0026#34;domains\u0026#34;: [ \u0026#34;geosite:cn\u0026#34; ], \u0026#34;expectIPs\u0026#34;: [ \u0026#34;geoip:cn\u0026#34; ] }, // 2.3 作为2.2的备份，对国内网站进行二次查询 { \u0026#34;address\u0026#34;: \u0026#34;114.114.114.114\u0026#34;, \u0026#34;domains\u0026#34;: [ \u0026#34;geosite:cn\u0026#34; ] }, // 2.4 最后的备份，上面全部失败时，用本机DNS查询 \u0026#34;localhost\u0026#34; ] }, // 3_分流设置 // 所谓分流，就是将符合否个条件的流量，用指定`tag`的出站协议去处理（对应配置的5.x内容） \u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;rules\u0026#34;: [ // 3.1 广告域名屏蔽 { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:category-ads-all\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;block\u0026#34; }, // 3.2 国内域名直连 { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:cn\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct\u0026#34; }, // 3.3 国内IP直连 { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [ \u0026#34;geoip:cn\u0026#34;, \u0026#34;geoip:private\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct\u0026#34; }, // 3.4 国外域名代理 { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:geolocation-!cn\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;proxy\u0026#34; } // 3.5 默认规则 // 在Xray中，任何不符合上述路由规则的流量，都会默认使用【第一个outbound（5.1）】的设置，所以一定要把转发VPS的outbound放第一个 ] }, // 4_入站设置 \u0026#34;inbounds\u0026#34;: [ // 4.1 一般都默认使用socks5协议作本地转发 { \u0026#34;tag\u0026#34;: \u0026#34;socks-in\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;socks\u0026#34;, \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, // 这个是通过socks5协议做本地转发的地址 \u0026#34;port\u0026#34;: 10800, // 这个是通过socks5协议做本地转发的端口 \u0026#34;settings\u0026#34;: { \u0026#34;udp\u0026#34;: true } }, // 4.2 有少数APP不兼容socks协议，需要用http协议做转发，则可以用下面的端口 { \u0026#34;tag\u0026#34;: \u0026#34;http-in\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, // 这个是通过http协议做本地转发的地址 \u0026#34;port\u0026#34;: 10801 // 这个是通过http协议做本地转发的端口 } ], // 5_出站设置 \u0026#34;outbounds\u0026#34;: [ // 5.1 默认转发VPS // 一定放在第一个，在routing 3.5 里面已经说明了，这等于是默认规则，所有不符合任何规则的流量都走这个 { \u0026#34;tag\u0026#34;: \u0026#34;proxy\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;vless\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;a-name.yourdomain.com\u0026#34;, // 替换成你的真实域名 \u0026#34;port\u0026#34;: 443, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;uuiduuid-uuid-uuid-uuid-uuiduuiduuid\u0026#34;, // 和服务器端的一致 \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, // Windows, macOS 同学保持这个不变 // \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-splice\u0026#34;, // Linux和安卓同学请改成Splice性能更强 \u0026#34;encryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;xtls\u0026#34;, \u0026#34;xtlsSettings\u0026#34;: { \u0026#34;serverName\u0026#34;: \u0026#34;a-name.yourdomain.com\u0026#34;, // 替换成你的真实域名 \u0026#34;allowInsecure\u0026#34;: false // 禁止不安全证书 } } }, // 5.2 用`freedom`协议直连出站，即当routing中指定\u0026#39;direct\u0026#39;流出时，调用这个协议做处理 { \u0026#34;tag\u0026#34;: \u0026#34;direct\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34; }, // 5.3 用`blackhole`协议屏蔽流量，即当routing中指定\u0026#39;block\u0026#39;时，调用这个协议做处理 { \u0026#34;tag\u0026#34;: \u0026#34;block\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;blackhole\u0026#34; } ] }    8.4 附加题 2：在PC端手工运行 xray-core  写好了配置文件该，要怎么让 xray-core 运行起来呢？双击好像并没有反应啊？\n首先，你要找到电脑上的【命令行界面】。\n Linux桌面、macOS系统的同学肯定已经比较熟悉了，搜索 Console 或者 Terminal 就可以 Windows就可以搜索使用 Cmd 或者 Powershell 等程序（WSL的同学你坐下，你的 Console 当然也可以）  其次，我们要做的事情是【让 xray 找到并读取配置文件 config.json，然后运行】，所以：\n  在Windows下，假设你的 Xray 程序位置是 C:\\Xray-windows-64\\xray.exe，配置文件位置是C:\\Xray-windows-64\\config.json，那么正确的启动命令就是：\nC:\\Xray-windows-64\\xray.exe -c C:\\Xray-windows-64\\config.json  说明： 这里的 -c 就是指定配置文件路径的参数，告诉 xray 去后面的位置找配置文件\n   相似的，在Linux和macOS下，假设你的 Xray 程序位置是 /usr/local/bin/xray，配置文件位置是/usr/local/etc/xray/config.json，那么正确的启动命令就是\n$ /usr/local/bin/xray -c /usr/local/etc/xray/config.json  说明： 每个系统都有系统路径变量，所以写 Xray 程序时不一定要写绝对路径。但是写了肯定没错，所以我就如此演示了。\n    8.5 附加题 3：在PC端开机自动运行 xray-core  如果你真的尝试了手动运行 xray-core，你一定会发现这个方式还有点小问题：\n 每次运行 Xray 都要出现一个黑乎乎的窗口，很丑 不能开机自动运行，每次都要手工输入，十分不方便  我可以肯定的告诉你：完全可以解决。但是具体的解决方式，就当作课外作业留给大家吧！（友情提示，文档站的问答区有线索哦）\n 8.6 圆满完成！  我相信，有耐心看到这里的同学，都是兼具好奇心和行动力的学习派！我现在要郑重的恭喜你，因为到了这里，你已经完完整整的【从第一条命令开始，完成了VPS服务器部署，并成功的在客户端配置使用Xray】了！这毫无疑问是一个巨大的胜利！\n我相信，你现在一定对Linux不再恐惧，对Xray不再陌生了吧！\n至此，小小白白话文圆满结束！ ⬛⬛⬛⬛⬛⬛⬛⬛ 100%\n 8.7 TO INFINITY AND BEYOND!  但现在你看到的，远远不是Xray的全貌。\nXray是一个强大而丰富的网络工具集合，平台化的提供了众多模块，可以像瑞士军刀一样，通过灵活的配置组合解决各种不同的问题。而本文，仅仅蜻蜓点水的用了最简单、最直观的配置来做基础演示。\n如果你觉得现在已经完全够用了，那就好好的享受它给你带来的信息自由。但如果你的好奇心依然不能停歇，那就去继续挖掘它无限的可能性吧！\n需要更多信息，可以到这里寻找：\n xtls.github.io - 官方文档站 官方Telegram群组 - 活跃而友善的官方讨论社区  不算后记的后记：\n希望我陪你走过的这一段小小的旅程，可以成为你网络生活中的一份小小助力。\n这篇文章里的工具和信息难免会一点点的陈旧过时，但你一定会逐渐成长为大佬。未来的某个时间，若你能偶尔想起这篇教程、想起我写下本文的初衷，那我衷心希望你能够薪火相传、把最新的知识分享给后来人，让这一份小小的助力在社区里坚定的传递下去。\n这是个大雪封山乌云密布的世界，人们孤独的走在各自的路上试图寻找阳光，如果大家偶尔交汇时不能守望相助互相鼓励，那最终剩下的，恐怕只有【千山鸟飞绝 万径人踪灭】的凄凉了吧。\n "},{"uri":"https://xtls.github.io/config/inbound-protocols/shadowsocks/","title":"Shadowsocks","tags":[],"description":"Project X 的文档.","content":"Shadowsocks 协议，兼容大部分其它版本的实现。\n目前兼容性如下：\n  支持 TCP 和 UDP 数据包转发，其中 UDP 可选择性关闭；\n  推荐的加密方式：\n AES-256-GCM AES-128-GCM ChaCha20-Poly1305 或称 ChaCha20-IETF-Poly1305 none 或 plain  不推荐的加密方式:\n AES-256-CFB AES-128-CFB ChaCha20 ChaCha20-IETF    important\u0026ldquo;none\u0026rdquo; 不加密方式下，服务器端不会验证 \u0026ldquo;password\u0026rdquo; 中的密码。为确保安全性, 一般需要加上 TLS 并在传输层使用安全配置，例如 WebSocket 配置较长的 path\n InboundConfigurationObject { \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;aes-256-gcm\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;密码\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34; }  email: string\n 邮件地址，可选，用于标识用户\nmethod: string\n 必填。\n 推荐的加密方式：  AES-256-GCM AES-128-GCM ChaCha20-Poly1305 或称 ChaCha20-IETF-Poly1305 none 或 plain    password: string\n 必填，任意字符串。\nShadowsocks 协议不限制密码长度，但短密码会更可能被破解，建议使用 16 字符或更长的密码。\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nnetwork: \u0026ldquo;tcp\u0026rdquo; | \u0026ldquo;udp\u0026rdquo; | \u0026ldquo;tcp,udp\u0026rdquo;\n 可接收的网络协议类型。比如当指定为 \u0026quot;tcp\u0026quot; 时，仅会接收 TCP 流量。默认值为 \u0026quot;tcp\u0026quot;。\n"},{"uri":"https://xtls.github.io/config/outbound-protocols/trojan/","title":"Trojan","tags":[],"description":"Project X 的文档.","content":"Trojan 协议\nimportantTrojan 被设计工作在正确配置的加密 TLS 隧道\n OutboundConfigurationObject  { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;password\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] }  servers: [ ServerObject ]\n 一个数组，其中每一项是一个 ServerObject。\n\nServerObject  { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;password\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0 }  address: address\n 服务端地址，支持 IPv4、IPv6 和域名。必填。\nport: number\n 服务端端口，通常与服务端监听的端口相同。\npassword: string\n 密码. 必填，任意字符串。\nemail: string\n 邮件地址，可选，用于标识用户\nflow: string\n 流控模式，用于选择 XTLS 的算法。\n目前出站协议中有以下流控模式可选：\n xtls-rprx-origin：最初的流控模式。该模式纪念价值大于实际使用价值 xtls-rprx-origin-udp443：同 xtls-rprx-origin, 但放行了目标为 443 端口的 UDP 流量 xtls-rprx-direct：所有平台皆可使用的典型流控模式 xtls-rprx-direct-udp443：同 xtls-rprx-direct, 但是放行了目标为 443 端口的 UDP 流量 xtls-rprx-splice：Linux 平台下最建议使用的流控模式 xtls-rprx-splice-udp443：同 xtls-rprx-splice, 但是放行了目标为 443 端口的 UDP 流量  注意\n当 flow 被指定时，还需要将该出站协议的 streamSettings.security 一项指定为 xtls，tlsSettings 改为 xtlsSettings。详情请参考 streamSettings。\n此外，目前 XTLS 仅支持 TCP、mKCP、DomainSocket 这三种传输方式。\n 关于 xtls-rprx-*-udp443 流控模式\n启用了 Xray-core 的 XTLS 时，通往 UDP 443 端口的流量默认会被拦截（一般情况下为 QUIC），这样应用就不会使用 QUIC 而会使用 TLS，XTLS 才会真正生效。实际上，QUIC 本身也不适合被代理，因为 QUIC 自带了 TCP 的功能， 它作为 UDP 流量在通过 Trojan 协议传输时，底层协议为 TCP，就相当于两层 TCP 了。\n若不需要拦截，请在客户端填写 xtls-rprx-*-udp443，服务端不变。\n importantSplice 是 Linux Kernel 提供的函数，系统内核直接转发 TCP，不再经过 Xray 的内存，大大减少了数据拷贝、CPU 上下文切换的次数。\nSplice 模式的的使用限制：\n Linux 环境 入站协议为 Dokodemo door、Socks、HTTP 等纯净的 TCP 连接, 或其它使用了 XTLS 的入站协议 出站协议为 VLESS + XTLS 或 Trojan + XTLS  此外，使用 Splice 时网速显示会滞后，这是特性，不是 bug。\n需要注意的是，使用 mKCP 协议时不会使用 Splice（是的，虽然没有报错，但实际上根本没用到）。\n level: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n"},{"uri":"https://xtls.github.io/config/base/transport/","title":"传输方式","tags":[],"description":"Project X 的文档.","content":"传输方式（transport）是当前 Xray 节点和其它节点对接的方式。\n传输方式指定了稳定的数据传输的方式。通常来说，一个网络连接的两端需要有对称的传输方式。比如一端用了 WebSocket，那么另一个端也必须使用 WebSocket，否则无法建立连接。\n传输方式（transport）配置有两部分:\n  全局设置（TransportObject）\n  指定inbound/outbound配置（StreamSettingsObject）。\n指定inbound/outbound配置时,可以指定每个单独的inbound/outbound用怎样的方式传输。\n通常来说客户端和服务器对应的inbound和outbound需要使用同样的传输方式。当inbound/outbound配置指定了一种传输方式，但没有填写其具体设置时，此传输方式会使用全局配置中的设置。\n  \nTransportObject  TransportObject 对应配置文件的 transport 项。\n{ \u0026#34;transport\u0026#34;: { \u0026#34;tcpSettings\u0026#34;: {}, \u0026#34;kcpSettings\u0026#34;: {}, \u0026#34;wsSettings\u0026#34;: {}, \u0026#34;httpSettings\u0026#34;: {}, \u0026#34;quicSettings\u0026#34;: {}, \u0026#34;dsSettings\u0026#34;: {}, \u0026#34;grpcSettings\u0026#34;: {} } }  tcpSettings: TcpObject\n 针对 TCP 连接的配置。\nkcpSettings: KcpObject\n 针对 mKCP 连接的配置。\nwsSettings: WebSocketObject\n 针对 WebSocket 连接的配置。\nhttpSettings: HttpObject\n 针对 HTTP/2 连接的配置。\nquicSettings: QuicObject\n 针对 QUIC 连接的配置。\ngrpcSettings: GRPCObject\n 针对 gRPC 连接的配置。\ndsSettings: DomainSocketObject\n 针对 Domain Socket 连接的配置。\n\nStreamSettingsObject  StreamSettingsObject 对应inbound/outbound中的 streamSettings 项。每一个 inbound/outbound 都可以分别配置不同的传输配置，都可以设置 streamSettings 来进行一些传输的配置。\n{ \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;tlsSettings\u0026#34;: {}, \u0026#34;xtlsSettings\u0026#34;: {}, \u0026#34;tcpSettings\u0026#34;: {}, \u0026#34;kcpSettings\u0026#34;: {}, \u0026#34;wsSettings\u0026#34;: {}, \u0026#34;httpSettings\u0026#34;: {}, \u0026#34;quicSettings\u0026#34;: {}, \u0026#34;dsSettings\u0026#34;: {}, \u0026#34;grpcSettings\u0026#34;: {}, \u0026#34;sockopt\u0026#34;: { \u0026#34;mark\u0026#34;: 0, \u0026#34;tcpFastOpen\u0026#34;: false, \u0026#34;tproxy\u0026#34;: \u0026#34;off\u0026#34;, \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;dialerProxy\u0026#34;: \u0026#34;\u0026#34; } }  network: \u0026ldquo;tcp\u0026rdquo; | \u0026ldquo;kcp\u0026rdquo; | \u0026ldquo;ws\u0026rdquo; | \u0026ldquo;http\u0026rdquo; | \u0026ldquo;domainsocket\u0026rdquo; | \u0026ldquo;quic\u0026rdquo;\n 连接的数据流所使用的传输方式类型，默认值为 \u0026quot;tcp\u0026quot;\nsecurity: \u0026ldquo;none\u0026rdquo; | \u0026ldquo;tls\u0026rdquo; | \u0026ldquo;xtls\u0026rdquo;\n 是否启用传输层加密，支持的选项有\n \u0026quot;none\u0026quot; 表示不加密（默认值） \u0026quot;tls\u0026quot; 表示使用 TLS。 \u0026quot;xtls\u0026quot; 表示使用 XTLS。  tlsSettings: TLSObject\n TLS 配置。TLS 由 Golang 提供，通常情况下TLS协商的结果为使用 TLS 1.3，不支持 DTLS。\nxtlsSettings: XTLSObject\n XTLS 配置。XTLS 是 Xray 的原创黑科技, 也是使 Xray 性能一骑绝尘的核心动力.\nXTLS 与 TLS 有相同的安全性, 配置方式也和TLS一致. 点击此处查看XTLS的技术细节剖析 importantTLS / XTLS 是目前最安全的传输加密方案, 且外部看来流量类型和正常上网具有一致性.\n启用 XTLS 并且配置合适的XTLS流控模式, 可以在保持和 TLS 相同的安全性的前提下, 性能达到数倍甚至十几倍的提升.\n当 security 的值从\u0026rsquo;tls\u0026rsquo;改为\u0026rsquo;xtls\u0026rsquo;时, 只需将tlsSettings 修改成为 xtlsSettings\n tcpSettings: TcpObject\n 当前连接的 TCP 配置，仅当此连接使用 TCP 时有效。配置内容与上面的全局配置相同。\nkcpSettings: KcpObject\n 当前连接的 mKCP 配置，仅当此连接使用 mKCP 时有效。配置内容与上面的全局配置相同。\nwsSettings: WebSocketObject\n 当前连接的 WebSocket 配置，仅当此连接使用 WebSocket 时有效。配置内容与上面的全局配置相同。\nhttpSettings: HttpObject\n 当前连接的 HTTP/2 配置，仅当此连接使用 HTTP/2 时有效。配置内容与上面的全局配置相同。\nquicSettings: QUICObject\n 当前连接的 QUIC 配置，仅当此连接使用 QUIC 时有效。配置内容与上面的全局配置相同。\ngrpcSettings: GRPCObject\n 当前连接的 gRPC 配置，仅当此连接使用 gRPC 时有效。配置内容与上面的全局配置相同。\ndsSettings: DomainSocketObject\n 当前连接的 Domain socket 配置，仅当此连接使用 Domain socket 时有效。配置内容与上面的全局配置相同。\nsockopt: SockoptObject\n 透明代理相关的具体配置。\n\nTLSObject  { \u0026#34;serverName\u0026#34;: \u0026#34;xray.com\u0026#34;, \u0026#34;allowInsecure\u0026#34;: false, \u0026#34;alpn\u0026#34;: [ \u0026#34;h2\u0026#34;, \u0026#34;http/1.1\u0026#34; ], \u0026#34;minVersion\u0026#34;: \u0026#34;1.2\u0026#34;, \u0026#34;maxVersion\u0026#34;: \u0026#34;1.3\u0026#34;, \u0026#34;preferServerCipherSuites\u0026#34;: true, \u0026#34;cipherSuites\u0026#34;: \u0026#34;此处填写你需要的加密套件名称,每个套件名称之间用:进行分隔\u0026#34;, \u0026#34;certificates\u0026#34;: [], \u0026#34;disableSystemRoot\u0026#34;: false, \u0026#34;enableSessionResumption\u0026#34;: false }  serverName: string\n 指定服务器端证书的域名，在连接由 IP 建立时有用。\n当目标连接由域名指定时，比如在 Socks inbound接收到了域名，或者由 Sniffing 功能探测出了域名，这个域名会自动用于 serverName，无须手动配置。\nalpn: [ string ]\n 一个字符串数组，指定了 TLS 握手时指定的 ALPN 数值。默认值为 [\u0026quot;h2\u0026quot;, \u0026quot;http/1.1\u0026quot;]。\nminVersion: [ string ]\n minVersion为可接受的最小SSL/TLS版本。\nmaxVersion: [ string ]\n maxVersion为可接受的最大SSL/TLS版本。\npreferServerCipherSuites: true | false\n 指示服务器选择客户端最喜欢的密码套件 或 服务器最优选的密码套件。\n如果为true则为使用服务器的最优选的密码套件\ncipherSuites: [ string ]\n CipherSuites用于配置受支持的密码套件列表, 每个套件名称之间用:进行分隔.\n你可以在这里或这里找到golang加密套件的名词和说明\nimportant以上两项配置为非必要选项，正常情况下不影响安全性 在未配置的情况下golang根据设备自动选择. 若不熟悉, 请勿配置此选项, 填写不当引起的问题自行负责\n allowInsecure: true | false\n 是否允许不安全连接（仅用于客户端）。默认值为 false。\n当值为 true 时，Xray 不会检查远端主机所提供的 TLS 证书的有效性。\nimportant出于安全性考虑，这个选项不应该在实际场景中选择true，否则可能遭受中间人攻击。\n disableSystemRoot: true | false\n 是否禁用操作系统自带的 CA 证书。默认值为 false。\n当值为 true 时，Xray 只会使用 certificates 中指定的证书进行 TLS 握手。当值为 false 时，Xray 只会使用操作系统自带的 CA 证书进行 TLS 握手。\nenableSessionResumption: true | false\n 此参数的设置为false时, ClientHello 里没有 session_ticket 这个扩展。\n通常来讲 go 语言程序的 ClientHello 里并没有用到这个扩展, 因此建议保持默认值。\n默认值为 false。\ncertificates: [ CertificateObject ]\n 证书列表，其中每一项表示一个证书（建议 fullchain）。\nTIP\n如果要在 ssllibs 或者 myssl 获得 A/A+ 等级的评价, 请参考这里.\n CertificateObject { \u0026#34;ocspStapling\u0026#34;: 3600, \u0026#34;usage\u0026#34;: \u0026#34;encipherment\u0026#34;, \u0026#34;certificateFile\u0026#34;: \u0026#34;/path/to/certificate.crt\u0026#34;, \u0026#34;keyFile\u0026#34;: \u0026#34;/path/to/key.key\u0026#34;, \u0026#34;certificate\u0026#34;: [ \u0026#34;-----BEGIN CERTIFICATE-----\u0026#34;, \u0026#34;MIICwDCCAaigAwIBAgIRAO16JMdESAuHidFYJAR/7kAwDQYJKoZIhvcNAQELBQAw\u0026#34;, \u0026#34;ADAeFw0xODA0MTAxMzU1MTdaFw0xODA0MTAxNTU1MTdaMAAwggEiMA0GCSqGSIb3\u0026#34;, \u0026#34;DQEBAQUAA4IBDwAwggEKAoIBAQCs2PX0fFSCjOemmdm9UbOvcLctF94Ox4BpSfJ+\u0026#34;, \u0026#34;3lJHwZbvnOFuo56WhQJWrclKoImp/c9veL1J4Bbtam3sW3APkZVEK9UxRQ57HQuw\u0026#34;, \u0026#34;OzhV0FD20/0YELou85TwnkTw5l9GVCXT02NG+pGlYsFrxesUHpojdl8tIcn113M5\u0026#34;, \u0026#34;pypgDPVmPeeORRf7nseMC6GhvXYM4txJPyenohwegl8DZ6OE5FkSVR5wFQtAhbON\u0026#34;, \u0026#34;OAkIVVmw002K2J6pitPuJGOka9PxcCVWhko/W+JCGapcC7O74palwBUuXE1iH+Jp\u0026#34;, \u0026#34;noPjGp4qE2ognW3WH/sgQ+rvo20eXb9Um1steaYY8xlxgBsXAgMBAAGjNTAzMA4G\u0026#34;, \u0026#34;A1UdDwEB/wQEAwIFoDATBgNVHSUEDDAKBggrBgEFBQcDATAMBgNVHRMBAf8EAjAA\u0026#34;, \u0026#34;MA0GCSqGSIb3DQEBCwUAA4IBAQBUd9sGKYemzwPnxtw/vzkV8Q32NILEMlPVqeJU\u0026#34;, \u0026#34;7UxVgIODBV6A1b3tOUoktuhmgSSaQxjhYbFAVTD+LUglMUCxNbj56luBRlLLQWo+\u0026#34;, \u0026#34;9BUhC/ow393tLmqKcB59qNcwbZER6XT5POYwcaKM75QVqhCJVHJNb1zSEE7Co7iO\u0026#34;, \u0026#34;6wIan3lFyjBfYlBEz5vyRWQNIwKfdh5cK1yAu13xGENwmtlSTHiwbjBLXfk+0A/8\u0026#34;, \u0026#34;r/2s+sCYUkGZHhj8xY7bJ1zg0FRalP5LrqY+r6BckT1QPDIQKYy615j1LpOtwZe/\u0026#34;, \u0026#34;d4q7MD/dkzRDsch7t2cIjM/PYeMuzh87admSyL6hdtK0Nm/Q\u0026#34;, \u0026#34;-----END CERTIFICATE-----\u0026#34; ], \u0026#34;key\u0026#34;: [ \u0026#34;-----BEGIN RSA PRIVATE KEY-----\u0026#34;, \u0026#34;MIIEowIBAAKCAQEArNj19HxUgoznppnZvVGzr3C3LRfeDseAaUnyft5SR8GW75zh\u0026#34;, \u0026#34;bqOeloUCVq3JSqCJqf3Pb3i9SeAW7Wpt7FtwD5GVRCvVMUUOex0LsDs4VdBQ9tP9\u0026#34;, \u0026#34;GBC6LvOU8J5E8OZfRlQl09NjRvqRpWLBa8XrFB6aI3ZfLSHJ9ddzOacqYAz1Zj3n\u0026#34;, \u0026#34;jkUX+57HjAuhob12DOLcST8np6IcHoJfA2ejhORZElUecBULQIWzjTgJCFVZsNNN\u0026#34;, \u0026#34;itieqYrT7iRjpGvT8XAlVoZKP1viQhmqXAuzu+KWpcAVLlxNYh/iaZ6D4xqeKhNq\u0026#34;, \u0026#34;IJ1t1h/7IEPq76NtHl2/VJtbLXmmGPMZcYAbFwIDAQABAoIBAFCgG4phfGIxK9Uw\u0026#34;, \u0026#34;qrp+o9xQLYGhQnmOYb27OpwnRCYojSlT+mvLcqwvevnHsr9WxyA+PkZ3AYS2PLue\u0026#34;, \u0026#34;C4xW0pzQgdn8wENtPOX8lHkuBocw1rNsCwDwvIguIuliSjI8o3CAy+xVDFgNhWap\u0026#34;, \u0026#34;/CMzfQYziB7GlnrM6hH838iiy0dlv4I/HKk+3/YlSYQEvnFokTf7HxbDDmznkJTM\u0026#34;, \u0026#34;aPKZ5qbnV+4AcQfcLYJ8QE0ViJ8dVZ7RLwIf7+SG0b0bqloti4+oQXqGtiESUwEW\u0026#34;, \u0026#34;/Wzi7oyCbFJoPsFWp1P5+wD7jAGpAd9lPIwPahdr1wl6VwIx9W0XYjoZn71AEaw4\u0026#34;, \u0026#34;bK4xUXECgYEA3g2o9WqyrhYSax3pGEdvV2qN0VQhw7Xe+jyy98CELOO2DNbB9QNJ\u0026#34;, \u0026#34;8cSSU/PjkxQlgbOJc8DEprdMldN5xI/srlsbQWCj72wXxXnVnh991bI2clwt7oYi\u0026#34;, \u0026#34;pcGZwzCrJyFL+QaZmYzLxkxYl1tCiiuqLm+EkjxCWKTX/kKEFb6rtnMCgYEAx0WR\u0026#34;, \u0026#34;L8Uue3lXxhXRdBS5QRTBNklkSxtU+2yyXRpvFa7Qam+GghJs5RKfJ9lTvjfM/PxG\u0026#34;, \u0026#34;3vhuBliWQOKQbm1ZGLbgGBM505EOP7DikUmH/kzKxIeRo4l64mioKdDwK/4CZtS7\u0026#34;, \u0026#34;az0Lq3eS6bq11qL4mEdE6Gn/Y+sqB83GHZYju80CgYABFm4KbbBcW+1RKv9WSBtK\u0026#34;, \u0026#34;gVIagV/89moWLa/uuLmtApyEqZSfn5mAHqdc0+f8c2/Pl9KHh50u99zfKv8AsHfH\u0026#34;, \u0026#34;TtjuVAvZg10GcZdTQ/I41ruficYL0gpfZ3haVWWxNl+J47di4iapXPxeGWtVA+u8\u0026#34;, \u0026#34;eH1cvgDRMFWCgE7nUFzE8wKBgGndUomfZtdgGrp4ouLZk6W4ogD2MpsYNSixkXyW\u0026#34;, \u0026#34;64cIbV7uSvZVVZbJMtaXxb6bpIKOgBQ6xTEH5SMpenPAEgJoPVts816rhHdfwK5Q\u0026#34;, \u0026#34;8zetklegckYAZtFbqmM0xjOI6bu5rqwFLWr1xo33jF0wDYPQ8RHMJkruB1FIB8V2\u0026#34;, \u0026#34;GxvNAoGBAM4g2z8NTPMqX+8IBGkGgqmcYuRQxd3cs7LOSEjF9hPy1it2ZFe/yUKq\u0026#34;, \u0026#34;ePa2E8osffK5LBkFzhyQb0WrGC9ijM9E6rv10gyuNjlwXdFJcdqVamxwPUBtxRJR\u0026#34;, \u0026#34;cYTY2HRkJXDdtT0Bkc3josE6UUDvwMpO0CfAETQPto1tjNEDhQhT\u0026#34;, \u0026#34;-----END RSA PRIVATE KEY-----\u0026#34; ] }  ocspStapling: number\n ocspStapling 检查更新时间间隔。 单位：秒\nusage: \u0026ldquo;encipherment\u0026rdquo; | \u0026ldquo;verify\u0026rdquo; | \u0026ldquo;issue\u0026rdquo;\n 证书用途，默认值为 \u0026quot;encipherment\u0026quot;。\n \u0026quot;encipherment\u0026quot;：证书用于 TLS 认证和加密。 \u0026quot;verify\u0026quot;：证书用于验证远端 TLS 的证书。当使用此项时，当前证书必须为 CA 证书。 \u0026quot;issue\u0026quot;：证书用于签发其它证书。当使用此项时，当前证书必须为 CA 证书。  TIP 1\n在 Windows 平台上可以将自签名的 CA 证书安装到系统中，即可验证远端 TLS 的证书。\n TIP 2\n当有新的客户端请求时，假设所指定的 serverName 为 \u0026quot;xray.com\u0026quot;，Xray 会先从证书列表中寻找可用于 \u0026quot;xray.com\u0026quot; 的证书，如果没有找到，则使用任一 usage 为 \u0026quot;issue\u0026quot; 的证书签发一个适用于 \u0026quot;xray.com\u0026quot; 的证书，有效期为一小时。并将新的证书加入证书列表，以供后续使用。\n TIP 3\n当 certificateFile 和 certificate 同时指定时，Xray 优先使用 certificateFile。keyFile 和 key 也一样。\n TIP 4\n当 usage 为 \u0026quot;verify\u0026quot; 时，keyFile 和 key 可均为空。\n TIP 5\n使用 xray tls cert 可以生成自签名的 CA 证书。\n TIP 6\n如已经拥有一个域名, 可以使用工具便捷的获取免费第三方证书,如acme.sh\n certificateFile: string\n 证书文件路径，如使用 OpenSSL 生成，后缀名为 .crt。\ncertificate: [ string ]\n 一个字符串数组，表示证书内容，格式如样例所示。certificate 和 certificateFile 二者选一。\nkeyFile: string\n 密钥文件路径，如使用 OpenSSL 生成，后缀名为 .key。目前暂不支持需要密码的 key 文件。\nkey: [ string ]\n 一个字符串数组，表示密钥内容，格式如样例如示。key 和 keyFile 二者选一。\n\nSockoptObject  { \u0026#34;mark\u0026#34;: 0, \u0026#34;tcpFastOpen\u0026#34;: false, \u0026#34;tproxy\u0026#34;: \u0026#34;off\u0026#34;, \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;dialerProxy\u0026#34;: \u0026#34;\u0026#34; }  mark: number\n 一个整数。当其值非零时，在ountbound连接以此数值上标记 SO_MARK。\n 仅适用于 Linux 系统。 需要 CAP_NET_ADMIN 权限。  tcpFastOpen: true | false\n 是否启用 TCP Fast Open。\n当其值为 true 时，强制开启 TFO；当其值为 false 时，强制关闭 TFO；当此项不存在时，使用系统默认设置。 可用于inbound/ountbound。\n 仅在以下版本（或更新版本）的操作系统中可用:  Windows 10 (1604) Mac OS 10.11 / iOS 9 Linux 3.16：系统已默认开启，无需配置。    tproxy: \u0026ldquo;redirect\u0026rdquo; | \u0026ldquo;tproxy\u0026rdquo; | \u0026ldquo;off\u0026rdquo;\n 是否开启透明代理（仅适用于 Linux）。\n \u0026quot;redirect\u0026quot;：使用 Redirect 模式的透明代理。支持所有基于 IPv4/6 的 TCP 和 UDP 连接。 \u0026quot;tproxy\u0026quot;：使用 TProxy 模式的透明代理。支持所有基于 IPv4/6 的 TCP 和 UDP 连接。 \u0026quot;off\u0026quot;：关闭透明代理。  透明代理需要 Root 或 CAP_NET_ADMIN 权限。\nimportant当 Dokodemo-door 中指定了 followRedirect为true，且 Sockopt设置中的tproxy 为空时，Sockopt设置中的tproxy 的值会被设为 \u0026quot;redirect\u0026quot;。\n domainStrategy: \u0026ldquo;AsIs\u0026rdquo; | \u0026ldquo;UseIP\u0026rdquo; | \u0026ldquo;UseIPv4\u0026rdquo; | \u0026ldquo;UseIPv6\u0026rdquo;\n 在之前的版本中，当 Xray 尝试使用域名建立系统连接时，域名的解析由系统完成，不受 Xray 控制。这导致了在 非标准Linux环境中无法解析域名 等问题。为此，Xray 1.3.1 为 Sockopt 引入了 Freedom 中的 domainStrategy，解决了此问题。\n在目标地址为域名时, 配置相应的值, SysteDailer 的行为模式如下:\n \u0026quot;AsIs\u0026quot;: 通过系统DNS服务器解析获取IP, 向此域名发出连接。 \u0026quot;UseIP\u0026quot;、\u0026quot;UseIPv4\u0026quot; 和 \u0026quot;UseIPv6\u0026quot;: Xray 使用内置 DNS 服务器解析获取IP, 向此域名发出连接。  默认值为 \u0026quot;AsIs\u0026quot;。\nimportant如果启用了此功能，将有可能导致通过 代理服务器 代理 解析代理服务器IP的查询 的死循环。因此，不建议 经验不足的用户擅自使用此功能。\n dialerProxy: \u0026quot;\u0026quot;\n 一个出站代理的标识。当值不为空时，将使用指定的outbound发出连接。 此选项可用于支持底层传输方式的链式转发。\n此选项与 PorxySettingsObject.Tag 不兼容\n "},{"uri":"https://xtls.github.io/faq/about/","title":"关于Xray","tags":[],"description":"Project X 的文档.","content":" Q: XXX功能什么时候出来呀!康明宋\n Q: 为什么会开发 Xray ?兴趣使然\n Q: Xray收钱吗? 可以按我的要求定制吗?Xray 不沾钱,这是个兴趣使然的项目.\nXray 不接受定制, 只根据大家的需求进行兴趣使然的开发.\n Q: XXX也是你们开发的吗?请明辨您获取资源的来源, 小心使用, 谨防蜜罐\n我们的开发均托管在 github, 不在project X 仓库的, 都不属于 project X 开发.\n当然也有很多大佬支持着 Xray 的开发和完善了生态圈, 请见这里.\n我们也欢迎所有人一起来完善 Xray.\n Q: Xray 和 v2ray 还有 v2fly 是什么关系啊?禁忌の歷史迷局\nv2ray-core 项目是继Shadowsocks项目之后活跃的独立项目。\n但在2019年，原作者Victoria Raymond突然从 GitHub 项目、社交网站等失联，开发一度陷入停滞。\nv2fly项目组基于v2ray项目的技术基础，fork并成立了社区化项目v2fly。\n后续于2020年9月与 GitHub 官方沟通确认后，取消了与原 v2ray 项目的fork关系，正式成为独立的社区项目组织。\n随后，v2fly社区的贡献者之一 rprx，给v2fly项目带来了VLESS协议，回落分流，XTLS黑科技等一系列更新，v2fly项目进入了\u0026quot;腹泻式\u0026quot;更新时期。\nv2fly社区一些成员在某些技术选择及社区理念方面与 rprx 产生分歧。\n此后在一些其他外因的促使下，v2fly社区自 v4.33.0 版本起移除了其核心对 XTLS 的支持，但保留了 VLESS 协议支持。\n最终 rprx 决定独立分支并成立 project X 社区进行维护。\n2020年11月25日，Xray 1.0正式发布，成为了基于原 v2ray 项目基础的第二个社区分支版本。\nXray 一直保持着前行，并且在将来也会保持不断前行，您可以在大史记查看 Xray 一路前行中发生的各种杂事秘辛。\n Xray 项目的核心技术创新是：\n  VLESS 协议\n  回落分流 防主动探测, 强大而且灵活的分流.\n  XTLS 及流控 保证数据流获得标准TLS加密的同时，借助readV, Zero Copy等技术，最大限度减少数据流转过程中冗余的资源使用（表现为性能大幅提升、CPU 占用大幅降低、网速和延迟接近接近硬件的极限）\n  Xray 项目的核心社区理念是：\n  活跃的开发社区\nXray 保持着活跃的开发与更新，项目成立至今保持着每周有效更新的节奏，积极倾听社区反馈和用户痛点，快速迭代新特性、并持续解决历史遗留问题（详情可直接参考相关 release notes）\n  明确的价值追求\nXray项目组反对技术壁垒化、倡导社区分享和互助，坚定维护友善积极的社区氛围。\n   \n"},{"uri":"https://xtls.github.io/documents/level-0/ch09-appendix/","title":"【第9章】附录","tags":[],"description":"小小白白话文","content":"1. 小小白白Linux基础命令索引     编号 命令名称 命令说明 出现篇章     cmd-01 apt update 查询软件更新 《远程登录篇》   cmd-02 apt upgrade 执行软件更新 《远程登录篇》   cmd-03 nano 文本编辑器 《安全防护篇》   cmd-04 systemctl restart 重启某个服务 《安全防护篇》   cmd-05 adduser 给系统新增用户 《安全防护篇》   cmd-06 apt install 安装某个软件 《安全防护篇》   cmd-07 visudo 修改sudo权限设置专用编辑器 《安全防护篇》   cmd-08 sudo 用root权限运行某个命令 《安全防护篇》   cmd-09 chmod 修改目标文件/文件夹的权限 《安全防护篇》   cmd-10 mkdir 新建文件夹 《网站建设篇》   cmd-11 systemctl reload 重新加载某个服务 《网站建设篇》   cmd-12 wget 访问（或下载）某个网页文件 《证书管理篇》   cmd-13 acme.sh acme.sh证书管理相关的命令 《证书管理篇》   cmd-14 rm 删除命令 《Xray服务器篇》   cmd-15 crontab -e 编辑当前用户的定时任务 《Xray服务器篇》   cmd-16 touch 建立空白文件 《Xray服务器篇》   cmd-17 systemctl systemd基本服务管理命令 《Xray服务器篇》   cmd-18 reboot 重启Linux系统 《Xray服务器篇》     2. 小小白白Linux重要配置文件索引     编号 配置文件位置 文件说明 出现篇章     conf-01 /etc/ssh/sshd_config SSH远程登录程序设置 《远程登录篇》   conf-02 /etc/nginx/nginx.conf Nginx程序设置 《网站建设篇》   conf-03 /etc/apt/sources.list apt软件源列表 《Xray服务器篇》   conf-04 /etc/apt/sources.list.d/vpsadmin.list 用户自定义软件源列表列表 《Xray服务器篇》   conf-05 crontab -e 当前用户的定时任务 《Xray服务器篇》   conf-06 /etc/sysctl.conf 手动设置kernel参数 《Xray服务器篇》   conf-07 /etc/sysctl.d/vpsadmin.conf 用户自定义kernel参数配置文件 《Xray服务器篇》     3. 小小白白Xray重要文件索引     编号 配置文件位置 文件说明 出现篇章     xray-01 /usr/local/etc/xray/config.json Xray程序设置 《Xray服务器篇》   xray-02 /home/vpsadmin/xray_cert/xray.cert TLS证书 《Xray服务器篇》   xray-03 /home/vpsadmin/xray_cert/xray.key TLS私钥 《Xray服务器篇》   xray-04 /home/vpsadmin/xray_log/access.log Xray访问日志 《Xray服务器篇》   xray-05 /home/vpsadmin/xray_log/error.log Xray错误日志 《Xray服务器篇》    "},{"uri":"https://xtls.github.io/config/outbound-protocols/shadowsocks/","title":"Shadowsocks","tags":[],"description":"Project X 的文档.","content":"Shadowsocks 协议，兼容大部分其它版本的实现。\n目前兼容性如下：\n  支持 TCP 和 UDP 数据包转发，其中 UDP 可选择性关闭；\n  推荐的加密方式：\n AES-256-GCM AES-128-GCM ChaCha20-Poly1305 或称 ChaCha20-IETF-Poly1305 none 或 plain  不推荐的加密方式:\n AES-256-CFB AES-128-CFB ChaCha20 ChaCha20-IETF    important\u0026ldquo;none\u0026rdquo; 不加密方式下，服务器端不会验证 \u0026ldquo;password\u0026rdquo; 中的密码。为确保安全性, 一般需要加上 TLS 并在传输层使用安全配置，例如 WebSocket 配置较长的 path\n OutboundConfigurationObject  { \u0026#34;servers\u0026#34;: [ { \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;method\u0026#34;: \u0026#34;加密方式\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;密码\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] }  servers: [ServerObject]\n 一个数组，代表一组 Shadowsocks 服务端设置, 其中每一项是一个 ServerObject。\n\nServerObject  { \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;method\u0026#34;: \u0026#34;加密方式\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;密码\u0026#34;, \u0026#34;level\u0026#34;: 0 }  email: string\n 邮件地址，可选，用于标识用户\naddress: address\n Shadowsocks 服务端地址，支持 IPv4、IPv6 和域名。必填。\nport: number\n Shadowsocks 服务端端口。必填。\nmethod: string\n 必填。\n 推荐的加密方式：  AES-256-GCM AES-128-GCM ChaCha20-Poly1305 或称 ChaCha20-IETF-Poly1305 none 或 plain    password: string\n 必填。任意字符串。\nShadowsocks 协议不限制密码长度，但短密码会更可能被破解，建议使用 16 字符或更长的密码。\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n"},{"uri":"https://xtls.github.io/config/vless/","title":"VLESS 协议详解","tags":[],"description":"Project X 的文档.","content":" VLESS 是原创的无状态的轻量传输协议, 也是 Xray 一切的开始 \n协议详解  In progress\n 配置模板  Xray-examples 有完整的 VLESS 配置示例供参考。（但目前不能保证其它协议的配置示例质量）\n 客户端开发指引   VLESS 协议本身还会有不兼容升级，但客户端配置文件参数基本上是只增不减的。所以如果你开发了用 core 的客户端，现在就可以适配。 iOS 客户端的协议实现则需紧跟升级。 视觉标准：UI 标识请统一用 VLESS，而不是 VLess / Vless / vless，配置文件不受影响，代码内则顺其自然。 encryption 应做成输入框而不是选择框，新配置的默认值应为 none，若用户置空则应代填 none。  以下为已支持图形化配置 VLESS 的部分客户端列表，推荐使用：（排名不分先后顺序）\n OpenWrt  PassWall Hello World ShadowSocksR Plus+   Windows  v2rayN Qv2ray   Android  v2rayNG Kitsunebi   iOS / Mac  Shadowrocket     Fallbacks  Fallbacks 是 Xray 独创的新型协议回落模式解析, 可有效防止主动探测, 自由配置常用端口多服务共享.\n目前 Xray 中的 VLESS 和 trojan 协议支持Fallbacks.\n Fallbacks 配置说明 Fallbacks 功能简析 Fallbacks 设计理论   VLESS 分享链接标准  感谢@DuckSoft 的提案!\n目前为初步提案, 详情请见VMessAEAD / VLESS 分享链接标准提案\n"},{"uri":"https://xtls.github.io/config/base/stats/","title":"统计信息","tags":[],"description":"Project X 的文档.","content":"用于配置 Xray 流量数据的统计。\nStatsObject StatsObject 对应配置文件的 stats 项。\n{ \u0026#34;stats\u0026#34;: {} } 目前统计信息不需要任何参数，只要 StatsObject 项存在，内部的统计即会开启。\n开启了统计以后, 只需在 Policy 中开启对应的项，就可以统计对应的数据。\n\n获取统计信息  可以用 xray api 的相关命令获取统计信息.\n目前已有的统计信息如下：\n  用户数据\n  user\u0026gt;\u0026gt;\u0026gt;[email]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;uplink\n特定用户的上行流量，单位字节。\n  user\u0026gt;\u0026gt;\u0026gt;[email]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;downlink\n特定用户的下行流量，单位字节。\n  TIP\n如果对应用户没有指定 Email，则不会开启统计。\n   全局数据\n  inbound\u0026gt;\u0026gt;\u0026gt;[tag]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;uplink\n特定inbound的上行流量，单位字节。\n  inbound\u0026gt;\u0026gt;\u0026gt;[tag]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;downlink\n特定inbound的下行流量，单位字节。\n  outbound\u0026gt;\u0026gt;\u0026gt;[tag]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;uplink\n特定outbound的上行流量，单位字节。\n  outbound\u0026gt;\u0026gt;\u0026gt;[tag]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;downlink\n特定outbound的下行流量，单位字节。\n    "},{"uri":"https://xtls.github.io/config/fallback/","title":"Fallbacks","tags":[],"description":"Project X 的文档.","content":" Fallback 是 Xray 的最强大功能之一, 可有效防止主动探测, 自由配置常用端口多服务共享 \nfallback 为 Xray 提供了高强度的防主动探测性, 并且具有独创的首包回落机制.\nfallback 也可以将不同类型的流量根据 path 进行分流, 从而实现一个端口, 多种服务共享.\n目前您可以在使用 VLESS 或者 trojan 协议时, 通过配置 fallbacks 来使用回落这一特性, 并且创造出非常丰富的组合玩法.\n\nfallbacks 配置  \u0026#34;fallbacks\u0026#34;: [ { \u0026#34;dest\u0026#34;: 80 } ]  fallbacks: [ FallbackObject ]\n 一个数组，包含一系列强大的回落分流配置。\n\nFallbackObject  { \u0026#34;name\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;alpn\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;dest\u0026#34;: 80, \u0026#34;xver\u0026#34;: 0 } fallbacks 是一个数组，这里是其中一个子元素的配置说明。\nfallbacks 项是可选的，只能用于 TCP+TLS 传输组合\n 该项有子元素时，Inbound TLS 需设置 \u0026quot;alpn\u0026quot;:[\u0026quot;http/1.1\u0026quot;]。**  通常，你需要先设置一组 alpn 和 path 均省略或为空的默认回落，然后再按需配置其它分流。\nVLESS 会把 TLS 解密后首包长度 \u0026lt; 18 或协议版本无效、身份认证失败的流量转发到 dest 指定的地址。\n其它传输组合必须删掉 fallbacks 项或所有子元素，此时也不会开启 Fallback，VLESS 会等待读够所需长度，协议版本无效或身份认证失败时，将直接断开连接。\n name: string\n 尝试匹配 TLS SNI(Server Name Indication)，空为任意，默认为 \u0026quot;\u0026quot;\nalpn: string\n 尝试匹配 TLS ALPN 协商结果，空为任意，默认为 \u0026quot;\u0026quot;\n有需要时，VLESS 才会尝试读取 TLS ALPN 协商结果，若成功，输出 info realAlpn = 到日志。 用途：解决了 Nginx 的 h2c 服务不能同时兼容 http/1.1 的问题，Nginx 需要写两行 listen，分别用于 1.1 和 h2c。 注意：fallbacks alpn 存在 \u0026quot;h2\u0026quot; 时，Inbound TLS 需设置 \u0026quot;alpn\u0026quot;:[\u0026quot;h2\u0026quot;,\u0026quot;http/1.1\u0026quot;]，以支持 h2 访问。\nTIP\nFallback 内设置的 \u0026ldquo;alpn\u0026rdquo; 是匹配实际协商出的 ALPN，而 Inbound TLS 设置的 \u0026ldquo;alpn\u0026rdquo; 是握手时可选的 ALPN 列表，两者含义不同。\n path: string\n 尝试匹配首包 HTTP PATH，空为任意，默认为空，非空则必须以 \u0026quot;/\u0026quot; 开头，不支持 h2c。\n智能：有需要时，VLESS 才会尝试看一眼 PATH（不超过 55 个字节；最快算法，并不完整解析 HTTP），若成功，输出 info realPath = 到日志。 用途：分流其它 inbound 的 WebSocket 流量或 HTTP 伪装流量，没有多余处理、纯粹转发流量，实测比 Nginx 反代更强。\n注意：fallbacks 所在入站本身必须是 TCP+TLS，这是分流至其它 WS 入站用的，被分流的入站则无需配置 TLS。\ndest: string | number\n 决定 TLS 解密后 TCP 流量的去向，目前支持两类地址：（该项必填，否则无法启动）\n TCP，格式为 \u0026quot;addr:port\u0026quot;，其中 addr 支持 IPv4、域名、IPv6，若填写域名，也将直接发起 TCP 连接（而不走内置的 DNS）。 Unix domain socket，格式为绝对路径，形如 \u0026quot;/dev/shm/domain.socket\u0026quot;，可在开头加 \u0026quot;@\u0026quot; 代表 abstract，\u0026quot;@@\u0026quot; 则代表带 padding 的 abstract。  若只填 port，数字或字符串均可，形如 80、\u0026quot;80\u0026quot;，通常指向一个明文 http 服务（addr 会被补为 \u0026quot;127.0.0.1\u0026quot;）。\nxver: number\n 发送 PROXY protocol，专用于传递请求的真实来源 IP 和端口，填版本 1 或 2，默认为 0，即不发送。若有需要建议填 1。\n目前填 1 或 2，功能完全相同，只是结构不同，且前者可打印，后者为二进制。Xray 的 TCP 和 WS 入站均已支持接收 PROXY protocol。\nTIP\n若你正在 配置 Nginx 接收 PROXY protocol，除了设置 proxy_protocol 外，还需设置 set_real_ip_from，否则可能会出问题。\n \n补充说明   将匹配到最精确的子元素，与子元素的排列顺序无关。若配置了几个 alpn 和 path 均相同的子元素，则会以最后的为准。 回落分流均是解密后 TCP 层的转发，而不是 HTTP 层，只在必要时检查首包 PATH。 您可以查看更多的关于 Fallbacks 的使用技巧和心得  Fallbacks 功能简析     \nFallbacks 设计理论  In progress\n\n"},{"uri":"https://xtls.github.io/config/base/reverse/","title":"反向代理","tags":[],"description":"Project X 的文档.","content":"反向代理可以把服务器端的流量向客户端转发，即逆向流量转发。\n反向代理的大致工作原理如下:\n 假设在主机 A 中有一个网页服务器，这台主机没有公网 IP，无法在公网上直接访问。另有一台主机 B，它可以由公网访问。现在我们需要把 B 作为入口，把流量从 B 转发到 A。 在主机 A 中配置 Xray，称为bridge，在 B 中也配置 Xray，称为 portal。 bridge 会向 portal 主动建立连接，此连接的目标地址可以自行设定。portal 会收到两种连接，一是由 bridge 发来的连接，二是公网用户发来的连接。portal 会自动将两类连接合并。于是 bridge 就可以收到公网流量了。 bridge 在收到公网流量之后，会将其原封不动地发给主机 A 中的网页服务器。当然，这一步需要路由的协作。 bridge 会根据流量的大小进行动态的负载均衡。  TIP\n反向代理默认已开启 Mux，请不要在其用到的outbound上再次开启 Mux。\n 反向代理功能尚处于测试阶段，可能会有一些问题。\n \nReverseObject  ReverseObject 对应配置文件的 reverse 项。\n{ \u0026#34;reverse\u0026#34;: { \u0026#34;bridges\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; } ], \u0026#34;portals\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;portal\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; } ] } }  bridges: [BridgeObject]\n 数组，每一项表示一个 bridge。每个 bridge 的配置是一个 BridgeObject。\nportals: [PortalObject]\n 数组，每一项表示一个 portal。每个 portal 的配置是一个 PortalObject。\n\nBridgeObject  { \u0026#34;tag\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; }  tag: string\n 所有由 bridge 发出的连接，都会带有这个标识。可以在 路由配置 中使用 inboundTag 进行识别。\ndomain: string\n 指定一个域名，bridge 向 portal 建立的连接，都会使用这个域名进行发送。\n这个域名只作为 bridge 和 portal 的通信用途，不必真实存在。\n\nPortalObject  { \u0026#34;tag\u0026#34;: \u0026#34;portal\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; }  tag: string\n portal 的标识。在 路由配置 中使用 outboundTag 将流量转发到这个 portal。\ndomain: string\n 一个域名。当 portal 接收到流量时，如果流量的目标域名是此域名，则 portal 认为当前连接上 bridge 发来的通信连接。而其它流量则会被当成需要转发的流量。portal 所做的工作就是把这两类连接进行识别并拼接。\nTIP\n一个 Xray 既可以作为 bridge，也可以作为 portal，也可以同时两者，以适用于不同的场景需要。\n \n完整配置样例  TIP\n在运行过程中，建议先启用 bridge，再启用 portal。\n bridge配置  bridge 通常需要两个outbound，一个用于连接 portal，另一个用于发送实际的流量。也就是说，你需要用路由区分两种流量。\n反向代理配置:\n{ \u0026#34;bridges\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; } ] } outbound:\n{ \u0026#34;tag\u0026#34;: \u0026#34;out\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;redirect\u0026#34;: \u0026#34;127.0.0.1:80\u0026#34; // 将所有流量转发到网页服务器 } }, { \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;portal 的 IP 地址\u0026#34;, \u0026#34;port\u0026#34;: 1024, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34; } ] } ] }, \u0026#34;tag\u0026#34;: \u0026#34;interconn\u0026#34; } 路由配置:\n\u0026#34;routing\u0026#34;: { \u0026#34;rules\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;inboundTag\u0026#34;: [ \u0026#34;bridge\u0026#34; ], \u0026#34;domain\u0026#34;: [ \u0026#34;full:test.xray.com\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;interconn\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;inboundTag\u0026#34;: [ \u0026#34;bridge\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;out\u0026#34; } ] } \nportal配置  portal 通常需要两个inbound，一个用于接收 bridge 的连接，另一个用于接收实际的流量。同时你也需要用路由区分两种流量。\n反向代理配置:\n{ \u0026#34;portals\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;portal\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; // 必须和 bridge 的配置一样 } ] } inbound:\n{ \u0026#34;tag\u0026#34;: \u0026#34;external\u0026#34;, \u0026#34;port\u0026#34;: 80, // 开放 80 端口，用于接收外部的 HTTP 访问 \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 80, \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34; } }, { \u0026#34;port\u0026#34;: 1024, // 用于接收 bridge 的连接 \u0026#34;tag\u0026#34;: \u0026#34;interconn\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34; } ] } } 路由配置:\n\u0026#34;routing\u0026#34;: { \u0026#34;rules\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;inboundTag\u0026#34;: [ \u0026#34;external\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;portal\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;inboundTag\u0026#34;: [ \u0026#34;interconn\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;portal\u0026#34; } ] } "},{"uri":"https://xtls.github.io/config/base/fakedns/","title":"FakeDNS","tags":[],"description":"Project X 的文档.","content":"FakeDNS 通过伪造 DNS 以获取目标域名，能够降低 DNS 查询时的延迟、配合透明代理获取目标域名。\nFakeDNS 有可能会污染本地 DNS，导致 Xray 关闭后“无法访问网络”。\n \nFakeDNSObject  FakeDNSObject 对应配置文件的 fakedns 项。\n{ \u0026#34;ipPool\u0026#34;: \u0026#34;198.18.0.0/16\u0026#34;, \u0026#34;poolSize\u0026#34;: 65535 }  ipPool: CIDR\n FakeDNS 将使用此选项指定的 IP 块分配地址。\npoolSize: int\n 指定 FakeDNS 储存的 域名-IP 映射的最大数目。当映射数超过此值后，会按照 LRU 规则淘汰映射。默认为 65535。\n\n如何使用？ FakeDNS 本质上是一个 DNS 服务器，能够与任意 DNS 规则配合使用。\nTIP\n只有将 DNS 查询路由到 FakeDNS，才能使其发挥作用。\n 另外，你需要在入站中开启 Sniffing ，并使用 fakedns 目标地址重置。\nimportantTIP\n如果 FakeIP 没有被正确的还原为域名，将无法连接到服务器。\n "},{"uri":"https://xtls.github.io/config/xtls/","title":"XTLS 深度剖析","tags":[],"description":"Project X 的文档.","content":" XTLS 是 Xray 的原创黑科技, 也是使 Xray 性能一骑绝尘的核心动力 \nIn progress\n"},{"uri":"https://xtls.github.io/config/env/","title":"环境变量","tags":[],"description":"Project X 的文档.","content":"Xray 提供以下环境变量以供修改 Xray 的一些底层配置。\n\nXTLS 信息显示  VLESS   名称：xray.vless.xtls.show 或 XRAY_VLESS_XTLS_SHOW。 默认值：\u0026quot;\u0026quot;。  使用 VLESS 协议时,设置此环境变量为 true 时, 会在终端或日志中输出 XTLS 的相关信息.\nTIP\n可打开此环境变量并根据是否有输出 XTLS 相关信息, 来确定 XTLS 是否成功被应用.\n TROJAN   名称：xray.trojan.xtls.show 或 XRAY_TROJAN_XTLS_SHOW。 默认值：\u0026quot;\u0026quot;。  使用 trojan 协议时, 设置此环境变量为 true 时, 会在终端或日志中输出 XTLS 的相关信息.\nTIP\n可打开此环境变量并根据是否有输出 XTLS 相关信息, 来确定 XTLS 是否成功被应用.\n \n资源文件路径   名称：xray.location.asset 或 XRAY_LOCATION_ASSET。 默认值：和 Xray 文件同路径。  这个环境变量指定了一个文件夹位置，这个文件夹应当包含 geoip.dat 和 geosite.dat 文件。\n\n配置文件位置   名称：xray.location.config 或 XRAY_LOCATION_CONFIG。 默认值：和 Xray 文件同路径。  这个环境变量指定了一个文件夹位置，这个文件夹应当包含 config.json 文件。\n\n多配置目录   名称：xray.location.confdir 或 XRAY_LOCATION_CONFDIR。 默认值：\u0026quot;\u0026quot;。  这个目录内的 .json 文件会按文件名顺序读取，作为多配置选项。\n\n"},{"uri":"https://xtls.github.io/config/multiple_config/","title":"多文件配置","tags":[],"description":"Project X 的文档.","content":"Xray 程序支持使用多个配置文件。\n多配置文件的主要作用在于分散不同作用模块配置，便于管理和维护。\n该功能主要考虑是为了丰富 Xray 的生态链，比如对于 GUI 的客户端，一般只实现节点选择等固定的功能，对于太复杂的配置难以图形化实现；只需留一个 confdir 的自定义配置目录供配置复杂的功能；对于服务器的部署脚本，只需往 confdir 添加文件即可实现配置多种协议。\n多文件启动  TIP\n启动信息中会提示依次读入的每个配置文件，留意启动信息是否符合你预设的顺序。\n $ xray run -confdir /etc/xray/confs 也可使用 Xray.location.confdir 或 Xray_LOCATION_CONFDIR 指定 confdir。\n参数 -confdir 的作用优先于环境变量，如果参数指定了有效的目录则不再读取环境变量中的路径。\n\n规则说明  普通对象（{}）  在 json 的顶级对象当中，后者覆盖或补充前者。\n比如：\n base.json  { \u0026#34;log\u0026#34;: {}, \u0026#34;api\u0026#34;: {}, \u0026#34;dns\u0026#34;: {}, \u0026#34;stats\u0026#34;: {}, \u0026#34;policy\u0026#34;: {}, \u0026#34;transport\u0026#34;: {}, \u0026#34;routing\u0026#34;: {}, \u0026#34;inbounds\u0026#34;: [] }  outbounds.json  { \u0026#34;outbounds\u0026#34;: [] } 以多配置启动 Xray：\n$ xray run -confdir /etc/xray/confs 这两个配置文件的就等效于合成一起的整配置。当需要修改出口节点，只需要修改 outbounds.json 内容。\n如果需要改编日志 log 的级别，也不需要改 base.json，只需后续增加一个配置：\n debuglog.json  { \u0026#34;log\u0026#34;: { \u0026#34;loglevel\u0026#34;: \u0026#34;debug\u0026#34; } } 启动顺序放置在 base 后，即可输出 debug 级别的日志\n\n数组（[]）  在 json 配置中的inbounds和outbounds是数组结构，他们有特殊的规则：\n 当配置中的数组元素有 2 或以上，覆盖前者的 inbounds/oubounds； 当配置中的数组元素只有 1 个时，查找原有tag相同的元素进行覆盖；若无法找到：  对于 inbounds，添加至最后（inbounds 内元素顺序无关） 对于 outbounds，添加至最前（outbounds 默认首选出口）；但如果文件名含有 tail（大小写均可），添加至最后。    借助多配置，可以很方便为原有的配置添加不同协议的 inbound，而不必修改原有配置。\n以下例子不是有效配置，只为展示上述规则。\n 000.json  { \u0026#34;inbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;socks\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;socks\u0026#34;, \u0026#34;port\u0026#34;: 1234 } ] }  001.json  { \u0026#34;inbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;http\u0026#34; } ] }  002.json  { \u0026#34;inbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;socks\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;socks\u0026#34;, \u0026#34;port\u0026#34;: 4321 } ] } 三个配置将会合成为：\n{ \u0026#34;inbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;socks\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;socks\u0026#34;, \u0026#34;port\u0026#34;: 4321 // \u0026lt;--- 002顺序在000后，因此覆盖tag为socks的inbound端口为4321 }, { \u0026#34;protocol\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;http\u0026#34; } ] } \n推荐的多文件列表  执行：\nfor BASE in 00_log 01_api 02_dns 03_routing 04_policy 05_inbounds 06_outbounds 07_transport 08_stats 09_reverse; do echo \u0026#39;{}\u0026#39; \u0026gt; \u0026#34;/etc/Xray/$BASE.json\u0026#34;; done 或\nfor BASE in 00_log 01_api 02_dns 03_routing 04_policy 05_inbounds 06_outbounds 07_transport 08_stats 09_reverse; do echo \u0026#39;{}\u0026#39; \u0026gt; \u0026#34;/usr/local/etc/Xray/$BASE.json\u0026#34;; done . ├── 00_log.json ├── 01_api.json ├── 02_dns.json ├── 03_routing.json ├── 04_policy.json ├── 05_inbounds.json ├── 06_outbounds.json ├── 07_transport.json ├── 08_stats.json └── 09_reverse.json 0 directories, 10 files "},{"uri":"https://xtls.github.io/","title":"","tags":[],"description":"","content":"\n  \n\n不 畏 浮 云 遮 望 眼 · 金 睛 如 炬 耀 苍 穹  不 畏 浮 云 遮 望 眼 金 睛 如 炬 耀 苍 穹  K E E P \u0026nbsp; R I D I N G \u0026nbsp; / \u0026nbsp; N E V E R \u0026nbsp; L O O K \u0026nbsp; B A C K  K E E P \u0026nbsp; R I D I N G \u0026nbsp; N E V E R \u0026nbsp; L O O K \u0026nbsp; B A C K   由此开始  \n  极速协议 原创 VLESS 轻量协议 摆脱冗余加密\n原创 XTLS 及 Direct/Splice流控 释放CPU算力\n 自由回落 完善的回落机制 有效防止主动探测\n自由配置常用端口 多服务共享\n 超低占用 适合 OpenWRT RaspberryPi 等\n各种精简设备皆可使用\n 跨平台 Windows, macOS, Linux, iOS, Android\u0026hellip; \n各种平台皆可用\n 强兼容 完整兼容 v2ray-core 配置文件\n完整兼容 v2ray-core API 调用\n 亲和力 活跃的社区讨论及贡献\nMPL 2.0 开源许可协议\n   \n\n"},{"uri":"https://xtls.github.io/404.html","title":"Whoops! Page not found","tags":[],"description":"This is a 404 page","content":"That page can\u0026rsquo;t be found.\nOur latest content is on the homepage.\nPhoto by Aron Visuals on Unsplash"}]