import{_ as c,r as t,o as r,c as d,a,b as o,d as e,e as s}from"./app-CFfdwgaj.js";const l={},u=s(`<h1 id="httpupgrade" tabindex="-1"><a class="header-anchor" href="#httpupgrade"><span>HTTPUpgrade</span></a></h1><p>一个实现了类似于 WebSocket 进行 HTTP 1.1 升级请求和响应的协议，这使得它可以像 WebSocket 一样可以被CDN或者Nginx进行反代，但无需实现 WebSocket 协议的其他部分，所以具有更高的效率。 其设计不推荐单独使用，而是和TLS等安全协议一起工作。</p><h2 id="httpupgradeobject" tabindex="-1"><a class="header-anchor" href="#httpupgradeobject"><span>HttpUpgradeObject</span></a></h2><p><code>HttpUpgradeObject</code> 对应传输配置的 <code>httpupgradeSettings</code> 项。</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;acceptProxyProtocol&quot;</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token property">&quot;path&quot;</span><span class="token operator">:</span> <span class="token string">&quot;/&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;host&quot;</span><span class="token operator">:</span> <span class="token string">&quot;xray.com&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;headers&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;key&quot;</span><span class="token operator">:</span> <span class="token string">&quot;value&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>acceptProxyProtocol</code>: true | false</p></blockquote><p>仅用于 inbound，指示是否接收 PROXY protocol。</p>`,7),i={href:"https://www.haproxy.org/download/2.2/doc/proxy-protocol.txt",target:"_blank",rel:"noopener noreferrer"},h=o("strong",null,"若你不了解它，请先忽略该项",-1),k=s("<p>常见的反代软件（如 HAProxy、Nginx）都可以配置发送它，VLESS fallbacks xver 也可以发送它。</p><p>填写 <code>true</code> 时，最底层 TCP 连接建立后，请求方必须先发送 PROXY protocol v1 或 v2，否则连接会被关闭。</p><blockquote><p><code>path</code>: string</p></blockquote><p>HTTPUpgrade 所使用的 HTTP 协议路径，默认值为 <code>&quot;/&quot;</code>。</p><p>如果客户端路径中包含 <code>ed</code> 参数(如 <code>/mypath?ed=2560</code>)，将会启用 <code>Early Data</code> 以降低延迟，其值为首包长度阈值。如果首包长度超过此值，就不会启用 <code>Early Data</code>。建议的值为2560。</p><blockquote><p><code>host</code>: string</p></blockquote><p>HTTPUpgrade 的HTTP请求中所发送的host，默认值为空。若服务端值为空时，不验证客户端发送来的host值。</p><p>当在服务端指定该值，或在 <code>headers</code> 中指定host，将会校验与客户端请求host是否一致。</p><p>客户端选择发送的host优先级 <code>host</code> &gt; <code>headers</code> &gt; <code>address</code></p><blockquote><p><code>headers</code>: map {string: string}</p></blockquote><p>仅客户端，自定义 HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是字符串。</p><p>默认值为空。</p>",12);function b(g,v){const n=t("I18nTip"),p=t("ExternalLinkIcon");return r(),d("div",null,[a(n),u,o("p",null,[o("a",i,[e("PROXY protocol"),a(p)]),e(" 专用于传递请求的真实来源 IP 和端口，"),h,e("。")]),k])}const _=c(l,[["render",b],["__file","httpupgrade.html.vue"]]);export{_ as default};
