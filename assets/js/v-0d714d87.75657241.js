"use strict";(self.webpackChunkXray_docs_next=self.webpackChunkXray_docs_next||[]).push([[3767],{69534:(e,r,a)=>{a.r(r),a.d(r,{data:()=>l});const l={key:"v-0d714d87",path:"/config/features/browser_dialer.html",title:"Browser Dialer",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"Background",slug:"background",children:[]},{level:2,title:"Xray & JS",slug:"xray-js",children:[]},{level:2,title:"Early data",slug:"early-data",children:[]},{level:2,title:"Configuration",slug:"configuration",children:[]}],filePathRelative:"config/features/browser_dialer.md",git:{updatedTime:1625482451e3,contributors:[{name:"hmol233",email:"82594500+hmol233@users.noreply.github.com",commits:1}]}}},1536:(e,r,a)=>{a.r(r),a.d(r,{default:()=>v});var l=a(66252);const i=(0,l._)("h1",{id:"browser-dialer",tabindex:"-1"},[(0,l._)("a",{class:"header-anchor",href:"#browser-dialer","aria-hidden":"true"},"#"),(0,l.Uk)(" Browser Dialer")],-1),n=(0,l.Uk)(),o=(0,l._)("h2",{id:"background",tabindex:"-1"},[(0,l._)("a",{class:"header-anchor",href:"#background","aria-hidden":"true"},"#"),(0,l.Uk)(" Background")],-1),t=(0,l.Uk)("基于 "),d={href:"https://github.com/v2ray/discussion/issues/754#issuecomment-647934994",target:"_blank",rel:"noopener noreferrer"},c=(0,l.Uk)("一年前的想法"),u=(0,l.Uk)(" ，利用原生 JS 实现了简洁的 WSS Browser Dialer，达到了真实浏览器的 TLS 指纹、行为特征。"),s=(0,l.uE)('<p>不过 WSS 仍存在 ALPN 明显的问题，所以下一步是浏览器转发 <code>HTTP/2</code>,<code>QUIC</code>。</p><h2 id="xray-js" tabindex="-1"><a class="header-anchor" href="#xray-js" aria-hidden="true">#</a> Xray &amp; JS</h2><p>创造了一个非常简单、巧妙的通信机制：</p><ul><li>Xray 监听地址端口 A，作为 HTTP 服务，浏览器访问 A，加载网页中的 JS。</li><li>JS 主动向 A 建立 WebSocket 连接，成功后，Xray 将连接发给 channel。</li><li>需要建立连接时，Xray 从 channel 接收一个可用的连接，并发送目标 URL 和可选的 early data。</li><li>JS 成功连接到目标后告知 Xray，并继续用这个 conn 全双工双向转发数据，连接关闭行为同步。</li><li>连接使用后就会被关闭，但 JS 会确保始终有新空闲连接可用。</li></ul><h2 id="early-data" tabindex="-1"><a class="header-anchor" href="#early-data" aria-hidden="true">#</a> Early data</h2><p>根据浏览器的需求，对 early data 机制进行了如下调整：</p>',6),h=(0,l._)("li",null,[(0,l.Uk)("服务端响应头会带有请求的 "),(0,l._)("code",null,"Sec-WebSocket-Protocol"),(0,l.Uk)("，这也初步混淆了 WSS 握手响应的长度特征。")],-1),k=(0,l._)("li",null,[(0,l.Uk)("用于浏览器的 early data 编码是 "),(0,l._)("code",null,"base64.RawURLEncoding"),(0,l.Uk)(" 而不是 "),(0,l._)("code",null,"StdEncoding"),(0,l.Uk)("，服务端做了兼容。")],-1),y=(0,l.Uk)("此外，由于 "),g={href:"https://github.com/XTLS/Xray-core/pull/375",target:"_blank",rel:"noopener noreferrer"},_=(0,l.Uk)("Xray-core#375"),p=(0,l.Uk)(" 推荐 "),b=(0,l._)("code",null,"?ed=2048",-1),f=(0,l.Uk)("，这个 PR 顺便将服务端一处 "),S=(0,l._)("code",null,"MaxHeaderBytes",-1),m=(0,l.Uk)(" 扩至了 4096。 "),U=(0,l._)("s",null,"（虽然好像不改也没问题）",-1),x={id:"configuration",tabindex:"-1"},w=(0,l._)("a",{class:"header-anchor",href:"#configuration","aria-hidden":"true"},"#",-1),X=(0,l.Uk)(" Configuration "),W=(0,l.uE)("<p>这是一个探索的过程，目前两边都是 Xray-core v1.4.1 时的配置方式：</p><ul><li>准备一份可用的 WSS 配置，注意 address 必须填域名，若需要指定 IP，请配置 DNS 或系统 hosts。</li><li>若浏览器的流量也会经过 Xray-core，务必将这个域名设为直连，否则会造成流量回环。</li><li>设置环境变量指定要监听的地址端口，比如 <code>XRAY_BROWSER_DIALER = 127.0.0.1:8080</code>。</li><li>先运行 Xray-core，再用任意浏览器访问上面指定的地址端口，还可以 <code>F12</code> 看 <code>Console</code> 和 <code>Network</code>。</li><li>浏览器会限制 WebSocket 连接数，所以建议开启 <code>Mux.Cool</code>。</li></ul>",2),v={render:function(e,r){const a=(0,l.up)("Badge"),v=(0,l.up)("OutboundLink");return(0,l.wg)(),(0,l.iD)(l.HY,null,[i,(0,l.Wm)(a,{text:"BETA",type:"warning"}),n,(0,l.Wm)(a,{text:"v1.4.1+",type:"warning"}),o,(0,l._)("p",null,[t,(0,l._)("a",d,[c,(0,l.Wm)(v)]),u]),s,(0,l._)("ul",null,[h,k,(0,l._)("li",null,[y,(0,l._)("a",g,[_,(0,l.Wm)(v)]),p,b,f,S,m,U])]),(0,l._)("h2",x,[w,X,(0,l.Wm)(a,{text:"v1.4.1",type:"warning"})]),W],64)}}}}]);