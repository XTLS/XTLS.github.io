"use strict";(self.webpackChunkXray_docs_next=self.webpackChunkXray_docs_next||[]).push([[6499],{38867:(e,t,n)=>{n.r(t),n.d(t,{data:()=>i});const i={key:"v-94110980",path:"/en/development/protocols/vmess.html",title:"VMess Protocol",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"Version",slug:"version",children:[]},{level:2,title:"Dependencies",slug:"dependencies",children:[{level:3,title:"Underlying Protocol",slug:"underlying-protocol",children:[]},{level:3,title:"User ID",slug:"user-id",children:[]},{level:3,title:"Functions",slug:"functions",children:[]}]},{level:2,title:"Communication Process",slug:"communication-process",children:[]},{level:2,title:"Client Request",slug:"client-request",children:[{level:3,title:"Authentication Information",slug:"authentication-information",children:[]},{level:3,title:"Command Section",slug:"command-section",children:[]},{level:3,title:"Data Section",slug:"data-section",children:[]}]},{level:2,title:"Server Response",slug:"server-response",children:[{level:3,title:"Dynamic Port Instructions",slug:"dynamic-port-instructions",children:[]}]},{level:2,title:"Comment",slug:"comment",children:[]}],filePathRelative:"en/development/protocols/vmess.md",git:{updatedTime:1695326765e3,contributors:[{name:"Eggwite",email:"69743130+Eggwite@users.noreply.github.com",commits:1},{name:"Kevin Amiri",email:"amiri990.us@gmail.com",commits:1},{name:"hmol233",email:"82594500+hmol233@users.noreply.github.com",commits:1}]}}},57309:(e,t,n)=>{n.r(t),n.d(t,{default:()=>A});var i=n(66252);const a=(0,i.uE)('<h1 id="vmess-protocol" tabindex="-1"><a class="header-anchor" href="#vmess-protocol" aria-hidden="true">#</a> VMess Protocol</h1><p>VMess is an encrypted transmission protocol that can serve as a bridge between the Xray client and server.</p><h2 id="version" tabindex="-1"><a class="header-anchor" href="#version" aria-hidden="true">#</a> Version</h2><p>The current version number is 1.</p><h2 id="dependencies" tabindex="-1"><a class="header-anchor" href="#dependencies" aria-hidden="true">#</a> Dependencies</h2><h3 id="underlying-protocol" tabindex="-1"><a class="header-anchor" href="#underlying-protocol" aria-hidden="true">#</a> Underlying Protocol</h3><p>VMess is a TCP-based protocol where all data is transmitted over TCP.</p><h3 id="user-id" tabindex="-1"><a class="header-anchor" href="#user-id" aria-hidden="true">#</a> User ID</h3>',8),l=(0,i.Uk)("An ID is equivalent to a "),r={href:"https://en.wikipedia.org/wiki/Universally_unique_identifier",target:"_blank",rel:"noopener noreferrer"},s=(0,i.Uk)("UUID"),o=(0,i.Uk)(", which is a 16-byte long random number. Its function is similar to a token. An ID looks like: "),d=(0,i._)("code",null,"de305d54-75b4-431b-adb2-eb6b9e546014",-1),h=(0,i.Uk)(", it is almost entirely random and can be generated using any UUID generator, such as "),c={href:"https://www.uuidgenerator.net/",target:"_blank",rel:"noopener noreferrer"},u=(0,i.Uk)("this one"),y=(0,i.Uk)("."),m=(0,i._)("p",null,[(0,i.Uk)("User ID can be specified in the "),(0,i._)("a",{href:"../../config"},"configuration file"),(0,i.Uk)(".")],-1),p=(0,i._)("h3",{id:"functions",tabindex:"-1"},[(0,i._)("a",{class:"header-anchor",href:"#functions","aria-hidden":"true"},"#"),(0,i.Uk)(" Functions")],-1),g=(0,i.Uk)("MD5: "),b={href:"https://en.wikipedia.org/wiki/MD5",target:"_blank",rel:"noopener noreferrer"},f=(0,i.Uk)("MD5 Function"),x=(0,i._)("ul",null,[(0,i._)("li",null,"Input parameter is any length byte array"),(0,i._)("li",null,"Output is a 16-byte array")],-1),v=(0,i.Uk)("HMAC: "),k={href:"https://en.wikipedia.org/wiki/Hash-based_message_authentication_code",target:"_blank",rel:"noopener noreferrer"},M=(0,i.Uk)("HMAC Function"),w=(0,i._)("ul",null,[(0,i._)("li",null,[(0,i.Uk)("Input parameters are: "),(0,i._)("ul",null,[(0,i._)("li",null,"H: Hash function"),(0,i._)("li",null,"K: Key, any length byte array"),(0,i._)("li",null,"M: Message, any length byte array")])])],-1),I=(0,i.Uk)("Shake: "),C={href:"https://en.wikipedia.org/wiki/SHA-3",target:"_blank",rel:"noopener noreferrer"},B=(0,i.Uk)("SHA3-Shake128 Function"),_=(0,i._)("ul",null,[(0,i._)("li",null,"Input parameter is any length string"),(0,i._)("li",null,"Output is any length string")],-1),D=(0,i.uE)('<h2 id="communication-process" tabindex="-1"><a class="header-anchor" href="#communication-process" aria-hidden="true">#</a> Communication Process</h2><p>VMess is a stateless protocol, which means that data can be transmitted directly between the client and the server without the need for a handshake. Each data transmission has no impact on other data transmissions before or after it.</p><p>When a VMess client initiates a request, the server checks whether the request comes from a legitimate client. If the validation passes, the server forwards the request and sends the obtained response back to the client.</p><p>VMess uses an asymmetric format, meaning that the requests sent by the client and the responses from the server use different formats.</p><h2 id="client-request" tabindex="-1"><a class="header-anchor" href="#client-request" aria-hidden="true">#</a> Client Request</h2><table><thead><tr><th>16 Bytes</th><th>X Bytes</th><th>Remaining</th></tr></thead><tbody><tr><td>Authentication Information</td><td>Instruction Part</td><td>Data Part</td></tr></tbody></table><h3 id="authentication-information" tabindex="-1"><a class="header-anchor" href="#authentication-information" aria-hidden="true">#</a> Authentication Information</h3><p>The authentication information is a 16-byte hash (hash) value, which is calculated as follows:</p><ul><li>H = MD5</li><li>K = User ID (16 bytes)</li><li>M = UTC time accurate to seconds, with a random value of ±30 seconds from the current time (8 bytes, Big Endian)</li><li>Hash = HMAC(H, K, M)</li></ul><h3 id="command-section" tabindex="-1"><a class="header-anchor" href="#command-section" aria-hidden="true">#</a> Command Section</h3><p>The instruction part is encrypted using AES-128-CFB.</p><ul><li>Key: MD5(user ID + []byte(&#39;c48619fe-8f02-49e0-b9e9-edf763e17e21&#39;))</li><li>IV: MD5(X + X + X + X), X = []byte(time generated by authentication information) (8 bytes, Big Endian)</li></ul><table><thead><tr><th style="text-align:center;">1 Byte</th><th style="text-align:center;">16 Bytes</th><th style="text-align:center;">16 Bytes</th><th style="text-align:center;">1 Byte</th><th style="text-align:center;">1 Byte</th><th style="text-align:center;">4 bits</th><th style="text-align:center;">4 bits</th><th style="text-align:center;">1 Byte</th><th style="text-align:center;">1 Byte</th><th style="text-align:center;">2 Bytes</th><th style="text-align:center;">1 Byte</th><th style="text-align:center;">N Bytes</th><th style="text-align:center;">P Bytes</th><th style="text-align:center;">4 Bytes</th></tr></thead><tbody><tr><td style="text-align:center;">Version</td><td style="text-align:center;">Data Encryption IV</td><td style="text-align:center;">Data Encryption Key</td><td style="text-align:center;">Response Authentication Value</td><td style="text-align:center;">Options</td><td style="text-align:center;">Reserved</td><td style="text-align:center;">Encryption Method</td><td style="text-align:center;">Reserved</td><td style="text-align:center;">Command</td><td style="text-align:center;">Port</td><td style="text-align:center;">Address Type</td><td style="text-align:center;">Address</td><td style="text-align:center;">Random Value</td><td style="text-align:center;">Checksum</td></tr></tbody></table><p>Options Opt Details: (When a bit is 1, it means the option is enabled)</p><table><thead><tr><th style="text-align:center;">0</th><th style="text-align:center;">1</th><th style="text-align:center;">2</th><th style="text-align:center;">3</th><th style="text-align:center;">4</th><th style="text-align:center;">5</th><th style="text-align:center;">6</th><th style="text-align:center;">7</th></tr></thead><tbody><tr><td style="text-align:center;">X</td><td style="text-align:center;">X</td><td style="text-align:center;">X</td><td style="text-align:center;">X</td><td style="text-align:center;">X</td><td style="text-align:center;">M</td><td style="text-align:center;">R</td><td style="text-align:center;">S</td></tr></tbody></table><p>of which:</p><ul><li>Version Number Ver: Always 1;</li><li>Data Encryption IV: Random value;</li><li>Data Encryption Key: Random value;</li><li>Response Authentication V: Random value;</li><li>Option Opt: <ul><li>S (0x01): Standard format data stream (recommended);</li><li>R (0x02): Client expects to reuse TCP connection (deprecated in Xray 2.23+); <ul><li>This item only takes effect when S is enabled;</li></ul></li><li>M (0x04): Enable metadata obfuscation (recommended); <ul><li>This item only takes effect when S is enabled;</li><li>When this item is enabled, the client and server need to construct two Shake instances respectively, RequestMask = Shake (request data IV), ResponseMask = Shake (response data IV).</li></ul></li><li>X: Reserved</li></ul></li><li>Redundancy P: Random value added before checksum value;</li><li>Encryption Method: Specify the encryption method for the data part, and the optional values are: <ul><li>0x00: AES-128-CFB;</li><li>0x01: No encryption;</li><li>0x02: AES-128-GCM;</li><li>0x03: ChaCha20-Poly1305;</li></ul></li><li>Instruction Cmd: <ul><li>0x01: TCP data;</li><li>0x02: UDP data;</li></ul></li><li>Port Port: Integer port number in Big Endian format;</li><li>Address Type T: <ul><li>0x01: IPv4</li><li>0x02: Domain name</li><li>0x03: IPv6</li></ul></li><li>Address A: <ul><li>When T = 0x01, A is a 4-byte IPv4 address;</li><li>When T = 0x02, A is a 1-byte length (L) + L-byte domain name;</li><li>When T = 0x03, A is a 16-byte IPv6 address;</li></ul></li><li>Check F: FNV1a hash of all content in the instruction except F.</li></ul><h3 id="data-section" tabindex="-1"><a class="header-anchor" href="#data-section" aria-hidden="true">#</a> Data Section</h3><p>When Opt(S) is enabled, this format is used for the data section. The actual request data is divided into several small chunks, and each chunk has the following format. After the server verifies all the small chunks, it will be forwarded in the basic format.</p><table><thead><tr><th style="text-align:center;">2 Bytes</th><th style="text-align:center;">L Bytes</th></tr></thead><tbody><tr><td style="text-align:center;">Length L</td><td style="text-align:center;">Data Packet</td></tr></tbody></table><p>in which:</p><ul><li>Length L: A big-endian integer with a maximum value of 2^14. <ul><li>When Opt(M) is enabled, the value of L is equal to the true value xor Mask. Mask = (RequestMask.NextByte() &lt;&lt; 8) + RequestMask.NextByte();</li></ul></li><li>Packet: A data packet encrypted by the specified encryption method.</li></ul><p>Before the transmission is completed, the data packet must contain actual data, in addition to the length and authentication data. When the transmission is complete, the client must send an empty data packet, that is, L = 0 (unencrypted) or the length of the authentication data (encrypted), to indicate the end of the transmission.</p><p>The packets are formatted as follows, depending on the encryption method:</p><ul><li>Unencrypted:   - L bytes: actual data;</li><li>AES-128-CFB: The entire data section is encrypted using AES-128-CFB.   - 4 bytes: FNV1a hash of actual data;   - L - 4 bytes: actual data;</li><li>AES-128-GCM: Key is the Key of the instruction section, IV = count (2 bytes) + IV (10 bytes). count starts at 0 and increases by 1 for each packet; IV is the 3rd to 12th byte of the instruction section IV.   - L - 16 bytes: actual data;   - 16 bytes: GCM authentication information</li><li>ChaCha20-Poly1305: Key = MD5 (instruction part Key) + MD5 (MD5 (instruction part Key)), IV = count (2 bytes) + IV (10 bytes). count starts at 0 and increases by 1 for each packet; IV is the 3rd to 12th byte of the instruction section IV.   - L - 16 bytes: actual data;   - 16 bytes: Poly1305 authentication information</li></ul><h2 id="server-response" tabindex="-1"><a class="header-anchor" href="#server-response" aria-hidden="true">#</a> Server Response</h2><p>The header data is encrypted using AES-128-CFB encryption. The IV is MD5 of the data encryption IV, and the Key is MD5 of the data encryption Key. The actual response data varies depending on the encryption settings.</p><table><thead><tr><th>1 Byte</th><th>1 Byte</th><th>1 Byte</th><th>1 Byte</th><th>M Bytes</th><th>Remaining Part</th></tr></thead><tbody><tr><td>Response Authentication V</td><td>Option Opt</td><td>Command Cmd</td><td>Command Length M</td><td>Command Content</td><td>Actual Response Data</td></tr></tbody></table><p>in which：</p><ul><li>Response Authentication V: must match the response authentication V in the client request.</li><li>Option Opt: <ul><li>0x01: server prepares to reuse TCP connections (deprecated in Xray 2.23+).</li></ul></li><li>Command Cmd: <ul><li>0x01: dynamic port command.</li></ul></li><li>Actual response data: <ul><li>If Opt(S) in the request is enabled, the standard format is used. Otherwise, the basic format is used.</li><li>Both formats are identical to the request data. <ul><li>When Opt(M) is enabled, the value of length L is equal to the true value XOR Mask. Mask = (ResponseMask.NextByte() &lt;&lt; 8) + ResponseMask.NextByte().</li></ul></li></ul></li></ul><h3 id="dynamic-port-instructions" tabindex="-1"><a class="header-anchor" href="#dynamic-port-instructions" aria-hidden="true">#</a> Dynamic Port Instructions</h3><table><thead><tr><th>1 Byte</th><th>2 Bytes</th><th>16 Bytes</th><th>2 Bytes</th><th>1 Byte</th><th>1 Byte</th></tr></thead><tbody><tr><td>Reserved</td><td>Port</td><td>User ID</td><td>AlterID</td><td>User level</td><td>Validity period T</td></tr></tbody></table><p>in which:</p><ul><li>Port: Integer port number in Big Endian format</li><li>T: Number of minutes as integer value.</li></ul><p>When the client receives a dynamic port command, the server opens a new port for communication. The client can then send data to the new port. After T minutes, the port will expire, and the client must use the main port to communicate again.</p><h2 id="comment" tabindex="-1"><a class="header-anchor" href="#comment" aria-hidden="true">#</a> Comment</h2><ul><li>To ensure forward compatibility, the values of all reserved fields must be 0.</li></ul>',37),A={render:function(e,t){const n=(0,i.up)("OutboundLink");return(0,i.wg)(),(0,i.iD)(i.HY,null,[a,(0,i._)("p",null,[l,(0,i._)("a",r,[s,(0,i.Wm)(n)]),o,d,h,(0,i._)("a",c,[u,(0,i.Wm)(n)]),y]),m,p,(0,i._)("ul",null,[(0,i._)("li",null,[g,(0,i._)("a",b,[f,(0,i.Wm)(n)]),x]),(0,i._)("li",null,[v,(0,i._)("a",k,[M,(0,i.Wm)(n)]),w]),(0,i._)("li",null,[I,(0,i._)("a",C,[B,(0,i.Wm)(n)]),_])]),D],64)}}}}]);