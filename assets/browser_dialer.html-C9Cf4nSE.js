import{_ as c,r as s,o as h,c as d,a as t,d as o,b as e,w as i,e as u}from"./app-D67lhmby.js";const p={},b=e("h1",{id:"browser-dialer",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#browser-dialer"},[e("span",null,"Browser Dialer")])],-1),_=e("h2",{id:"background",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#background"},[e("span",null,"Background")])],-1),w=e("p",null,[o("Xray generally uses uTLS to mimic the behavior of popular browsers, and it can be controlled through the "),e("code",null,"fingerprint"),o(" setting. However, the fingerprints produced by uTLS are an imperfect replica of the real thing, and because uTLS is a popular library, they may be targeted themselves.")],-1),f={href:"https://github.com/v2ray/discussion/issues/754#issuecomment-647934994",target:"_blank",rel:"noopener noreferrer"},g=e("code",null,"localhost:8080",-1),m=e("p",null,"The TLS fingerprinting behavior is perfect this way, and so it may be possible to revive servers that open fine as websites in the browser, but do not connect using any proxying software.",-1),y=e("p",null,"However, there are many drawbacks:",-1),T=e("li",null,"The user has to launch a browser next to the Xray client just for opening the proxy connection.",-1),S=e("li",null,"The browser dialer must not be tunneled through the proxy itself, otherwise there is a loop. TUN users should be cautious.",-1),k={href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS",target:"_blank",rel:"noopener noreferrer"},v=e("code",null,"localhost:8080",-1),x=e("code",null,"proxy.example.com:443",-1),R=e("li",null,"The browser tunnels your traffic using JavaScript, so there is a significant performance penalty (or, battery drain)",-1),L=e("li",null,[o("The configuration to be used with browser dialer cannot use custom SNI or host headers. "),e("code",null,"SNI == host == address"),o(". Custom HTTP headers and "),e("code",null,"tlsSettings"),o(" are ignored entirely.")],-1),X=u('<h2 id="configuration" tabindex="-1"><a class="header-anchor" href="#configuration"><span>Configuration</span></a></h2><ol><li>Prepare a usable WebSocket or SplitHTTP configuration. Be aware of the above restrictions.</li><li>Launch Xray with <code>XRAY_BROWSER_DIALER=127.0.0.1:8080</code>. On Windows, this can be done as <code>set XRAY_BROWSER_DIALER=...</code> and then launching the core from the console, on Linux the core can be launched as <code>XRAY_BROWSER_DIALER=127.0.0.1:8080 ./xray -c config.json</code>.</li><li>Open a browser that is not tunneled through the proxy, or modify the config&#39;s routing such that the Xray server&#39;s domain goes to <code>freedom</code> directly from the client. Browse to <code>localhost:8080</code>, and open the developer console with <code>F12</code> to monitor for errors.</li><li>For better performance and to bypass arbitrary connection limits enforced by the browser, it is recommended to enable <code>Mux.Cool</code>.</li></ol><h2 id="inner-workings" tabindex="-1"><a class="header-anchor" href="#inner-workings"><span>Inner workings</span></a></h2><ul><li>Xray listens on <code>http://127.0.0.1:8080</code>, and the browser accesses <code>http://127.0.0.1:8080</code> to load the <code>JS</code> in the webpage.</li><li>The <code>JS</code> actively establishes a WebSocket connection to <code>http://127.0.0.1:8080</code>. Xray will use this connection to send instructions, but for now it goes into a connection pool (implemented as Go channel).</li><li>When a connection needs to be established, Xray receives an available connection from the pool and sends the protocol name, target URL and optional early data.</li><li>Once the <code>JS</code> successfully connects to the target, it informs Xray and continues to use this conn to bi-directionally forward data.</li><li>After the connection to the server is closed, the connection to localhost is also closed, but the JS ensures that there is always at least one idle connection available.</li></ul><h2 id="websocket" tabindex="-1"><a class="header-anchor" href="#websocket"><span>WebSocket</span></a></h2>',5),B=e("p",null,"According to the browser's needs, the early data mechanism has been adjusted as follows:",-1),I=e("li",null,[o("The server response header will contain the requested "),e("code",null,"Sec-WebSocket-Protocol"),o(", which also initially obfuscates the length characteristic of the WSS handshake response.")],-1),E=e("li",null,[o("The encoding used for early data for browsers is "),e("code",null,"base64.RawURLEncoding"),o(" instead of "),e("code",null,"StdEncoding"),o(", and the server has made it compatible.")],-1),H={href:"https://github.com/XTLS/Xray-core/pull/375",target:"_blank",rel:"noopener noreferrer"},P=e("code",null,"?ed=2048",-1),W=e("code",null,"MaxHeaderBytes",-1),A=e("s",null,"(Although it seems like it would work without modification.)",-1),C=e("h2",{id:"splithttp",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#splithttp"},[e("span",null,"SplitHTTP")])],-1),O=e("p",null,[o("SplitHTTP supports QUIC, but the browser's own QUIC stack may be used as well. In Chrome this can be done through "),e("code",null,"chrome://flags"),o(", in other browsers it may already be enabled or need a different flag.")],-1),N=e("p",null,[o("In general, "),e("code",null,"tlsSettings"),o(" are completely ignored when Browser Dialer is used. Xray does not have any control over which HTTP version the browser selects.")],-1);function J(U,D){const l=s("I18nTip"),n=s("Badge"),r=s("ExternalLinkIcon"),a=s("RouterLink");return h(),d("div",null,[t(l),b,t(n,{text:"BETA",type:"warning"}),o(),t(n,{text:"v1.4.1+",type:"warning"}),_,w,e("p",null,[o("So "),e("a",f,[o("the idea of browser dialer"),t(r)]),o(" is that Xray uses a real browser to establish TLS connections. The way this works is that Xray hosts a small website on "),g,o(", the user opens this website in a browser of their choice, and JavaScript on that page will act as Xray's networking stack (HTTP client, TLS client).")]),m,y,e("ul",null,[T,S,e("li",null,[o("The browser can only speak standard HTTP, which means that only "),t(a,{to:"/en/transports/websocket.html"},{default:i(()=>[o("WebSocket")]),_:1}),o(" and "),t(a,{to:"/en/transports/splithttp.html"},{default:i(()=>[o("SplitHTTP")]),_:1}),o(" are supported")]),e("li",null,[e("a",k,[o("CORS"),t(r)]),o(" needs to be considered when making requests from one website ("),v,o(") to another ("),x,o(")")]),R,L]),X,t(n,{text:"v1.4.1+",type:"warning"}),B,e("ul",null,[I,E,e("li",null,[o("In addition, due to "),e("a",H,[o("Xray-core#375"),t(r)]),o(" recommendations for "),P,o(", this PR also increased server "),W,o(" by 4096. "),A])]),C,t(n,{text:"v1.8.19+",type:"warning"}),O,N])}const j=c(p,[["render",J],["__file","browser_dialer.html.vue"]]);export{j as default};
