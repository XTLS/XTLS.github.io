import{_ as i,r as e,o as l,c as u,a,b as n,d as s,w as r,e as p}from"./app-5zWpXwXh.js";const d={},v=n("h1",{id:"splithttp-h2-quic-h3",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#splithttp-h2-quic-h3"},[n("span",null,"SplitHTTP (H2, QUIC H3)")])],-1),k=p(`<p>Используется для загрузки с помощью HTTP-фрагментированной передачи, загрузка осуществляется с помощью нескольких HTTP POST-запросов.</p><p>Может использоваться через CDN, не поддерживающие WebSocket, но есть несколько требований:</p><ul><li>CDN должен поддерживать HTTP-фрагментированную передачу и потоковые ответы без буферизации. Ядро будет отправлять различную информацию, чтобы сообщить CDN об этом, но CDN должна ее соблюдать. Если промежуточный узел не поддерживает потоковые ответы и зависает, этот транспорт, скорее всего, не будет работать.</li></ul><p>Цель та же, что и у V2fly Meek, но благодаря использованию фрагментированной загрузки скорость загрузки выше, а скорость отдачи оптимизирована, но все еще очень ограничена, поэтому к HTTP-прокси предъявляются более высокие требования (см. выше).</p><p><code>SplitHTTP</code> также принимает заголовок <code>X-Forwarded-For</code>.</p><h2 id="splithttpobject" tabindex="-1"><a class="header-anchor" href="#splithttpobject"><span>SplitHttpObject</span></a></h2><p><code>SplitHttpObject</code> соответствует элементу <code>splithttpSettings</code> в конфигурации транспорта.</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;path&quot;</span><span class="token operator">:</span> <span class="token string">&quot;/&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;host&quot;</span><span class="token operator">:</span> <span class="token string">&quot;xray.com&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;headers&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;key&quot;</span><span class="token operator">:</span> <span class="token string">&quot;value&quot;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">&quot;scMaxEachPostBytes&quot;</span><span class="token operator">:</span> <span class="token number">1000000</span><span class="token punctuation">,</span>
  <span class="token property">&quot;scMaxConcurrentPosts&quot;</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span>
  <span class="token property">&quot;scMinPostsIntervalMs&quot;</span><span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
  <span class="token property">&quot;noSSEHeader&quot;</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token property">&quot;xPaddingBytes&quot;</span><span class="token operator">:</span> <span class="token string">&quot;100-1000&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;xmux&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;maxConcurrency&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token property">&quot;maxConnections&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token property">&quot;cMaxReuseTimes&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token property">&quot;cMaxLifetimeMs&quot;</span><span class="token operator">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>path</code>: string</p></blockquote><p>Путь HTTP-протокола, используемый SplitHTTP. Значение по умолчанию — <code>&quot;/&quot;</code>.</p><blockquote><p><code>host</code>: string</p></blockquote><p>Хост, отправляемый в HTTP-запросе SplitHTTP. Значение по умолчанию пустое. Если значение на сервере пустое, значение хоста, отправляемое клиентом, не проверяется.</p><p>Если значение указано на сервере или в <code>headers</code>, оно будет сравниваться со значением хоста в запросе клиента.</p><p>Приоритет выбора хоста для отправки клиентом: <code>host</code> &gt; <code>headers</code> &gt; <code>address</code>.</p><blockquote><p><code>headers</code>: map {string: string}</p></blockquote><p>Только для клиента. Пользовательские HTTP-заголовки. Пара «ключ-значение», где каждый ключ представляет собой имя HTTP-заголовка, а соответствующее значение — строка.</p><blockquote><p><code>scMaxEachPostBytes</code>: int | string</p></blockquote><p>Максимальный размер блока выгрузки в байтах. Значение по умолчанию — 1000000 (1 МБ).</p><p>Размер, установленный на клиенте, должен быть меньше этого значения, иначе запрос POST, размер которого превышает значение, установленное на сервере, будет отклонен.</p><p>Это значение должно быть меньше максимального размера тела запроса, разрешенного CDN или другим обратным прокси-сервером HTTP, иначе будет выдаваться ошибка HTTP 413.</p><p>Также может быть строкой в формате &quot;500000-1000000&quot;, и ядро будет случайным образом выбирать значение из этого диапазона для уменьшения цифрового следа.</p><blockquote><p><code>scMaxConcurrentPosts</code>: int | string</p></blockquote><p>Максимальное количество одновременных запросов POST на одно соединение. Значение по умолчанию — 100.</p><p>Параллельная выгрузка также (и в основном) контролируется параметром <code>scMinPostsIntervalMs</code>, поэтому это значение является лишь страховкой.</p><p>Фактическое количество запросов, отправляемых клиентом, должно быть меньше, чем на сервере. (На практике, поскольку указанного выше ограничения трудно достичь, клиент может фактически установить значение, превышающее значение на сервере, но это не рекомендуется).</p><p>Также может быть строкой в формате &quot;50-100&quot;, и ядро будет случайным образом выбирать значение из этого диапазона для уменьшения цифрового следа.</p><blockquote><p><code>scMinPostsIntervalMs</code>: int | string</p></blockquote><p>Только для клиента. Минимальный интервал между запросами POST на выгрузку. Значение по умолчанию — 30.</p><p>Также может быть строкой в формате &quot;10-50&quot;, и ядро будет случайным образом выбирать значение из этого диапазона для уменьшения цифрового следа.</p><blockquote><p><code>noSSEHeader</code>: bool</p></blockquote><p>Только для сервера. Не отправлять заголовок ответа <code>Content-Type: text/event-stream</code>. Значение по умолчанию — <code>false</code> (то есть заголовок будет отправлен).</p><blockquote><p><code>xPaddingBytes</code>: int | string</p></blockquote>`,32),m=n("code",null,'"100-1000"',-1),b=n("p",null,[s("Значение "),n("code",null,"-1"),s(" полностью отключает заполнение.")],-1),T=n("blockquote",null,[n("p",null,[n("code",null,"xmux"),s(": "),n("a",{href:"#xmuxobject"},"XmuxObject")])],-1),q=n("h2",{id:"xmuxobject",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#xmuxobject"},[n("span",null,"XmuxObject")])],-1),h=p(`<p>Только для клиента. Позволяет пользователю контролировать поведение многопоточности SplitHTTP в h2 и h3. Не используйте данную функцию вместе с mux.cool.</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;maxConcurrency&quot;</span><span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">,</span>
  <span class="token property">&quot;maxConnections&quot;</span><span class="token operator">:</span> <span class="token number">32</span><span class="token punctuation">,</span>
  <span class="token property">&quot;cMaxReuseTimes&quot;</span><span class="token operator">:</span> <span class="token number">64</span><span class="token punctuation">,</span>
  <span class="token property">&quot;cMaxLifetimeMs&quot;</span><span class="token operator">:</span> <span class="token number">128</span>
<span class="token punctuation">}</span>

При установке всех значений в <span class="token number">0</span> или их отсутствии<span class="token punctuation">,</span> ядро заполнит их значениями по умолчанию.

Объяснение терминов<span class="token operator">:</span>
- Потоки будут мультиплексироваться в физические соединения<span class="token punctuation">,</span> например<span class="token operator">:</span> Соединение <span class="token number">1</span> (Поток <span class="token number">1</span><span class="token punctuation">,</span> Поток <span class="token number">2</span><span class="token punctuation">,</span> Поток <span class="token number">3</span>) Соединение <span class="token number">2</span> (Поток <span class="token number">4</span><span class="token punctuation">,</span> Поток <span class="token number">5</span><span class="token punctuation">,</span> Поток <span class="token number">6</span>) ... и так далее. В других источниках вы можете встретить описание <span class="token string">&quot;соединение-подключение&quot;</span><span class="token punctuation">,</span> это то же самое.
- Все следующие поля имеют тип <span class="token punctuation">[</span>Int32Range<span class="token punctuation">]</span>(../../development/intro/guide.md#int32range)<span class="token operator">:</span>

&gt; \`maxConcurrency\`<span class="token operator">:</span> int/string

Значение по умолчанию — <span class="token number">0</span> (неограниченно). Максимальное количество потоков<span class="token punctuation">,</span> мультиплексируемых в одном соединении. Когда количество потоков в соединении достигает этого значения<span class="token punctuation">,</span> ядро создает дополнительные соединения для размещения новых потоков<span class="token punctuation">,</span> аналогично параметру \`concurrency\` в mux.cool.

&gt; \`maxConnections\`<span class="token operator">:</span> int/string

Значение по умолчанию — <span class="token number">0</span> (неограниченно). Максимальное количество открытых соединений. Ядро будет активно открывать новые соединения для каждого потока до тех пор<span class="token punctuation">,</span> пока не будет достигнуто это значение. Затем ядро начнет мультиплексировать потоки в уже установленные соединения. Конфликтует с \`maxConcurrency\`.

&gt; \`cMaxReuseTimes\`<span class="token operator">:</span> int/string

Значение по умолчанию — <span class="token number">0</span> (неограниченно). Максимальное количество раз<span class="token punctuation">,</span> которое соединение может быть использовано повторно. По достижении этого значения ядро больше не будет назначать потоки этому соединению<span class="token punctuation">,</span> и оно будет разорвано после закрытия последнего внутреннего потока.

&gt; \`cMaxLifetimeMs\`<span class="token operator">:</span> int/string

Значение по умолчанию — <span class="token number">0</span> (неограниченно). Максимальное время <span class="token string">&quot;жизни&quot;</span> соединения. По истечении этого времени ядро больше не будет назначать потоки этому соединению<span class="token punctuation">,</span> и оно будет разорвано после закрытия последнего внутреннего потока.

## Версия HTTP

### Поведение клиента

По умолчанию клиент будет использовать http/<span class="token number">1.1</span><span class="token punctuation">,</span> если TLS не включен<span class="token punctuation">,</span> и h2<span class="token punctuation">,</span> если TLS включен.

Если TLS включен<span class="token punctuation">,</span> можно указать конкретную версию HTTP (http/<span class="token number">1.1</span><span class="token punctuation">,</span> h2<span class="token punctuation">,</span> h3) в массиве \`alpn\` в настройках TLS (работает только в том случае<span class="token punctuation">,</span> если массив содержит только один элемент<span class="token punctuation">,</span> если указано несколько элементов<span class="token punctuation">,</span> будет использоваться поведение по умолчанию).

### Поведение сервера

По умолчанию сервер будет прослушивать TCP-порт и обрабатывать трафик http/<span class="token number">1.1</span> и h2.

Если TLS включен<span class="token punctuation">,</span> можно указать \`h3\` в массиве \`alpn\` в настройках TLS. В этом случае сервер будет прослушивать UDP-порт и обрабатывать трафик h3.

### Советы

Поскольку этот протокол основан на стандартных HTTP-запросах<span class="token punctuation">,</span> он нечувствителен к преобразованию версий HTTP<span class="token punctuation">,</span> и различные промежуточные узлы могут преобразовывать версии HTTP.

Например<span class="token punctuation">,</span> если вы хотите использовать h3 для подключения к Cloudflare<span class="token punctuation">,</span> но Cloudflare не будет использовать h3 для обратного подключения<span class="token punctuation">,</span> а будет использовать http/<span class="token number">1.1</span> или h2<span class="token punctuation">,</span> то на клиенте \`alpn\` должен быть установлен в \`h3\`<span class="token punctuation">,</span> а на сервере — нет<span class="token punctuation">,</span> поскольку запросы<span class="token punctuation">,</span> отправляемые на сервер<span class="token punctuation">,</span> не будут использовать h3.

## Browser Dialer

При использовании HTTPS этот транспорт также поддерживает <span class="token punctuation">[</span>Browser Dialer<span class="token punctuation">]</span>(../features/browser_dialer.md).

## Подробности протокола

Подробное обсуждение см. в <span class="token punctuation">[</span>#<span class="token number">3412</span><span class="token punctuation">]</span>(https<span class="token operator">:</span><span class="token comment">//github.com/XTLS/Xray-core/pull/3412) и [#3462](https://github.com/XTLS/Xray-core/pull/3462). Ниже приведено краткое описание и требования к совместимости реализации:</span>

<span class="token number">1</span>. Загрузка начинается с запроса \`GET /&lt;UUID&gt;\`. Сервер немедленно отвечает \`<span class="token number">200</span> OK\` и \`Transfer Encoding<span class="token operator">:</span>chunked\` и сразу же отправляет двухбайтовую полезную нагрузку<span class="token punctuation">,</span> чтобы заставить HTTP-промежуточные узлы сбросить заголовки.

На данный момент сервер отправляет следующие заголовки<span class="token operator">:</span>

* \`X-Accel-Buffering<span class="token operator">:</span> no\` — отключает буферизацию.
* \`Content-Type<span class="token operator">:</span> text/event-stream\` — отключает буферизацию на некоторых промежуточных узлах<span class="token punctuation">,</span> можно отключить с помощью опции \`<span class="token string">&quot;noSSEHeader&quot;</span>\`.
* \`Transfer-Encoding<span class="token operator">:</span> chunked\` — кодировка передачи данных<span class="token punctuation">,</span> используется только в HTTP/<span class="token number">1.1</span>.
* \`Cache-Control<span class="token operator">:</span> no-store\` — отключает любое возможное кэширование ответов.

<span class="token number">2</span>. Выгрузка начинается с запроса \`POST /&lt;UUID&gt;/&lt;seq&gt;\`. \`seq\` работает аналогично порядковому номеру TCP<span class="token punctuation">,</span> начиная с <span class="token number">0</span>. Пакеты данных могут отправляться одновременно<span class="token punctuation">,</span> сервер должен пересобрать данные в соответствии с порядковым номером. Порядковый номер не должен сбрасываться.

   Клиент может открывать запросы на выгрузку и загрузку в любом порядке<span class="token punctuation">,</span> любой из них может инициировать сеанс<span class="token punctuation">,</span> но соединение \`GET\` должно быть открыто в течение <span class="token number">30</span> секунд<span class="token punctuation">,</span> иначе сеанс будет разорван.

<span class="token number">3</span>. Запрос \`GET\` будет оставаться открытым до тех пор<span class="token punctuation">,</span> пока соединение не будет разорвано. Как сервер<span class="token punctuation">,</span> так и клиент могут закрыть соединение. Конкретное поведение зависит от версии HTTP.

Рекомендации<span class="token operator">:</span>

* Не ожидайте<span class="token punctuation">,</span> что CDN будет правильно передавать все заголовки. Цель этого протокола — обойти CDN<span class="token punctuation">,</span> которые не поддерживают WS<span class="token punctuation">,</span> а такие CDN обычно ведут себя не очень хорошо.

* Следует предполагать<span class="token punctuation">,</span> что все HTTP-соединения не поддерживают потоковые запросы<span class="token punctuation">,</span> поэтому размер каждого пакета<span class="token punctuation">,</span> отправляемого по исходящему соединению<span class="token punctuation">,</span> должен основываться на задержке<span class="token punctuation">,</span> пропускной способности и ограничениях самого промежуточного узла (аналогично MTU и алгоритму Нейгла в TCP).</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2);function g(x,P){const o=e("I18nTip"),t=e("Badge"),c=e("RouterLink");return l(),u("div",null,[a(o),v,a(t,{text:"v1.8.16+",type:"warning"}),k,n("p",null,[s("Задает размер заполнения для запросов (исходящих) и ответов (входящих), используемый для уменьшения отпечатка запроса. Единица измерения: байты. Значение по умолчанию: "),m,s(". При каждом запросе случайным образом выбирается число из этого диапазона. Тип: "),a(c,{to:"/ru/development/intro/guide.html#int32range"},{default:r(()=>[s("Int32Range")]),_:1})]),b,T,q,a(t,{text:"v24.9.19+",type:"warning"}),h])}const _=i(d,[["render",g],["__file","splithttp.html.vue"]]);export{_ as default};
