import{_ as i,r as o,o as u,c as d,a as e,b as n,d as s,w as p,e as t}from"./app-BNfGivRm.js";const h={},k=n("h1",{id:"splithttp-h2、quic-h3",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#splithttp-h2、quic-h3"},[n("span",null,"SplitHTTP（H2、QUIC H3）")])],-1),b=t(`<p>使用HTTP分块传输编码流式响应处理下载，使用多个HTTP POST请求进行上传。</p><p>可以通过不支持WebSocket的CDN上，但仍有一些要求：</p><ul><li>CDN必须支持HTTP分块传输，且支持流式响应而不会缓冲，核心将会发送各种信息以告知CDN，但是需要CDN遵守。如果中间盒不支持流式响应而导致连接被挂起，则该传输很可能无法工作。</li></ul><p>目的与V2fly Meek相同，由于使用了流式响应处理下载，下行速率更为优秀，上行也经过优化但仍非常有限，也因此对 HTTP 中间盒要求更高（见上）。</p><p><code>SplitHTTP</code> 也接受 <code>X-Forwarded-For</code> header。</p><h2 id="splithttpobject" tabindex="-1"><a class="header-anchor" href="#splithttpobject"><span>SplitHttpObject</span></a></h2><p>The <code>SplitHttpObject</code> 对应传输配置的 <code>splithttpSettings</code> 项。</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;path&quot;</span><span class="token operator">:</span> <span class="token string">&quot;/&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;host&quot;</span><span class="token operator">:</span> <span class="token string">&quot;xray.com&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;headers&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;key&quot;</span><span class="token operator">:</span> <span class="token string">&quot;value&quot;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">&quot;scMaxEachPostBytes&quot;</span><span class="token operator">:</span> <span class="token number">1000000</span><span class="token punctuation">,</span>
  <span class="token property">&quot;scMaxConcurrentPosts&quot;</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span>
  <span class="token property">&quot;scMinPostsIntervalMs&quot;</span><span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
  <span class="token property">&quot;noSSEHeader&quot;</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token property">&quot;xPaddingBytes&quot;</span><span class="token operator">:</span> <span class="token string">&quot;100-1000&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;xmux&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;maxConcurrency&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token property">&quot;maxConnections&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token property">&quot;cMaxReuseTimes&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token property">&quot;cMaxLifetimeMs&quot;</span><span class="token operator">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>path</code>: string</p></blockquote><p>SplitHTTP 所使用的 HTTP 协议路径，默认值为 <code>&quot;/&quot;</code>。</p><blockquote><p><code>host</code>: string</p></blockquote><p>SplitHTTP 的HTTP请求中所发送的host，默认值为空。若服务端值为空时，不验证客户端发送来的host值。</p><p>当在服务端指定该值，或在 <code>headers</code> 中指定host，将会校验与客户端请求host是否一致。</p><p>客户端选择发送的host优先级 <code>host</code> &gt; <code>headers</code> &gt; <code>address</code></p><blockquote><p><code>headers</code>: map {string: string}</p></blockquote><p>仅客户端，自定义 HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是字符串。</p><blockquote><p><code>scMaxEachPostBytes</code>: int | string</p></blockquote><p>上传分块的最大大小，单位为字节，默认值为 1000000, 即 1MB.</p><p>客户端设置的大小必须低于该值，否则当发送的 POST 请求大于服务端设置的值时，请求会被拒绝。</p><p>这个值应该小于CDN或其他HTTP反向代理所允许的最大请求体，否则将抛出 HTTP 413 错误。</p><p>也可以是字符串 &quot;500000-1000000&quot; 的形式，核心每次会在范围内随机选择一个值，以减少指纹。</p><blockquote><p><code>scMaxConcurrentPosts</code>: int | string</p></blockquote><p>单个连接上传post的最大并发数，默认为100.</p><p>上传并发同时也受(也主要受) <code>scMinPostsIntervalMs</code> 控制，故该值仅做保险。</p><p>客户端实际发起的数量必须低于服务端。(实际情况下由于上述很难达到上限，所以事实上客户端设置的值可以超过服务端，但不建议这么做)</p><p>也可以是字符串 &quot;50-100&quot; 的形式，核心每次会在范围内随机选择一个值，以减少指纹。</p><blockquote><p><code>scMinPostsIntervalMs</code>: int | string</p></blockquote><p>仅客户端，发起POST上传请求的最小间隔。默认值为 30.</p><p>也可以是字符串 &quot;10-50&quot; 的形式，核心每次会在范围内随机选择一个值，以减少指纹。</p><blockquote><p><code>noSSEHeader</code>: bool</p></blockquote><p>仅服务端，不发送 <code>Content-Type: text/event-stream</code> 响应头，默认 <code>false</code> (即会发送)</p><blockquote><p><code>xPaddingBytes</code> int | string</p></blockquote>`,32),m=n("code",null,'"100-1000"',-1),q=n("p",null,[s("设置为 "),n("code",null,"-1"),s(" 将完全禁用填充")],-1),T=n("blockquote",null,[n("p",null,[n("code",null,"xmux"),s(": "),n("a",{href:"#xmuxobject"},"XmuxObject")])],-1),v=n("h2",{id:"xmuxobject",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#xmuxobject"},[n("span",null,"XmuxObject")])],-1),x=t(`<p>允许用户对 SplitHTTP 在 h2 与 h3 中的多路复用行为进行控制，如不设置，默认行为为将所有请求复用至一条 TCP/QUIC 连接。</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;maxConcurrency&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token property">&quot;maxConnections&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token property">&quot;cMaxReuseTimes&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token property">&quot;cMaxLifetimeMs&quot;</span><span class="token operator">:</span> <span class="token number">0</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于默认是无限复用，xmux 实际上是对此进行限制。此外不要启用 mux.cool.</p><p>术语解释：</p>`,4),_=n("li",null,"流会复用物理连接，像这样 连接1(流1,流2,流3) 连接2(流4,流5,流6) .. 以此类推 在其他地方你可能看到 连接-子连接 这样的描述，都是一样的东西。",-1),g=t('<blockquote><p><code>maxConcurrency</code>: int/string</p></blockquote><p>默认值为 0(即无限) 每个连接中复用的流的最大数量，连接中流的数量达到该值后核心会新建更多连接以容纳更多的流，类似于 mux.cool 的 concurrency.</p><blockquote><p><code>maxConnections</code>: int/string</p></blockquote><p>默认值为 0(即无限) 要打开的最大连接数，连接达到此值前核心会积极打开连接，对每一条流都新建一个连接，直到达到该值。然后核心会开始复用已经建立的连接。 与 <code>maxConcurrency</code> 冲突。</p><blockquote><p><code>cMaxReuseTimes</code>: int/string</p></blockquote><p>默认值为 0(即无限) 一个连接最多被复用几次，当达到该值后核心不会向该连接再分配流，其将在内部最后一条流关闭后断开。</p><blockquote><p><code>cMaxLifetimeMs</code>: int/string</p></blockquote><p>默认值为 0(即无限) 一个连接最多可以“存活”多久，当连接打开的时间超过该值后核心不会向该连接再分配流，其将在内部最后一条流关闭后断开。</p><h2 id="http-版本" tabindex="-1"><a class="header-anchor" href="#http-版本"><span>HTTP 版本</span></a></h2><h3 id="客户端行为" tabindex="-1"><a class="header-anchor" href="#客户端行为"><span>客户端行为</span></a></h3><p>默认情况下，客户端将会默认在未启用 TLS 时使用 http/1.1, 启用 TLS 时，使用 h2.</p><p>当启用 TLS 时，允许在 TLS 设置的 alpn 数组内设置 http/1.1 h2 h3 来指定具体的http版本(仅当该数组只有一个元素时生效，若填入多个元素则返回默认行为)</p><h3 id="服务端行为" tabindex="-1"><a class="header-anchor" href="#服务端行为"><span>服务端行为</span></a></h3><p>默认情况下，服务端将会默认监听 TCP, 此时可以处理 http/1.1 和 h2 流量。</p><p>当启用 TLS 时，允许在 TLS 设置的 alpn 数组内设置 h3, 此时服务端将改为监听 UDP 端口, 处理 h3 流量。</p><h3 id="小提示" tabindex="-1"><a class="header-anchor" href="#小提示"><span>小提示</span></a></h3><p>由于该协议为标准的 HTTP 请求，所以对于 HTTP 版本的转换并不敏感，各种中间盒都可能转换 HTTP 版本。</p><p>列如：你希望使用 h3 连接 Cloudflare, 但是Cloudflare 不会使用 h3 回源, 而是使用 http/1.1 或 h2 回源，此时客户端 alpn 应为 h3, 而服务端就不应为 h3, 因为发往服务端的请求不是 h3.</p><h2 id="browser-dialer" tabindex="-1"><a class="header-anchor" href="#browser-dialer"><span>Browser Dialer</span></a></h2>',19),P=n("h2",{id:"协议细节",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#协议细节"},[n("span",null,"协议细节")])],-1),f={href:"https://github.com/XTLS/Xray-core/pull/3412",target:"_blank",rel:"noopener noreferrer"},y={href:"https://github.com/XTLS/Xray-core/pull/3462",target:"_blank",rel:"noopener noreferrer"},C=t('<ol><li>使用 <code>GET /&lt;UUID&gt;</code> 开始下载。服务器立即回复 <code>200 OK</code> 和 <code>Transfer Encoding:chunked</code> , 并立即发送一个两字节的有效负载，以强制HTTP中间盒刷新标头。</li></ol><p>现阶段服务器会发送以下标头</p><ul><li><code>X-Accel-Buffering: no</code> 禁用缓冲</li><li><code>Content-Type: text/event-stream</code> 在部分中间盒中禁用缓冲，可以使用 <code>&quot;noSSEHeader&quot;</code> 选项关闭</li><li><code>Transfer-Encoding: chunked</code> 分块传输，仅在 HTTP/1.1 中使用</li><li><code>Cache-Control: no-store</code> to disable any potential response caching. 禁用CDN的缓存</li></ul><ol start="2"><li><p>使用 <code>POST /&lt;UUID&gt;/&lt;seq&gt;</code> 开始发送上行数据. <code>seq</code> 作用类似于 TCP 序列号，从0开始，数据包可以被同时发送，服务端必须按序列号将数据重组。序列号不应重置。</p><p>客户端可以以任意决定打开上行与下行请求的顺序，任何一种都可以启动会话，但是必须要在30秒内打开 <code>GET</code> 连接，否则会话将被终止。</p></li><li><p><code>GET</code> 请求将一直保持在打开状态直到连接被终止，服务端和客户端都可以关闭连接。具体行为取决于HTTP版本。</p></li></ol><p>建议:</p><ul><li><p>不要期望CDN会正确传输所有标头，这个协议的目的是为了穿透不支持WS的CDN，而这些CDN的行为通常不怎么友好。</p></li><li><p>应当假设所有HTTP连接都不支持流式请求，所以上行连接发送的的每个包的大小应该基于延迟、吞吐量以及中间盒本身的限制考虑(类似TCP的MTU与纳格算法)。</p></li></ul>',6);function H(S,M){const r=o("I18nTip"),c=o("Badge"),a=o("RouterLink"),l=o("ExternalLinkIcon");return u(),d("div",null,[e(r),k,e(c,{text:"v1.8.16+",type:"warning"}),b,n("p",null,[s("设置请求（出站）和响应（入站）的填充大小，用于减少请求指纹。单位byte, 默认为 "),m,s(" 每次会在该范围中随机选择一个数字。为 "),e(a,{to:"/development/intro/guide.html#int32range"},{default:p(()=>[s("Int32Range")]),_:1}),s(" 类型")]),q,T,v,e(c,{text:"v24.9.19+",type:"warning"}),x,n("ul",null,[_,n("li",null,[s("下述所有字段类型均为 为 "),e(a,{to:"/development/intro/guide.html#int32range"},{default:p(()=>[s("Int32Range")]),_:1}),s(" 类型")])]),g,n("p",null,[s("如果使用HTTPS，该传输还支持 "),e(a,{to:"/config/features/browser_dialer.html"},{default:p(()=>[s("Browser Dialer")]),_:1})]),P,n("p",null,[s("讨论详见 "),n("a",f,[s("#3412"),e(l)]),s(" 和 "),n("a",y,[s("#3462"),e(l)]),s(" 以下是简述和简要兼容实现要求")]),C])}const L=i(h,[["render",H],["__file","splithttp.html.vue"]]);export{L as default};
