<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Project X</title><link>https://xtls.github.io/en/</link><description>Recent content on Project X</description><generator>Hugo -- gohugo.io</generator><language>cn</language><lastBuildDate>Fri, 15 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://xtls.github.io/en/index.xml" rel="self" type="application/rss+xml"/><item><title>【第1章】前言啰嗦篇</title><link>https://xtls.github.io/en/documents/level-0/ch01-preface/</link><pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/documents/level-0/ch01-preface/</guid><description>1.1 这篇文档是写给谁的？ 一句话：写给 ①零基础 ②希望学习自建VPS 的新人。
1.2 这篇文档不是写给谁的？ 包括但不限于：各路大神大能、懒得自己折腾的小白、已经会折腾的高手、确定要用机场的土豪、确定要用一键脚本的逍遥派&amp;hellip;&amp;hellip; 总之只要有技术基础、或不愿不想自建的同学，您直接关闭本文即可，因为这篇文章大概是入不了您的法眼的，更可能会让您生一肚子闲气，那多划不来。
1.3 郑重声明及其他声明 郑重声明：
鄙人技术奇菜无比，故本文必然挂一漏万破绽百出。您若发现问题还请温柔提醒，莫要人参公鸡。
免责声明：
本文内容请您自行判断是否可信可靠可用，若您根据本文内容建立和使用VPS服务器时出了任何问题和不良结果，鄙人概不负责。
啰嗦声明：
基于本文【零基础用户】的目标受众，许多内容会尽力详尽说明，所以语言偏啰嗦，请做好心理准备。
1.4 为什么自建是个难题？ 要回答这个问题，就需要稍微多说一点背景信息了。
一、科学上网这件事
科学上网这件事情，说来已经发展了近二十年（震惊!!!.jpg）。最初，自己稍微动动手即可（改改host、连一下ssh）、后来需要找一个网页代理，再后来需要写一个私有协议(比如Shadowsocks)等等。
随着GFW技术这十几年来不断的迭代升级，若要完成【自己动手科学上网】这个目标，需要做的事情已经包括但不限于：
1. 了解Linux系统基本命令 2. 了解网络传输协议 3. 有技术和经济能力完成VPS购买及管理 4. 有技术和经济能力完成域名购买及管理 5. 有技术能力完成TLS证书申请 等等。 这就让【自建VPS科学上网】这个曾经简单的行为逐渐变成了令新人望而生畏的挑战。
二、零基础用户的无奈
零基础的非技术用户，如果完成上面这一连串的操作，势必要学习大量的知识，但稍微搜索之后，新人只怕会更加迷茫：大量的信息散布在互联网的各个角落：博客、问答网站、群组、论坛、GitHub、Telegram、YouTube 等等等等）。这些信息纷乱复杂、水平良莠不齐、甚至可能互相矛盾。基本上就是不把新人彻底弄晕誓不罢休。
面对这些杂乱无章的信息，新人突然就从【信息匮乏】变成了【信息过剩】。若是几番连蒙带猜的折腾以失败告终（大概率如此）的话，他的积极性势必大受挫折。在这个过程中，若他又恰好去了一些不太友好的地方去求助，恐怕还要雪上加霜的被嘲讽一番：“这么菜，用机场不就行了，瞎折腾什么啊！”、“先去学会Linux再回来问吧”。
这时候，大概也只有一声“呵呵”可以表达心情了。
1.5 “用机场不就行了？” 首先，我想反问一下那些冷嘲热讽的人：“用机场”真的就是万灵药吗？
其次，我认为“不懂”和“不想懂”是有本质区别的。态度恶劣的巨婴伸手党自然惹人厌烦，但真心自学却不得要领的人不该受到无端的白眼和歧视，也正是这种对新人不加区分的恶劣社区氛围促使我写下本文。那么闲话少说，我们来看看机场的优势与劣势究竟如何：
一、“机场“的优势
所谓“机场”，就是“线路提供商”。他负责完成1.4提到的那一串技术操作和管理，用户则付费获得使用权。所以，它的优点至少有：
用户操作简单：扫码操作、一键添加规则等 线路选择多：可解锁不同国家、地区的网络服务；比如iplc等专线服务、游戏加速服务等 接入节点多：所以抵抗节点封锁的能力强一些，封了一个就换下一个 二、“机场”的风险
“方便”这枚硬币的另一面就是“风险”，基于“机场”的技术特点和市场情况，它的风险至少有：
“机场”可完全获得用户信息：用户在网上的所有痕迹，都【必然】经过且【非常可能】长期存储在其服务器上，这些记录无法受到任何具备法律效力的用户隐私协议的约束（窥视、记录你的一举一动） “机场”缺乏市场管理：不可避免存在着以欺诈为目标的恶意商家（主动跑路） “机场”面临监管压力：大机场相对有保障的同时，也无法避免树大招风。2020年间，已经有几个大机场停运、跑路的事件发生，用户的正常使用受到严重干扰（被动跑路） “机场”技术水平难以确定：线路质量良莠不齐，挂羊头卖狗肉的现象屡见不鲜（速度慢、掉线多、连不上） 1.</description></item><item><title>Blackhole</title><link>https://xtls.github.io/en/config/outbound-protocols/blackhole/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/outbound-protocols/blackhole/</guid><description>Blackhole（黑洞）是一个出站数据协议，它会阻碍所有数据的出站，配合 路由配置 一起使用，可以达到禁止访问某些网站的效果。
OutboundConfigurationObject { &amp;#34;response&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;none&amp;#34; } } response: ResponseObject
配置黑洞的响应数据。
Blackhole 会在收到待转发数据之后，发送指定的响应数据，然后关闭连接，待转发的数据将被丢弃。 如不指定此项，Blackhole 将直接关闭连接。
ResponseObject { &amp;#34;type&amp;#34;: &amp;#34;none&amp;#34; } type: &amp;ldquo;http&amp;rdquo; | &amp;ldquo;none&amp;rdquo;
当 type 为 &amp;quot;none&amp;quot;（默认值）时，Blackhole 将直接关闭连接。
当 type 为 &amp;quot;http&amp;quot; 时，Blackhole 会发回一个简单的 HTTP 403 数据包，然后关闭连接。</description></item><item><title>TCP</title><link>https://xtls.github.io/en/config/transports/tcp/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/transports/tcp/</guid><description>TCP 传输模式是目前推荐使用的传输模式之一.
可以和各种协议有多种组合模式.
TcpObject TcpObject 对应传输配置的 tcpSettings 项。
{ &amp;#34;acceptProxyProtocol&amp;#34;: false, &amp;#34;header&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;none&amp;#34; } } acceptProxyProtocol: true | false
仅用于 inbound，指示是否接收 PROXY protocol。
PROXY protocol 专用于传递请求的真实来源 IP 和端口，若你不了解它，请先忽略该项。
常见的反代软件（如 HAProxy、Nginx）都可以配置发送它，VLESS fallbacks xver 也可以发送它。
填写 true 时，最底层 TCP 连接建立后，请求方必须先发送 PROXY protocol v1 或 v2，否则连接会被关闭。
默认值为 false。
header: NoneHeaderObject | HttpHeaderobject
数据包头部伪装设置，默认值为 NoneHeaderObject。
TIP
HTTP 伪装无法被其它 HTTP 服务器（如 Nginx）分流，但可以被 VLESS fallbacks path 分流。
NoneHeaderObject 不进行伪装</description></item><item><title>VLESS 协议</title><link>https://xtls.github.io/en/develop/protocols/vless/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/develop/protocols/vless/</guid><description>VLESS 是一个无状态的轻量传输协议，可以作为 Xray 客户端和服务器之间的桥梁。
In progress</description></item><item><title>下载和安装中的问题</title><link>https://xtls.github.io/en/faq/start/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/faq/start/</guid><description> Q: 我想自己下载安装包, 可是release好多文件, 我要下载哪一个呢?请先使用谷歌搜索您的设备型号, 确认您设备使用的架构, 然后下载对应的版本. Q: 我在VPS上运行了脚本, 好像安装好了, 可是似乎没反应?/系统服务不能启动?/我也不知道有没有安装成功?使用命令 &amp;lsquo;journalctl -u xray&amp;rsquo; 查看 xray 的相关日志。
或者
终端命令行中执行 &amp;lsquo;xray run -c 您的config.json文件路径&amp;rsquo; 来查看相关信息
Q: 配置文件在哪个目录。谢谢!这位同学你可真的是不看文档, 不过因为你很有礼貌, 我可以告诉你在这里有所有文件的安装位置</description></item><item><title>编译</title><link>https://xtls.github.io/en/develop/intro/compile/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/develop/intro/compile/</guid><description>前序工作 Xray 使用 Golang 作为主要编程语言。
下载 Golang: Downloads 安装 Golang: install important请使用 Golang 1.15 以上版本。
编译 拉取 Xray 源代码和依赖 在安装了git的环境下, 只需要执行以下命令即可clone一份完整的Xray-core代码:
git clone https://github.com/XTLS/Xray-core.git
注意事项 在无法正常访问 Google 的网络环境，依赖可能无法被正常拉取，可以通过各种手段代理解决.
比如可以通过设置 GOPROXY：
go env -w GOPROXY=https://goproxy.io,direct
手工编译 important本小节的命令需要在 Xray 项目根目录内运行。
在 Linux 环境下, 只需执行以下命令, 即可在当前目录下生成刚构建的 xray 可执行文件。
CGO_ENABLED=0 go build -o xray -trimpath -ldflags &amp;#34;-s -w -buildid=&amp;#34; ./main 如果需要编译可以进行debug的程序,即可以用dlv附加到运行的程序进行调试, 请去掉 ldflags 中的 &amp;lsquo;-w -s&amp;rsquo; 选项.</description></item><item><title>透明代理入门</title><link>https://xtls.github.io/en/documents/level-2/transparent_proxy/transparent_proxy/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/documents/level-2/transparent_proxy/transparent_proxy/</guid><description>什么是透明代理 透明代理简单地说就是不让被代理的设备感觉到自己被代理了。简单地说就是，被代理的设备上不需要运行任何代理软件(比如Xray、V2RayNG等)，当你连接上网络时，你的设备已经被代理了。
这也意味着，代理的软件运行在别的地方，比如运行在路由器中，通过路由器上网的设备就自动被代理了。
透明代理的实现 透明代理的实现目前主要有两种方式：
tun2socks 可用Windows/Linux(包括安卓)实现。因为实现过程比较简单，很少有教程，我这里简单描述一下。
Windows
安装 Netch ，使用模式[3] [TUN/TAP] 绕过局域网启动。
开启热点
打开控制面板-&amp;gt;网络和 Internet-&amp;gt;网络和共享中心-&amp;gt;更改适配器设置，找到TAP-Windows Adapter和Microsoft Wi-Fi Direct Virtual Adapter。
鼠标右键点击TAP-Windows Adapter，属性-&amp;gt;共享，勾选允许其他网络用户通过此计算机的 Internet 连接来连接，在家庭网络连接中选择Microsoft Wi-Fi Direct Virtual Adapter的那个网络连接，点击确定。
Android
配置连接V2RayNG
开启热点
热点设置 -&amp;gt; 允许热点使用VPN(部分安卓系统可能没有这个选项)
iptables/nftables iptables与nftables实现透明代理的原理相同，下文统一使用iptables。
基于iptables的透明代理实现只能用于Linux系统(包括openwrt/安卓)。由于其比tun2socks更高效率以及适合在路由器中配置而广泛使用。
现存的三篇白话文透明代理教程其实讲的都是这种基于这种方案的透明代理实现，它们是： 新 V2Ray 白话文指南-透明代理 、 新 V2Ray 白话文指南-透明代理(TPROXY) 、 透明代理（TProxy）配置教程 。其中第一篇是基于iptables-redirect模式，已经过时了，不建议使用，仅供参考。第二篇和第三篇讲的都是基于iptables-tproxy模式的透明代理实现。
iptables实现透明代理原理 Linux使用Netfilter来管理网络，Netfilter模型如下：
假设使用路由器作为网关(即我们平时的上网方式)，那么：</description></item><item><title>Download and install</title><link>https://xtls.github.io/en/guide/install/</link><pubDate>Fri, 17 Jan 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/guide/install/</guid><description>Platform support Xray is available in the following platforms.
Windows 7 and later (x86 / amd64 / arm32). macOS 10.10 Yosemite and later (amd64). Linux 2.6.23 and later (x86 / amd64 / arm / arm64 / mips64 / mips / ppc64 / s390x / riscv64). Including but not limited to Debian 7 / 8, Ubuntu 12.04 / 14.04 and later, CentOS 7 / 8, Arch Linux, etc. FreeBSD (x86 / amd64).</description></item><item><title>【第2章】原料准备篇</title><link>https://xtls.github.io/en/documents/level-0/ch02-preparation/</link><pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/documents/level-0/ch02-preparation/</guid><description>这一章比较特殊，因为涉及到金钱交易行为，本文基于项目的中立立场，不做具体的推荐。我能做的，是告诉你需要准备哪些东西。
2.1 获取一台VPS 你需要获取一台健康的、IP没有被墙的VPS，并在管理后台做下面这些基础准备：
在VPS的后台安装 Debian 10 64bit 系统 小本本记下VPS的IP地址（本文会用 &amp;quot;100.200.300.400&amp;quot; 来表示） 注意： 这是一个故意写错的非法IP，请替换成你的真实IP）
小本本记下VPS的SSH远程登陆端口(Port) 小本本记下SSH远程登录的用户名和密码 购买VPS是一个比较复杂的事情，建议先去学习一下相关知识，选择适合自己的经济能力和线路需求的即可。另外可以选择薅一些国际大厂的羊毛（比如甲骨文和谷歌提供的永久免费或限时免费的套餐）。总之，务必量力而行。
说明： 关于选择 Debian 10 作为操作系统，这里稍微多说一句：不管你在网上听说了什么，不管哪个大神告诉你XXX版的Linux更好、XXX版的Linux更牛，这些Linux的派系之争跟现在的你半毛钱关系也没有！使用 Debian 10 足以让你的VPS服务器在安全、稳健运行的同时得到足够的优化（如cloud专用内核、及时的bbr支持等）。等你对Linux熟悉之后，再回头去尝试其他的Linux发行版也不迟
2.2 获取一个心仪的域名 你需要获取一个域名、并在DNS设置中添加一条A记录，指向你VPS的IP地址
请选择靠谱的国际域名服务商。选择一些常见的域名后缀就行，注意不要用 .cn 后缀。
在DNS设置中，添加一条指向你VPS的IP地址的A记录（A记录的名字可以随便起，本文会用 &amp;quot;a-name&amp;quot; 来表示。完整的域名则会用 &amp;quot;二级域名.你的域名.com&amp;quot; 或者 &amp;quot;a-name.yourdomain.com&amp;quot; 来表示）。效果如下图：
注意： 这不是一个真实可用的网址，请替换成你的真实网址
2.3 你本地电脑上需要安装的软件 SSH远程登录工具
Windows: PuTTY macOS/Linux: Terminal 远程文件拷贝工具</description></item><item><title>DNS</title><link>https://xtls.github.io/en/config/outbound-protocols/dns/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/outbound-protocols/dns/</guid><description>DNS 是一个出站协议，主要用于拦截和转发 DNS 查询。
此出站协议只能接收 DNS 流量（包含基于 UDP 和 TCP 协议的查询），其它类型的流量会导致错误。
在处理 DNS 查询时，此出站协议会将 IP 查询（即 A 和 AAAA）转发给内置的 DNS 服务器。其它类型的查询流量将被转发至它们原本的目标地址。
OutboundConfigurationObject { &amp;#34;network&amp;#34;: &amp;#34;tcp&amp;#34;, &amp;#34;address&amp;#34;: &amp;#34;1.1.1.1&amp;#34;, &amp;#34;port&amp;#34;: 53 } network: &amp;ldquo;tcp&amp;rdquo; | &amp;ldquo;udp&amp;rdquo;
修改 DNS 流量的传输层协议，可选的值有 &amp;quot;tcp&amp;quot; 和 &amp;quot;udp&amp;quot;。当不指定时，保持来源的传输方式不变。
address: address
修改 DNS 服务器地址。当不指定时，保持来源中指定的地址不变。
port: number
修改 DNS 服务器端口。当不指定时，保持来源中指定的端口不变。
DNS配置实例 In progress</description></item><item><title>Dokodemo door</title><link>https://xtls.github.io/en/config/inbound-protocols/dokodemo/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/inbound-protocols/dokodemo/</guid><description>Dokodemo door（任意门）可以监听一个本地端口，并把所有进入此端口的数据发送至指定服务器的一个端口，从而达到端口映射的效果。
InboundConfigurationObject { &amp;#34;address&amp;#34;: &amp;#34;8.8.8.8&amp;#34;, &amp;#34;port&amp;#34;: 53, &amp;#34;network&amp;#34;: &amp;#34;tcp&amp;#34;, &amp;#34;timeout&amp;#34;: 0, &amp;#34;followRedirect&amp;#34;: false, &amp;#34;userLevel&amp;#34;: 0 } address: address
将流量转发到此地址。可以是一个 IP 地址，形如 &amp;quot;1.2.3.4&amp;quot;，或者一个域名，形如 &amp;quot;xray.com&amp;quot;。字符串类型。
当 followRedirect（见下文）为 true 时，address 可为空。
port: number
将流量转发到目标地址的指定端口，范围 [1, 65535]，数值类型。必填参数。
network: &amp;ldquo;tcp&amp;rdquo; | &amp;ldquo;udp&amp;rdquo; | &amp;ldquo;tcp,udp&amp;rdquo;
可接收的网络协议类型。比如当指定为 &amp;quot;tcp&amp;quot; 时，仅会接收 TCP 流量。默认值为 &amp;quot;tcp&amp;quot;。
timeout: number
连接空闲的时间限制。单位为秒。默认值为 300。处理一个连接时，如果在 timeout 时间内，没有任何数据被传输，则中断该连接。
followRedirect: true | false
当值为 true 时，dokodemo-door 会识别出由 iptables 转发而来的数据，并转发到相应的目标地址。
可参考 传输配置 中的 tproxy 设置。</description></item><item><title>VMess 协议</title><link>https://xtls.github.io/en/develop/protocols/vmess/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/develop/protocols/vmess/</guid><description>VMess 是一个加密传输协议，可以作为 Xray 客户端和服务器之间的桥梁。
版本 当前版本号为 1。
依赖 底层协议 VMess 是一个基于 TCP 的协议，所有数据使用 TCP 传输。
用户 ID ID 等价于 UUID，是一个 16 字节长的随机数，它的作用相当于一个令牌（Token）。 一个 ID 形如：de305d54-75b4-431b-adb2-eb6b9e546014，几乎完全随机，可以使用任何的 UUID 生成器来生成，比如这个。
用户 ID 可在配置文件中指定。
函数 MD5: MD5 函数 输入参数为任意长度的 byte 数组 输出为一个 16 byte 的数组 HMAC: HMAC 函数 输入参数为： H：散列函数 K：密钥，任意长度的 byte 数组 M：消息，任意长度的 byte 数组 Shake: SHA3-Shake128 函数 输入参数为任意长度的字符串 输出为任意长度的字符串</description></item><item><title>WebSocket</title><link>https://xtls.github.io/en/config/transports/websocket/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/transports/websocket/</guid><description>使用标准的 WebSocket 来传输数据。
WebSocket 连接可以被其它 HTTP 服务器（如 Nginx）分流，也可以被 VLESS fallbacks path 分流。
TIP
Websocket 会识别 HTTP 请求的 X-Forwarded-For 头来覆写流量的源地址，优先级高于 PROXY protocol。
WebSocketObject WebSocketObject 对应传输配置的 wsSettings 项。
{ &amp;#34;acceptProxyProtocol&amp;#34;: false, &amp;#34;path&amp;#34;: &amp;#34;/&amp;#34;, &amp;#34;headers&amp;#34;: { &amp;#34;Host&amp;#34;: &amp;#34;xray.com&amp;#34; } } acceptProxyProtocol: true | false
仅用于 inbound，指示是否接收 PROXY protocol。
PROXY protocol 专用于传递请求的真实来源 IP 和端口，若你不了解它，请先忽略该项。
常见的反代软件（如 HAProxy、Nginx）都可以配置发送它，VLESS fallbacks xver 也可以发送它。
填写 true 时，最底层 TCP 连接建立后，请求方必须先发送 PROXY protocol v1 或 v2，否则连接会被关闭。
path string</description></item><item><title>设计思路</title><link>https://xtls.github.io/en/develop/intro/design/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/develop/intro/design/</guid><description>设计目标 Xray 内核提供了一个平台，支持必要的网络代理功能，在其之上可以进二次开发，以提供更好的用户体验； 以跨平台为首要原则，以减少二次开发的成本；
架构 内核分为三层：应用层、代理层和传输层。
每一层内包含数个模块，模块间互相独立，同类型的模块可无缝替换。
应用层 应用层包含一些代理层中常用的功能，这些功能被抽象出来，以便在不同的代理模块中复用。
应用层的模块应为纯软件实现，与硬件或平台相关的技术无关。
重要模块列表：
Dispatcher: 用于把入站代理所接收到的数据，传送给出站代理； Router: 路由模块，详见 路由配置； DNS: 内置的 DNS 服务器模块； Proxy Manager: 代理管理器；
代理层 代理层分为两部分：入站代理（Inbound Proxy）和出站代理（Outbound Proxy）。
两部分相互独立，入站代理不依赖于某个特定的出站代理，反之亦然。
入站代理 实现 proxy.Inbound 接口； 出站代理 实现 proxy.Outbound 接口；
传输层 传输层提供一些网络数据传输相关的工具模块。</description></item><item><title>透明代理（TProxy）配置教程</title><link>https://xtls.github.io/en/documents/level-2/tproxy/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/documents/level-2/tproxy/</guid><description>本配置基于TProxy 透明代理的新 V2Ray 白话文教程，加入了 Xray 的新特性，使用 VLESS + XTLS Splice 方案，并将旧教程中默认出站代理的分流方式改为默认出站直连，使用者请按照实际情况进行修改。
本文中所有配置已在 Raspberry Pi 2B、Ubuntu 20.04 环境下测试成功，如在其它环境中使用请自行调整配置。
开始之前 请检查您的设备是否有可用的网络连接，且服务端已经配置成功，客户端已经安装完毕。
需注意的是，目前很多透明代理教程都会将 Linux 系统的 IP 转发打开，但这样会导致 Splice 性能下降。详情请参考大案牍术破案纪实第三篇&amp;ndash;我们是如何破解 Splice 性能下降甚至低于 Direct 之谜的。
这里我想要补充的是，很多透明代理教程会使用 Netfilter 进行分流，使直连流量直接发出而不经过 Xray，这时必须开启 IP 转发；也有的教程，如本文，会将所有流量导入 Xray 之中，由 Xray 的路由模块进行分流，这时无需开启 IP 转发。
Xray 配置 { &amp;#34;log&amp;#34;: { &amp;#34;loglevel&amp;#34;: &amp;#34;warning&amp;#34;, &amp;#34;error&amp;#34;: &amp;#34;/var/log/xray/error.log&amp;#34;, &amp;#34;access&amp;#34;: &amp;#34;/var/log/xray/access.log&amp;#34; }, &amp;#34;inbounds&amp;#34;: [ { &amp;#34;tag&amp;#34;: &amp;#34;all-in&amp;#34;, &amp;#34;port&amp;#34;: 12345, &amp;#34;protocol&amp;#34;: &amp;#34;dokodemo-door&amp;#34;, &amp;#34;settings&amp;#34;: { &amp;#34;network&amp;#34;: &amp;#34;tcp,udp&amp;#34;, &amp;#34;followRedirect&amp;#34;: true }, &amp;#34;sniffing&amp;#34;: { &amp;#34;enabled&amp;#34;: true, &amp;#34;destOverride&amp;#34;: [ &amp;#34;http&amp;#34;, &amp;#34;tls&amp;#34; ] }, &amp;#34;streamSettings&amp;#34;: { &amp;#34;sockopt&amp;#34;: { &amp;#34;tproxy&amp;#34;: &amp;#34;tproxy&amp;#34; } } } ], &amp;#34;outbounds&amp;#34;: [ { &amp;#34;tag&amp;#34;: &amp;#34;direct&amp;#34;, &amp;#34;protocol&amp;#34;: &amp;#34;freedom&amp;#34;, &amp;#34;settings&amp;#34;: { &amp;#34;domainStrategy&amp;#34;: &amp;#34;UseIPv4&amp;#34; }, &amp;#34;streamSettings&amp;#34;: { &amp;#34;sockopt&amp;#34;: { &amp;#34;mark&amp;#34;: 2 } } }, { &amp;#34;tag&amp;#34;: &amp;#34;proxy&amp;#34;, &amp;#34;protocol&amp;#34;: &amp;#34;vless&amp;#34;, &amp;#34;settings&amp;#34;: { &amp;#34;vnext&amp;#34;: [ { &amp;#34;address&amp;#34;: &amp;#34;服务端域名&amp;#34;, &amp;#34;port&amp;#34;: 443, &amp;#34;users&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;UUID&amp;#34;, &amp;#34;flow&amp;#34;: &amp;#34;xtls-rprx-splice&amp;#34;, &amp;#34;encryption&amp;#34;: &amp;#34;none&amp;#34; } ] } ] }, &amp;#34;streamSettings&amp;#34;: { &amp;#34;network&amp;#34;: &amp;#34;tcp&amp;#34;, &amp;#34;security&amp;#34;: &amp;#34;xtls&amp;#34;, &amp;#34;sockopt&amp;#34;: { &amp;#34;mark&amp;#34;: 2 } } }, { &amp;#34;tag&amp;#34;: &amp;#34;block&amp;#34;, &amp;#34;protocol&amp;#34;: &amp;#34;blackhole&amp;#34;, &amp;#34;settings&amp;#34;: { &amp;#34;response&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;http&amp;#34; } } }, { &amp;#34;tag&amp;#34;: &amp;#34;dns-out&amp;#34;, &amp;#34;protocol&amp;#34;: &amp;#34;dns&amp;#34;, &amp;#34;settings&amp;#34;: { &amp;#34;address&amp;#34;: &amp;#34;8.</description></item><item><title>配置和运行时的问题</title><link>https://xtls.github.io/en/faq/config/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/faq/config/</guid><description>Q: 为什么windows下只有一个可执行程序? 我想要隐藏执行, 嘤嘤嘤.A1: 方式很多,如: 建立一个hiderun.vbs文件,放在xray.exe同一目录 编辑内容为
CreateObject(&amp;#34;WScript.Shell&amp;#34;).Run &amp;#34;xray.exe&amp;#34;,0 运行此vbs即可, 然后放个快捷方式到shell:startup里面，就可以开机启动了
A2: 也可以通过创建window服务/计划任务等方式实现,亦可借助一些专门的后台运行的工具(不太必要)
A3: CHP (Create Hidden Process)
A4: 用winsw可以将xray-core添加为Win的系统服务，开机自动运行，不需要手动隐藏窗口。
A5: 写一个bat开机启动
@echo off if &amp;#34;%1&amp;#34; == &amp;#34;h&amp;#34; goto begin mshta vbscript:createobject(&amp;#34;wscript.shell&amp;#34;).run(&amp;#34;%~nx0 h&amp;#34;,0)(window.close)&amp;amp;&amp;amp;exit :begin D:/Xray run -c D:/Xray.json `
Q: 无法用做Tor前置代理 #66关闭 sniffing 再试试.
Q: 如何自定义.dat文件的文件位置?设置环境变量 XRAY_LOCATION_ASSET 的值
Q: 为什么我配置了SSL证书但不可用? 检查证书权限 使用 fullchain 证书
Q: 我以前用gfw列表, 我现在用Xray怎么进行分流呢?</description></item><item><title>Configure and run</title><link>https://xtls.github.io/en/guide/config/</link><pubDate>Fri, 17 Jan 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/guide/config/</guid><description>Once you downloaded and installed xray, you will need to configure it.
For demonstration purposes, only simple configurations are described here.
For more complex configurations, please refer to the more detailed configuration file for more detailed instructions.
Server-side configuration You will need a server outside the firewall to run the server-side xray. Configure it as follows.
{ &amp;#34;inbounds&amp;#34;: [ { &amp;#34;port&amp;#34;: 10086, // Port that the server listens on &amp;#34;protocol&amp;#34;: &amp;#34;vmess&amp;#34;, &amp;#34;settings&amp;#34;: { &amp;#34;clients&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;b831381d-6324-4d53-ad4f-8cda48b30811&amp;#34; } ] } } ], &amp;#34;outbounds&amp;#34;: [ { &amp;#34;protocol&amp;#34;: &amp;#34;freedom&amp;#34; } ] } The server needs to be configured to ensure that the id and port are the same as the client&amp;rsquo;s and you will be able to connect properly.</description></item><item><title>【第3章】远程登录篇</title><link>https://xtls.github.io/en/documents/level-0/ch03-ssh/</link><pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/documents/level-0/ch03-ssh/</guid><description>3.1 远程登录VPS (PuTTY) 首先，鉴于零基础人群中Windows的用户基数最大，所以本文以Windows为例进行展示。
其次，虽然Windows 10之后的PowerShell和WSL也可以达到很好的SSH操作体验。但是因为并非所有版本的Windows都有最新的组件，故本文还是以老牌的PuTTY为例，进行SSH远程登录的操作详解。（使用其他工具的话、在SSH登陆之后的操作都是一样的）
下面就跟我一步步操作吧。
进入PuTTY的官网，选择适合你操作系统的版本下载。（本文以64位版本为例）
安装运行后，将会看到PuTTY的主界面。现在请拿出你上一章记东西的小本本，在下图的对应位置填入你VPS的IP地址(VPS IP)和端口(VPS PORT)。为了方便以后使用时不用重复输入，我们可以保存会话 (Saved Sessions)，未来使用时只要按Load即可一键载入设置。
我建议将 Connection 中的 keepalive 设置为 60 秒，防止你一段时间没有操作之后SSH自动断线。另外务必再次保存设置。
注意： 对PuTTY的任何设置更新都要再次手动保存Session，不然关闭后就会丢失
点击 Open 就会进入SSH连接窗口，对应下图输入用户名与密码，与你的VPS远程主机建立连接。（本文假设默认用户名是 root，另外，在Linux系统输入密码的时候，是不会出现 ****** 这种提示符的，这样可以避免密码长度泄漏，不是你的键盘坏掉了哦！）
3.2 成功登录SSH！初识命令行界面！ 如果你的信息都填写正确，你将会看到类似下图的界面，说明已登录成功：
这个界面，就等于远程服务器的【桌面】，但它没有你熟悉的图标和鼠标，没有绚丽的色彩，有的只是简单文字，这就是【命令行界面】- Command Line Interface，或者缩写为 CLI。
接下来的所有操作，都需要你像电影里的黑客一样，在这个命令行界面中完成。也许你会觉得陌生，但请相信我，使用命令行既不可怕，也不神秘。说到底，它只不过是把你习惯的鼠标操作变成了文字指令而已，你说一句，它做一句。
现在，你可以稍微观察并熟悉一下命令行环境，这个界面其实已经告诉了你一些有用的信息了，比如系统内核版本（比如图内是 4.19.37-5）、上次登录时间及IP等。当然根据VPS的不同，你看到的界面可能会略有不同。
请注意命令行最下面一行，闪动的光标左边，有一串字符。图中显示的是root@vps-server:~#，这一串要怎么理解呢？很简单：
现在的用户是 root root 所在的服务器是 vps-server root 现在所在的文件夹是 ~ # 之后是你可以输入命令的地方 前两个很直观，无需多说。第三个是关于Linux的文件夹系统，现在也不需要过于深入，你只需要知道，&amp;quot;~&amp;ldquo;就是【当前用户的大本营】。第四个，提示符#，你也不用管，只需要知道，未来文章中会写一些需要你输入的命令，都会以 &amp;ldquo;#&amp;rdquo; 或者 &amp;ldquo;$&amp;rdquo; 开头，提示你后面是你输入命令的地方。（所以你复制命令的时候，只需要复制后面的内容，不要复制提示符）</description></item><item><title>Domain Socket</title><link>https://xtls.github.io/en/config/transports/domainsocket/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/transports/domainsocket/</guid><description>important推荐写到 inbounds 的 listen 处，传输方式可选 TCP、WebSocket、HTTP/2.
未来这里的 DomainSocket 可能会被弃用。
Domain Socket 使用标准的 Unix domain socket 来传输数据。
它的优势是使用了操作系统内建的传输通道，而不会占用网络缓存。 理论上相比起本地环回网络（local loopback）来说，Domain socket 速度略快一些。
目前仅可用于支持 Unix domain socket 的平台，如 Linux 和 macOS。在 Windows 10 Build 17036 前不可用。
如果指定了 domain socket 作为传输方式，在入站出站代理中配置的端口和 IP 地址将会失效，所有的传输由 domain socket 取代。
DomainSocketObject DomainSocketObject 对应传输配置的 dsSettings 项。
{ &amp;#34;path&amp;#34;: &amp;#34;/path/to/ds/file&amp;#34;, &amp;#34;abstract&amp;#34;: false, &amp;#34;padding&amp;#34;: false } path: string
一个合法的文件路径。 important在运行 Xray 之前，这个文件必须不存在。
abstract: true | false</description></item><item><title>Freedom</title><link>https://xtls.github.io/en/config/outbound-protocols/freedom/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/outbound-protocols/freedom/</guid><description>Freedom 是一个出站协议，可以用来向任意网络发送（正常的） TCP 或 UDP 数据。
OutboundConfigurationObject { &amp;#34;domainStrategy&amp;#34;: &amp;#34;AsIs&amp;#34;, &amp;#34;redirect&amp;#34;: &amp;#34;127.0.0.1:3366&amp;#34;, &amp;#34;userLevel&amp;#34;: 0 } domainStrategy: &amp;ldquo;AsIs&amp;rdquo; | &amp;ldquo;UseIP&amp;rdquo; | &amp;ldquo;UseIPv4&amp;rdquo; | &amp;ldquo;UseIPv6&amp;rdquo;
在目标地址为域名时, 配置相应的值, Freedom 的行为模式如下:
&amp;quot;AsIs&amp;quot;: Freedom 通过系统DNS服务器解析获取IP, 向此域名发出连接. &amp;quot;UseIP&amp;quot;、&amp;quot;UseIPv4&amp;quot; 和 &amp;quot;UseIPv6&amp;quot;: Xray 使用内置 DNS 服务器解析获取IP, 向此域名发出连接. 默认值为 &amp;quot;AsIs&amp;quot;。 TIP 1
当使用 &amp;quot;UseIP&amp;quot; 模式，并且出站连接配置 中指定了 sendThrough 时，Freedom 会根据 sendThrough 的值自动判断所需的 IP 类型，IPv4 或 IPv6。
TIP 2
当使用 &amp;quot;UseIPv4&amp;quot; 或 &amp;quot;UseIPv6&amp;quot; 模式时，Freedom 会只使用对应的 IPv4 或 IPv6 地址。当 sendThrough 指定了不匹配的本地地址时，将导致连接失败。</description></item><item><title>HTTP</title><link>https://xtls.github.io/en/config/inbound-protocols/http/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/inbound-protocols/http/</guid><description>HTTP 协议。
importanthttp 协议没有对传输加密，不适宜经公网中传输，更容易成为被人用作攻击的肉鸡。
http inbound 更有意义的用法是在局域网或本机环境下监听，为其他程序提供本地服务。
TIP 1
http proxy 只能代理 tcp 协议，udp 系的协议均不能通过。
TIP 2
在 Linux 中使用以下环境变量即可在当前 session 使用全局 HTTP 代理（很多软件都支持这一设置，也有不支持的）。
export http_proxy=http://127.0.0.1:8080/ (地址须改成你配置的 HTTP 入站代理地址) export https_proxy=$http_proxy InboundConfigurationObject { &amp;#34;timeout&amp;#34;: 0, &amp;#34;accounts&amp;#34;: [ { &amp;#34;user&amp;#34;: &amp;#34;my-username&amp;#34;, &amp;#34;pass&amp;#34;: &amp;#34;my-password&amp;#34; } ], &amp;#34;allowTransparent&amp;#34;: false, &amp;#34;userLevel&amp;#34;: 0 } timeout: number
连接空闲的时间限制。单位为秒。默认值为 300, 0 表示不限时。
处理一个连接时，如果在 timeout 时间内，没有任何数据被传输，则中断该连接。
accounts: [AccountObject]
一个数组，数组中每个元素为一个用户帐号。默认值为空。</description></item><item><title>Mux.Cool 协议</title><link>https://xtls.github.io/en/develop/protocols/muxcool/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/develop/protocols/muxcool/</guid><description>Mux.Cool 协议是一个多路复用传输协议，用于在一条已建立的数据流中传输多个各自独立的数据流。
版本 当前版本是 1 Beta。
依赖 底层协议 Mux.Cool 必须运行在一个已建立的可靠数据流之上。
通讯过程 一个 Mux.Cool 连接中可传输若干个子连接，每个子连接有一个独立的 ID 和状态。传输过程由帧（Frame）组成，每一帧用于传输一个特定的子连接的数据。
客户端行为 当有连接需求时并且没有现有可用的连接时，客户端向服务器发起一个新连接，以下称为“主连接”。
一个主连接可用于发送若干个子连接。客户端可自主决定主连接可承载的子连接数量。 对于一个新的子连接，客户端必须发送状态New以通知服务器建立子连接，然后使用状态Keep来传送数据。 当子连接结束时，客户端发送End状态来通知服务器关闭子连接。 客户端可自行决定何时关闭主连接，但必须确定服务器也同时保持连接。 客户端可使用 KeepAlive 状态来避免服务器关闭主连接。
服务器端行为 当服务器端接收到新的子连接时，服务器应当按正常的连接来处理。
当收到状态End时，服务器端可以关闭对目标地址的上行连接。 在服务器的响应中，必须使用与请求相同的 ID 来传输子连接的数据。 服务器不能使用New状态。 服务器可使用 KeepAlive 状态来避免客户端关闭主连接。
传输格式 Mux.Cool 使用对称传输格式，即客户端和服务器发送和接收相同格式的数据。
帧格式 2 字节 L 字节 X 字节 元数据长度 L 元数据 额外数据</description></item><item><title>开发规范</title><link>https://xtls.github.io/en/develop/intro/guide/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/develop/intro/guide/</guid><description>基本 版本控制 project X 的代码被托管在github上:
xray 核心 xray-core xray-flutter xray-flutter 安装脚本 Xray-install 数据文件 Xray-rules-dat 配置模板 Xray-examples xray文档 XTLS.github.io 您可以使用 Git 来获取代码.
分支（Branch） 本项目的主干分支为 main, main 分支也是发布时所使用的代码分支, 因此需要确保 master 在任一时刻都是可编译可使用的。
如果需要开发新的功能
请新开分支进行开发, 在开发完成并且经过充分测试后, 合并回主干分支. 新开分支如没有必要再存在时, 可以去除. 发布（Release） In progress
建立尝鲜版本和稳定版本两个发布通道 临时版本, 主要用于特定情况的测试(比如从分支build的), 于TG群内/issue回复等渠道 发布特定版本 尝鲜版本可以为daily build , 用于尝鲜和获得即时反馈和再改进. 稳定版本为定时更新(比如周更), 合并稳定的修改并发布. 引用其它项目 Golang 产品代码建议使用 Golang 标准库和 golang.</description></item><item><title>性能相关的问题</title><link>https://xtls.github.io/en/faq/performance/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/faq/performance/</guid><description>Q: 我是瓜瓜, 我想问 Xray 是不是最快的?是.
Q: 什么工具或协议组合最快啊?/我应该用什么工具协议组合啊?个人自建上网,首先考虑安全性和伪装性,然后选择能满足自己需求的最高性能组合
上网速率的高低, 体感的快慢, 根本的决定因素是线路 因此所有的选择跟你的实际环境息息相关,有时候需要一些特殊手段处理, 比如
比如低质量的线路可用使用CF加速. 比如晚上高峰期严重丢包的情况下, 可用使用mkcp(上限很低), 让线路尽量跑的更流畅一些. 在通常的环境下, 各种工具/协议组合的性能的高低, 可以参考Xray性能对比测试
Q: mac和win 使用splice是不是无解了？ Windows 提供了 TransmitFile，但似乎不能用于两个 TCP 对接 Windows 10 有 WSL WSL 1 使用 Splice 性能捉急. 不清楚 WSL 2 会不会带来额外拷贝开销，需要更多勇士尝试并反馈. macOS暂无计划 Q: 有无xtls+splice+ws的计划？XTLS 原理上不支持 WS
不带 TLS 的 WS 理论上可以支持类似 XTLS 的东西，目前没有实现它的计划
或者 看看这里</description></item><item><title>透明代理通过gid规避Xray流量</title><link>https://xtls.github.io/en/documents/level-2/iptables_gid/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/documents/level-2/iptables_gid/</guid><description>在现有的iptables透明代理白话文(新 V2Ray 白话文指南-透明代理 、 新 V2Ray 白话文指南-透明代理(TPROXY) 、 透明代理（TProxy）配置教程)教程中，对Xray流量的规避处理是打mark实现的。即对Xray出站流量打mark，通过设置iptables规则对对应mark的流量直连，来规避Xray流量，防止回环。
这么做有以下几个问题：
莫名流量进入PREROUTING链
安卓系统有自己的mark机制，该方案在安卓上不可用
本教程的方案不需要设置mark，理论性能更高，同时也不存在上述问题。
思路 tproxy流量只能被root权限用户(uid==0)或其他有CAP_NET_ADMIN权限的用户接收。
iptables规则可以通过uid(用户id)和gid(用户组id)分流。
让Xray运行在一个uid==0但gid!=0的用户上，设置iptables规则不代理该gid的流量来规避Xray流量。
配置过程 1. 前期准备 安卓系统
系统已root
安装 busybox
有一个可以执行命令的终端，可以使用adb shell，termux等。
其它Linux系统
需要依赖sudo，iptables的tproxy模块和extra模块。
一般系统都有自带，openwrt运行：
opkg install sudo iptables-mod-tproxy iptables-mod-extra 另附上一些openwrt常用的依赖，缺少可能导致Xray无法运行
opkg install libopenssl ca-certificates 2. 添加用户(安卓用户请忽略) 安卓系统不支持/etc/passwd文件来管理用户，请忽略，直接下一步。
grep -qw xray_tproxy /etc/passwd || echo &amp;#34;xray_tproxy:x:0:23333:::&amp;#34; &amp;gt;&amp;gt; /etc/passwd 其中xray_tproxy是用户名，0是uid，23333是gid，用户名和gid可以自己定，uid必须为0。 检查用户是否添加成功，运行
sudo -u xray_tproxy id 显示的结果应该是uid为0，gid为23333</description></item><item><title>Command parameters</title><link>https://xtls.github.io/en/guide/command/</link><pubDate>Fri, 17 Jan 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/guide/command/</guid><description>TIP
Xray uses go-style commands and parameters
Get basic commands You can run xray help to get all the basics of xray usage, as well as the available commands and instructions.
Xray is a platform for building proxies. Usage: xray &amp;lt;command&amp;gt; [arguments] The commands are: run Run Xray with config, the default command version Show current version of Xray api Call an API in an Xray process tls TLS tools uuid Generate new UUIDs Use &amp;#34;xray help &amp;lt;command&amp;gt;&amp;#34; for more information about a command.</description></item><item><title>【第4章】安全防护篇</title><link>https://xtls.github.io/en/documents/level-0/ch04-security/</link><pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/documents/level-0/ch04-security/</guid><description>4.1 为什么要做安全防护 Linux服务器的安全防护是一个纷繁复杂的巨大课题。无数的网站、APP、服务、甚至线下基础设施都建立在Linux的基石之上，这背后牵涉到巨大的经济利益和商业价值，当然也就就意味着黑灰产有巨大的攻击动力。但是这些服务是如此重要、根本不允许出现重大的安全漏洞。于是无数的运维专业人员都在安全攻防的战场上拼搏努力，这才让大家能享受到基本稳定的现代化数字生活。
现在，你拥有了一台VPS，并且将会敞开他的数据访问渠道来达到流量转发的目标，那就相当于你已经置身于安全攻防战场的第一线、直面所有风险。但与此同时，新人由于知识和信息的不足，看待安全问题是总是难免两极分化：要么觉得轻如鸿毛和自己没有半点关系，要么觉得重于泰山甚至惶惶不可终日。
对于前者，我的建议是：安全无小事，尽量多查一些安全方面的信息，免得自己真的受了损失才后悔莫及
对于后者，我的建议是：不用紧张，我们的服务器仍不具有太高的价值、一般不会吸引到高水平的攻击，需要面对的基本都是一些自动化脚本的恶意扫描和登录尝试，跟着本文做一些基础的防护即可
4.2 具体的风险到底是什么 就像我们在《远程登录篇》配置的一样，任何人只需要知道【IP地址】+【端口】+【用户名】+【密码】这四个要素，就能登录你的VPS服务器。那很显然，这四要素的安全就是我们要防护的底线。我们来逐一分析：
【IP地址】：恶意脚本会随机尝试和扫描IP段，可以简单认为是公开信息、无法隐藏
【端口】：如果使用默认端口，那么【端口 = 22】
【用户名】：如果使用默认用户，那么【用户名 = root】
【密码】：密码不存在默认值，一定是由VPS后台随机生成或由你自行设置的。也就是说，如果你的服务器都是默认设置，则四要素中的三个已经是已知的，那么你整个服务器的安全，就全部寄托在一串小小的密码上了。这时有几种情况：
如果你用了VPS管理后台随机生成密码，它一般包含随机的十几个大小写混杂的字母和符号，相对比较安全
如果你为了好记、把密码改成了类似123456这种超弱的密码，破解你的VPS服务器可谓不费吹灰之力
如果你为了好记、把密码改成了比较复杂、但在别的地方用过的密码，其实也并不安全。你要明白黑客手里有作弊器，比如说密码表，包含数万、数十万、数百万甚至更多曾经泄漏的真实密码）
但你要明白，没有哪个黑客真的要坐在电脑前一次一次的尝试你的密码，全部的攻击尝试都是恶意脚本自动进行的，它会24小时不眠不休的工作。也许每天你酣睡之时，你的服务器都在经受着一轮又一轮的冲击。
一旦密码被成功撞破，意味着你的四要素全部被攻击者掌握，恶意脚本就会快速登录服务器、获取服务器的最高 root 控制权、安装部署它的恶意服务，然后就可以用你的服务器来24小时做各种坏事（比如挖矿、传播病毒、发送垃圾邮件、欺诈邮件、做BT中继、甚至暗网公众节点等等等等）。如果恶意脚本比较克制，其实可以做到相当的隐蔽性。而新人一般也不会去观察留意VPS的登录记录、进程变化、CPU占用变化、流量变化等指标，你其实就很难发现自己被黑了。直到你的VPS服务商封禁你的账号、或者收到律师函为止。
别忘了，你获得VPS时大概率需要使用真实的支付信息，你登录各种网站、社交平台时也会留下你的IP地址，这些都与你的身份有直接或者间接的关系。于是，一旦这些坏事发生，它们就不可避免的与你产生了关联。
4.3 我们要做的安全防护有哪些 基于上述分析，我们要做的，自然就是对【端口】、【用户名】、【密码】这三要素进行加强，来降低被攻破的风险：
【端口】：将SSH远程登录端口修改为【非22端口】 （4.4） 【用户名】：建立【非root】的新用户、并禁用root用户SSH远程登录 （4.5、4.6） 【密码】：SSH启用RSA密钥验证登录、同时禁用密码验证登录 （4.7） 记得按顺序来，别把自己锁在门外了。</description></item><item><title>HTTP</title><link>https://xtls.github.io/en/config/outbound-protocols/http/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/outbound-protocols/http/</guid><description>HTTP 协议。
importanthttp 协议没有对传输加密，不适宜经公网中传输，更容易成为被人用作攻击的肉鸡。
http inbound 更有意义的用法是在局域网或本机环境下监听，为其他程序提供本地服务。
TIP
http proxy 只能代理 tcp 协议，udp 系的协议均不能通过。
OutboundConfigurationObject { &amp;#34;servers&amp;#34;: [ { &amp;#34;address&amp;#34;: &amp;#34;192.168.108.1&amp;#34;, &amp;#34;port&amp;#34;: 3128, &amp;#34;users&amp;#34;: [ { &amp;#34;user&amp;#34;: &amp;#34;my-username&amp;#34;, &amp;#34;pass&amp;#34;: &amp;#34;my-password&amp;#34; } ] } ] } TIP
目前 HTTP 协议 ounbound 中 streamSettings 设置 security 和 tlsSettings 是生效的。
servers: [ ServerObject ]
HTTP 服务器列表，其中每一项是一个服务器配置，若配置多个，循环使用 (RoundRobin)。
ServerObject { &amp;#34;address&amp;#34;: &amp;#34;192.168.108.1&amp;#34;, &amp;#34;port&amp;#34;: 3128, &amp;#34;users&amp;#34;: [ { &amp;#34;user&amp;#34;: &amp;#34;my-username&amp;#34;, &amp;#34;pass&amp;#34;: &amp;#34;my-password&amp;#34; } ] } address: string</description></item><item><title>mKCP</title><link>https://xtls.github.io/en/config/transports/mkcp/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/transports/mkcp/</guid><description>mKCP 使用 UDP 来模拟 TCP 连接。
mKCP 牺牲带宽来降低延迟。传输同样的内容，mKCP 一般比 TCP 消耗更多的流量。
TIP
请确定主机上的防火墙配置正确
KcpObject KcpObject 对应传输配置的 kcpSettings 项。
{ &amp;#34;mtu&amp;#34;: 1350, &amp;#34;tti&amp;#34;: 20, &amp;#34;uplinkCapacity&amp;#34;: 5, &amp;#34;downlinkCapacity&amp;#34;: 20, &amp;#34;congestion&amp;#34;: false, &amp;#34;readBufferSize&amp;#34;: 1, &amp;#34;writeBufferSize&amp;#34;: 1, &amp;#34;header&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;none&amp;#34; }, &amp;#34;seed&amp;#34;: &amp;#34;Password&amp;#34; } mtu: number
最大传输单元（maximum transmission unit）
请选择一个介于 576 - 1460 之间的值。
默认值为 1350。
tti: number
传输时间间隔（transmission time interval），单位毫秒（ms），mKCP 将以这个时间频率发送数据。
请选译一个介于 10 - 100 之间的值。
默认值为 50。</description></item><item><title>mKCP 协议</title><link>https://xtls.github.io/en/develop/protocols/mkcp/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/develop/protocols/mkcp/</guid><description>mKCP 是流式传输协议，由 KCP 协议修改而来，可以按顺序传输任意的数据流。
版本 mKCP 没有版本号，不保证版本之间兼容性。
依赖 底层协议 mKCP 是一个基于 UDP 的协议，所有通讯使用 UDP 传输。
函数 fnv: FNV-1a 哈希函数 输入参数为任意长度的字符串； 输入出一个 32 位无符号整数；
通讯过程 mKCP 将数据流拆成若干个数据包进行发送。一个数据流有一个唯一标识，用以区分不同的数据流。数据流中的每一个数据包都携带了同样的标识。 mKCP 没有握手过程，当收到一个数据包时，根据其携带的数据流的标识来判断是否为新的通话，或是正在进行中的通话。 每一个数据包中包含若干个片段（Segment），片段分为三类：数据（Data）、确认（ACK）、心跳（Ping）。每个片段需要单独处理。
数据格式 数据包 4 字节 2 字节 L 字节 认证信息 A 数据长度 L 片段部分 其中：</description></item><item><title>Socks</title><link>https://xtls.github.io/en/config/inbound-protocols/socks/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/inbound-protocols/socks/</guid><description>标准 Socks 协议实现，兼容 Socks 4、Socks 4a 和 Socks 5。
importantsocks 协议没有对传输加密，不适宜经公网中传输
socks inbound 更有意义的用法是在局域网或本机环境下监听，为其他程序提供本地服务。
InboundConfigurationObject { &amp;#34;auth&amp;#34;: &amp;#34;noauth&amp;#34;, &amp;#34;accounts&amp;#34;: [ { &amp;#34;user&amp;#34;: &amp;#34;my-username&amp;#34;, &amp;#34;pass&amp;#34;: &amp;#34;my-password&amp;#34; } ], &amp;#34;udp&amp;#34;: false, &amp;#34;ip&amp;#34;: &amp;#34;127.0.0.1&amp;#34;, &amp;#34;userLevel&amp;#34;: 0 } auth: &amp;ldquo;noauth&amp;rdquo; | &amp;ldquo;password&amp;rdquo;
Socks 协议的认证方式，支持 &amp;quot;noauth&amp;quot; 匿名方式和 &amp;quot;password&amp;quot; 用户密码方式。
默认值为 &amp;quot;noauth&amp;quot;。
accounts: [ AccountObject ]
一个数组，数组中每个元素为一个用户帐号。
此选项仅当 auth 为 password 时有效。
默认值为空。
udp: true | false
是否开启 UDP 协议的支持。
默认值为 false。</description></item><item><title>Xray的工作模式</title><link>https://xtls.github.io/en/documents/level-1/work/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/documents/level-1/work/</guid><description>单服务器模式 与其它的网络代理工具一样，你需要一台配置了 Xray 的服务器，然后在自己的设备上安装并配置 Xray 客户端，然后即可流畅地访问互联网。
mermaid.initialize({startOnLoad:true}); graph LR; A(PC) -.- B(防火墙); B -.- C(墙外网站); A -- D(Xray/VPS); D -- C; A -- E(墙内网站); 一个 Xray 服务器可同时支持多台设备使用不同的代理协议访问。同时，经过合理的配置，Xray 可以识别并区分需要代理以及不需要代理的流量，直连的流量不需要绕路。
桥接模式 如果你不想在每一台设备上都配置路由，你也可以设置一台中转服务器，用于接收客户端发来的所有流量，然后在服务器中进行转发判断。
mermaid.initialize({startOnLoad:true}); graph LR; A(PC) -.- B(防火墙); B -.- C(墙外网站); A -- D(墙内 VPS); D -- E(墙外 VPS); E -- C; D -- F(墙内网站);
工作原理 在配置 Xray 之前，不妨先来看一下 Xray 的工作原理，以下是单个 Xray 进程的内部结构示意图。多个 Xray 之间相互独立，互不影响。</description></item><item><title>透明代理相关问题</title><link>https://xtls.github.io/en/faq/tproxy/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/faq/tproxy/</guid><description> Q: 我搭建了透明代理给我和我同宿舍/隔壁宿舍的同学用, 日志中出现很多 too many open files .怎么办? 急,在线等.让你的同学少用BT过代理下载American Video 在 /etc/systemd/system/xray.service 的 [Service] 下加 LimitNPROC=10000 和 LimitNOFILE=1000000.
Q: sniffing的具体功能是什么，什么时候发挥作用?sniffing流量探测主要作用是用在透明代理等用途.
他的一个典型工作流程是这样的.
比如你有一个设备上网,去访问abc.com, 首先设备通过DNS查询得到abc.com的IP是1.2.3.4,然后设备会向1.2.3.4发起连接.
透明代理不设置嗅探的话,收到的连接请求是1.2.3.4,是不能走域名规则的路由分流的. 透明代理设置了sniffing,处理这个流量时,会从这个流量的数据中,嗅探出域名,abc.com. 然后把1.2.3.4重置为abc.com. 路由就可以根据域名进行符合域名规则的分流, 或者做更多的事情. 因为变成了一个向abc.com请求的连接,就可以做更多的事情,包括路由域名规则分流, 重新做DNS解析等等&amp;hellip;
另一个sniffing的作用是可以嗅探BT流量的标识,把流量归类成BT类型. 然后可以在路由中根据BT类型来做规则,比如服务端用来拦截BT流量,比如客户端把BT流量固定发送到某个VPS去代理等.</description></item><item><title>Usage Documents</title><link>https://xtls.github.io/en/guide/document/</link><pubDate>Fri, 17 Jan 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/guide/document/</guid><description>View documents You can use the menu on the left to select the relevant category you want to see.
Once you have selected a menu item, you can quickly switch between the articles in that category in the navigation bar at the top of the text area.
When viewing an article, you can quickly switch to one of the headings by using the list of headings on the right.</description></item><item><title>【第5章】网站建设篇</title><link>https://xtls.github.io/en/documents/level-0/ch05-webpage/</link><pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/documents/level-0/ch05-webpage/</guid><description>5.1 为什么要做一个网站？ 新人也许会迷惑，为什么科学上网还要建一个网站？我不会编程啊，是不是特别麻烦？
先回答第一个问题，建网站的原因有：
申请合法的TLS证书（非常重要） 提供合理的回落，防止主动探测攻击，提高安全性 建设一个伪装站（如博客、私人网盘、多媒体网站、游戏网站等），直接访问时有合理的前台，使流量使用看上去更合理。 再回答第二个问题：
本文作为演示，仅仅使用了一个最简单的【单文件html页面 + Nginx】来搭建，以此完成上面的目标，所以【非常简单】 这个网站完全可以不仅仅是伪装，而是真的做大做强，这个复杂性就完全取决于你了 对于“伪装”和“网站运营”这个目标，需要的就是各不相同、秀出真我，需要的同学可以自行搜索学习。这个内容已经完全偏离了科学上网，本文就不深入解析了。 5.2 登录VPS、安装运行Nginx 这里用到的，都是之前已经详解过的命令，所以就不重复讲解了。看不懂的同学可以看看前面的章节哦。
$ sudo apt update &amp;amp;&amp;amp; sudo apt install nginx 完成后，Nginx已经自动运行。此时打开Windows上的浏览器并输入 http://100.200.300.400:80，若看到下图的界面就说明Nginx已经正常在运行了。
5.3. 创建一个最简单的网页 小小白白Linux基础命令：
编号 命令名称 命令说明 cmd-10 mkdir 新建文件夹 cmd-11 systemctl reload 重新加载某个服务 小小白白Linux基础配置文件：</description></item><item><title>HTTP/2</title><link>https://xtls.github.io/en/config/transports/h2/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/transports/h2/</guid><description>基于 HTTP/2 的传输方式。
它完整按照 HTTP/2 标准实现，可以通过其它的 HTTP 服务器（如 Nginx）进行中转。
由 HTTP/2 的建议，客户端和服务器必须同时开启 TLS 才可以正常使用这个传输方式。
TIP
当前版本的 HTTP/2 的传输方式并不强制要求服务器端有 TLS 配置.
这使得可以在特殊用途的分流部署环境中，由外部网关组件完成 TLS 层对话，Xray 作为后端应用，网关和 Xray 间使用称为 h2c 的明文 http/2 进行通讯。
HttpObject HttpObject 对应传输配置的 httpSettings 项。
{ &amp;#34;host&amp;#34;: [&amp;#34;xray.com&amp;#34;], &amp;#34;path&amp;#34;: &amp;#34;/random/path&amp;#34; } host: [string]
一个字符串数组，每一个元素是一个域名。
客户端会随机从列表中选出一个域名进行通信，服务器会验证域名是否在列表中。
path string
HTTP 路径，由 / 开头, 客户端和服务器必须一致。
默认值为 &amp;quot;/&amp;quot;。</description></item><item><title>Socks</title><link>https://xtls.github.io/en/config/outbound-protocols/socks/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/outbound-protocols/socks/</guid><description>标准 Socks 协议实现，兼容 Socks 4、Socks 4a 和 Socks 5。
importantsocks 协议没有对传输加密，不适宜经公网中传输
socks inbound 更有意义的用法是在局域网或本机环境下监听，为其他程序提供本地服务。
OutboundConfigurationObject { &amp;#34;servers&amp;#34;: [ { &amp;#34;address&amp;#34;: &amp;#34;127.0.0.1&amp;#34;, &amp;#34;port&amp;#34;: 1234, &amp;#34;users&amp;#34;: [ { &amp;#34;user&amp;#34;: &amp;#34;test user&amp;#34;, &amp;#34;pass&amp;#34;: &amp;#34;test pass&amp;#34;, &amp;#34;level&amp;#34;: 0 } ] } ] } servers: [ ServerObject ]
Socks 服务器列表，其中每一项是一个服务器配置。
ServerObject { &amp;#34;address&amp;#34;: &amp;#34;127.0.0.1&amp;#34;, &amp;#34;port&amp;#34;: 1234, &amp;#34;users&amp;#34;: [ { &amp;#34;user&amp;#34;: &amp;#34;test user&amp;#34;, &amp;#34;pass&amp;#34;: &amp;#34;test pass&amp;#34;, &amp;#34;level&amp;#34;: 0 } ] } address: address</description></item><item><title>VLESS</title><link>https://xtls.github.io/en/config/inbound-protocols/vless/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/inbound-protocols/vless/</guid><description>important目前 VLESS 没有自带加密，请用于可靠信道，如 TLS。 目前 VLESS 不支持分享。
VLESS 是一个无状态的轻量传输协议，它分为入站和出站两部分，可以作为 Xray 客户端和服务器之间的桥梁。
与 VMess 不同，VLESS 不依赖于系统时间，认证方式同样为 UUID，但不需要 alterId。
InboundConfigurationObject { &amp;#34;clients&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;27848739-7e62-4138-9fd3-098a63964b6b&amp;#34;, &amp;#34;level&amp;#34;: 0, &amp;#34;email&amp;#34;: &amp;#34;love@xray.com&amp;#34;, &amp;#34;flow&amp;#34;: &amp;#34;xtls-rprx-direct&amp;#34; } ], &amp;#34;decryption&amp;#34;: &amp;#34;none&amp;#34;, &amp;#34;fallbacks&amp;#34;: [ { &amp;#34;dest&amp;#34;: 80 } ] } clients: [ ClientObject ]
一个数组，代表一组服务端认可的用户.
其中每一项是一个用户 ClientObject。
decryption: &amp;ldquo;none&amp;rdquo;
现阶段需要填 &amp;quot;none&amp;quot;，不能留空。 若未正确设置 decryption 的值，使用 Xray 或 -test 时会收到错误信息。
注意这里是 decryption，和 clients 同级。 decryption 和 vmess 协议的 encryption 的位置不同，是因为若套一层约定加密，服务端需要先解密才能知道是哪个用户。</description></item><item><title>回落相关问题</title><link>https://xtls.github.io/en/faq/fallback/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/faq/fallback/</guid><description> Q: 回落是个啥?好吃吗?Fallback 是 Xray 的最强大功能之一, 可有效防止主动探测, 自由配置常用端口多服务共享
点此查看详情 回落
Q: 为什么我回落以后nginx日志的IP是 127.0.0.1?需要开启 proxy protocol. 参见fallbacks配置的xver参数
Q: 我还是上一题的提问者, 那么我如何使用proxy protocol,达到所有日志都有源IP的目的呢?等待好心人写一篇小小白白话文
Q: Wordpress 是 Mixed Content, 回落到配置的Wordpress看起来怪怪的, 怎么办?@Ardentwheel :
需要在nginx的配置中加入以下内容，才可以修复
add_header Content-Security-Policy &amp;#34;upgrade-insecure-requests&amp;#34;;</description></item><item><title>【第6章】证书管理篇</title><link>https://xtls.github.io/en/documents/level-0/ch06-certificates/</link><pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/documents/level-0/ch06-certificates/</guid><description>6.1 申请TLS证书 接下来我们要做的，是为我们的域名申请一个真实的TLS证书，使网站具备标准TLS加密的能力及HTTPS访问的能力。这就是Xray等现阶段安全代理工具确保流量充分加密最重要的工具。
注意： 请不要轻易使用自签证书。它并没有让操作简单太多，但增加了无谓的风险（如中间人攻击）。
这里我会使用一个叫做 acme.sh 的证书管理工具，它简单、轻量、高效，并可完成证书自动更新。
另外，我相信，现在你已经逐渐熟悉了Linux的基础操作，所以已经多次出现的命令从本章开始不再重复截图、只做简单的描述。如果实在想不起来怎么用的话，就稍微复习一下前面的章节吧。
6.2 安装 acme.sh 小小白白Linux基础命令：
编号 命令名称 命令说明 cmd-12 wget 访问（或下载）某个网页文件 cmd-13 acme.sh acme.sh证书管理相关的命令 运行安装脚本
$ wget -O - https://get.acme.sh | sh 让 acme.sh 命令生效
$ . .bashrc 开启 acme.sh 的自动升级
$ acme.sh --upgrade --auto-upgrade 到这一步的完整流程如下图：</description></item><item><title>QUIC</title><link>https://xtls.github.io/en/config/transports/quic/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/transports/quic/</guid><description>QUIC 全称 Quick UDP Internet Connection，是由 Google 提出的使用 UDP 进行多路并发传输的协议。其主要优势是:
减少了握手的延迟（1-RTT 或 0-RTT） 多路复用，并且没有 TCP 的阻塞问题 连接迁移，（主要是在客户端）当由 Wifi 转移到 4G 时，连接不会被断开。 QUIC 目前处于实验期，使用了正在标准化过程中的 IETF 实现，不能保证与最终版本的兼容性。
默认设定: 12 字节的 Connection ID 30 秒没有数据通过时自动断开连接 (可能会影响一些长连接的使用) QuicObject QuicObject 对应传输配置的 quicSettings 项。
important对接的两端的配置必须完全一致，否则连接失败。 QUIC 强制要求开启 TLS，在传输配置中没有开启 TLS 时，Xray 会自行签发一个证书进行 TLS 通讯。
{ &amp;#34;security&amp;#34;: &amp;#34;none&amp;#34;, &amp;#34;key&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;header&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;none&amp;#34; } } security: &amp;ldquo;none&amp;rdquo; | &amp;ldquo;aes-128-gcm&amp;rdquo; | &amp;ldquo;chacha20-poly1305&amp;rdquo;</description></item><item><title>VLESS</title><link>https://xtls.github.io/en/config/outbound-protocols/vless/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/outbound-protocols/vless/</guid><description>important目前 VLESS 没有自带加密，请用于可靠信道，如 TLS。 目前 VLESS 不支持分享。
VLESS 是一个无状态的轻量传输协议，它分为入站和出站两部分，可以作为 Xray 客户端和服务器之间的桥梁。
与 VMess 不同，VLESS 不依赖于系统时间，认证方式同样为 UUID，但不需要 alterId。
OutboundConfigurationObject { &amp;#34;vnext&amp;#34;: [ { &amp;#34;address&amp;#34;: &amp;#34;example.com&amp;#34;, &amp;#34;port&amp;#34;: 443, &amp;#34;users&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;27848739-7e62-4138-9fd3-098a63964b6b&amp;#34;, &amp;#34;encryption&amp;#34;: &amp;#34;none&amp;#34;, &amp;#34;flow&amp;#34;: &amp;#34;xtls-rprx-direct&amp;#34;, &amp;#34;level&amp;#34;: 0 } ] } ] } vnext: [ ServerObject ]
一个数组, 表示 VLESS 服务器列表，包含一组指向服务端的配置, 其中每一项是一个服务器配置。
ServerObject { &amp;#34;address&amp;#34;: &amp;#34;example.com&amp;#34;, &amp;#34;port&amp;#34;: 443, &amp;#34;users&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;27848739-7e62-4138-9fd3-098a63964b6b&amp;#34;, &amp;#34;encryption&amp;#34;: &amp;#34;none&amp;#34;, &amp;#34;flow&amp;#34;: &amp;#34;xtls-rprx-direct&amp;#34;, &amp;#34;level&amp;#34;: 0 } ] } address: address</description></item><item><title>VMess</title><link>https://xtls.github.io/en/config/inbound-protocols/vmess/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/inbound-protocols/vmess/</guid><description>VMess 是一个加密传输协议，通常作为 Xray 客户端和服务器之间的桥梁。
importantVMess 依赖于系统时间，请确保使用 Xray 的系统 UTC 时间误差在 90 秒之内，时区无关。在 Linux 系统中可以安装ntp服务来自动同步系统时间。
InboundConfigurationObject { &amp;#34;clients&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;27848739-7e62-4138-9fd3-098a63964b6b&amp;#34;, &amp;#34;level&amp;#34;: 0, &amp;#34;alterId&amp;#34;: 0, &amp;#34;email&amp;#34;: &amp;#34;love@xray.com&amp;#34; } ], &amp;#34;default&amp;#34;: { &amp;#34;level&amp;#34;: 0, &amp;#34;alterId&amp;#34;: 0 }, &amp;#34;detour&amp;#34;: { &amp;#34;to&amp;#34;: &amp;#34;tag_to_detour&amp;#34; }, &amp;#34;disableInsecureEncryption&amp;#34;: false } clients: [ ClientObject ]
一个数组，代表一组服务端认可的用户.
其中每一项是一个用户ClientObject。
当此配置用作动态端口时，Xray 会自动创建用户。
detour: DetourObject
指示对应的出站协议使用另一个服务器。
default: DefaultObject
可选，clients 的默认配置。仅在配合detour时有效。
disableInsecureEncryption: true | false
是否禁止客户端使用不安全的加密方式，如果设置为 true 当客户端指定下列加密方式时，服务器会主动断开连接。</description></item><item><title>XTLS相关问题</title><link>https://xtls.github.io/en/faq/xtls/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/faq/xtls/</guid><description> Q: XTLS是个啥?好吃吗?XTLS 是 Xray 的原创黑科技, 也是使 Xray 性能一骑绝尘的核心动力
点此查看详情 XTLS
Q: TLS和XTLS有啥区别?XTLS会不安全吗?安全性没有区别. 传输的数据都是完全加密的
TLS / XTLS 是目前最安全的传输加密方案, 且外部看来流量类型和正常上网具有一致性.
性能有区别. XTLS比TLS快的多的多的多.
启用 XTLS 并且配置合适的XTLS流控模式, 可以在保持和 TLS 相同的安全性的前提下, 性能达到数倍甚至十几倍的提升.
Q: 听说XTLS的数据是不完全加密的，是这样的吗?此说法错误，XTLS传输的数据是完全加密的，和TLS没有区别。
XTLS去掉了旧时代翻墙模式中不必要的对加密数据的重复加密。即:
如果原始数据是已经经过TLS加密的数据（通常上网，绝大部分数据都是已经TLS加密过的数据了），此时XTLS不再和旧时代工具一样进行无用的重复加密，从而获得卓越性能。 如果原始数据不是经过TLS加密的，而是明文数据，XTLS会进行TLS加密。 因此XTLS数据仍然是完全TLS加密的，并且去掉了毫无意义的不必要的重复加密，而不是所谓的不完全加密。
同时外部看来流量类型和正常上网具有一致性，更具隐蔽性，是最安全的模式。</description></item><item><title>【第7章】Xray服务器篇</title><link>https://xtls.github.io/en/documents/level-0/ch07-xray-server/</link><pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/documents/level-0/ch07-xray-server/</guid><description>7.1 博观而约取，厚积而薄发 本文撰写过程中，大佬开玩笑的吐槽到：你这教程，居然连载了6章都还没到Xray，不知道的还以为你是“手把手教你建网站”教程呢。（我竟无法反驳.jpg!）
其实这样的结构是我多番思考之后的决定，毕竟只有打好基础，才能在后面事半功倍快速反超。我在群里看到许多新人连nano都无法正确使用，也不会用WinSCP，远程手写编辑出来的config.json自然错误百出，连查错也变得举步维艰。
经过了前6章的准备，各位已经跟我一起翻越了Linux基本操作、VPS远程管理、网页搭建、域名管理、证书申请等等几座大山。是不是回头看看，觉得其实非常简单呢？现在我们有了如此扎实的准备，接下来安装和配置Xray时会有一种【水到渠成】的轻快感觉。
后面要做的事情非常简单：
安装 配置（如安装TLS证书、config.json） 运行 优化（如更新内核、开启bbr、网站http访问自动跳转https等） 7.2 安装Xray 首先，Xray的官方载体，就是 xray-core 开源项目（基于 MPL 2.0 开源协议）生成的二进制程序。你把这个二进制放在服务器运行，它就是服务器端；你把它下载到本地电脑运行，它就是客户端。主要区别来源于【配置】。
安装时，直接使用官方安装脚本就很简单直接。它提供了多种安装选项，有兴趣的可以去官方的安装脚本仓库中看看脚本的说明，本文使用的是【非root用户】安装模式。
写本文时，安装脚本在使用非root账户时有一些小bug，所以我决定正好把这几步分开操作，可以顺便说明一下Linux下的删除命令。
小小白白Linux基础命令：
编号 命令名称 命令说明 cmd-14 rm 删除命令 将安装脚本下载至本地：
$ wget https://github.com/XTLS/Xray-install/raw/main/install-release.sh 执行安装命令
$ sudo bash install-release.sh 使用完成之后可以删除该脚本
$ rm ~/install-release.sh 注意： 使用 rm 命令删除文件的时候，默认其实就是删除现在所在的文件夹下的文件。但是，我依然写了完整的路径： ~/install-release.sh，这是我使用 rm 时的一个安全习惯、也是我把安装分成几步之后想强调一下的内容。如果你听过一些“程序员从删库到跑路”之类的段子，大概就知道为什么了。</description></item><item><title>Trojan</title><link>https://xtls.github.io/en/config/inbound-protocols/trojan/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/inbound-protocols/trojan/</guid><description>Trojan 协议
importantTrojan 被设计工作在正确配置的加密 TLS 隧道
InboundConfigurationObject { &amp;#34;clients&amp;#34;: [ { &amp;#34;password&amp;#34;: &amp;#34;password&amp;#34;, &amp;#34;email&amp;#34;: &amp;#34;love@xray.com&amp;#34;, &amp;#34;level&amp;#34;: 0, &amp;#34;flow&amp;#34;: &amp;#34;xtls-rprx-direct&amp;#34; } ], &amp;#34;fallbacks&amp;#34;: [ { &amp;#34;dest&amp;#34;: 80 } ] } clients: [ ClientObject ]
一个数组，代表一组服务端认可的用户.
其中每一项是一个用户 ClientObject。
fallbacks: [ FallbackObject ]
一个数组，包含一系列强大的回落分流配置（可选）。
TIP
Xray 的 Trojan 有完整的 fallbacks 支持，配置方式完全一致。 触发回落的条件也与VLESS类似：首包长度 &amp;lt; 58 或第 57 个字节不为 &amp;lsquo;\r&amp;rsquo;（因为 Trojan 没有协议版本）或身份认证失败。
ClientObject { &amp;#34;password&amp;#34;: &amp;#34;password&amp;#34;, &amp;#34;email&amp;#34;: &amp;#34;love@xray.</description></item><item><title>VMess</title><link>https://xtls.github.io/en/config/outbound-protocols/vmess/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/outbound-protocols/vmess/</guid><description>VMess VMess 是一个加密传输协议，通常作为 Xray 客户端和服务器之间的桥梁。
importantVMess 依赖于系统时间，请确保使用 Xray 的系统 UTC 时间误差在 90 秒之内，时区无关。在 Linux 系统中可以安装ntp服务来自动同步系统时间。
OutboundConfigurationObject { &amp;#34;vnext&amp;#34;: [ { &amp;#34;address&amp;#34;: &amp;#34;127.0.0.1&amp;#34;, &amp;#34;port&amp;#34;: 37192, &amp;#34;users&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;27848739-7e62-4138-9fd3-098a63964b6b&amp;#34;, &amp;#34;alterId&amp;#34;: 0, &amp;#34;security&amp;#34;: &amp;#34;auto&amp;#34;, &amp;#34;level&amp;#34;: 0 } ] } ] } vnext：[ ServerObject ]
一个数组，包含一组的服务端配置.
其中每一项是一个服务端配置ServerObject。
ServerObject { &amp;#34;address&amp;#34;: &amp;#34;127.0.0.1&amp;#34;, &amp;#34;port&amp;#34;: 37192, &amp;#34;users&amp;#34;: [] } address: address
服务端地址，支持 IP 地址或者域名。
port: number
服务端监听的端口号, 必填。</description></item><item><title>【第8章】Xray客户端篇</title><link>https://xtls.github.io/en/documents/level-0/ch08-xray-clients/</link><pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/documents/level-0/ch08-xray-clients/</guid><description>8.1 Xray的工作原理简述 要正确的配置和使用Xray，就需要正确的理解其工作原理，对于新人，可以先看看下面简化的示意图（省略了许多复杂的设置）：
这其中的关键点是：
APP要主动或借助转发工具，将数据【流入(inbounds)】Xray 客户端
流量进入客户端后，会被【客户端路由(routing)】按规则处理后，向不同方向【流出(outbounds)】Xray 客户端。比如：
国内流量直连（direct） 国外流量转发VPS（proxy） 广告流量屏蔽（block） 向VPS转发的国外流量，会跨过防火墙，【流入(inbounds)】 Xray 服务器端
流量进入服务器端后，与客户端一样，会被【服务器端路由(routing)】按规则处理后，向不同方向【流出(outbounds)】：
因为已经在防火墙之外，所以流量默认直连，你就可以访问到不存在网站们了（direct） 如果需要在不同的VPS之间做链式转发，就可以继续配置转发规则（proxy） 你可以在服务器端继续禁用各种你想禁用的流量，如广告、BT下载等（block） 注意： 请务必记得，Xray 的路由配置非常灵活，上面的说明只是无限可能性中的一种。
借助 geosite.dat 和 geoip.dat 这两个文件，可以很灵活的从【域名】和【IP】这两个角度、不留死角的控制流量流出的方向。这比曾经单一笼统的 GFWList 强大很多很多，可以做到非常细致的微调：比如可以指定Apple域名直连或转发、指定亚马逊域名代理或转发，百度的域名屏蔽等等。。。）
8.2 客户端与服务器端正确连接 现在你已经理解了 Xray 的工作原理，那么接下来的配置，其实就是【告诉你的客户端如何连接VPS服务器】。这和你已经很熟悉的、告诉PuTTY如何远程连接服务器是一样的。只不过Xray连接时的要素不止是【IP地址】+【端口】+【用户名】+【密码】这四要素了。
实际上，Xray的连接要素是由不同的协议决定的。本文在第7章的配置文件 config.json 里，我们使用 Xray 下独特而强大的 VLESS 协议 + XTLS 流控。所以看看那个配置文件的内容就能知道，这个协议组合的连接要素有：
服务器【地址】: a-name.yourdomain.com 服务器【端口】: 443 连接的【协议】: vless 连接的【流控】: xtls-rprx-direct (direct模式适合全平台，若是Linux/安卓用户，可改成 xtls-rprx-splice 性能全开) 连接的【验证】: uuiduuid-uuid-uuid-uuiduuiduuid 连接的【安全】: &amp;quot;allowInsecure&amp;quot;: false 鉴于新人一般都会使用手机APP或者电脑的GUI客户端，我就把常用的客户端罗列在下面。每个客户端都有自己独特的配置界面，逐一截图展示并不现实，所以请你务必仔细阅读这些客户端的说明、然后把上述要素填入合适的地方即可。</description></item><item><title>Shadowsocks</title><link>https://xtls.github.io/en/config/inbound-protocols/shadowsocks/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/inbound-protocols/shadowsocks/</guid><description>Shadowsocks 协议，兼容大部分其它版本的实现。
目前兼容性如下：
支持 TCP 和 UDP 数据包转发，其中 UDP 可选择性关闭；
推荐的加密方式：
AES-256-GCM AES-128-GCM ChaCha20-Poly1305 或称 ChaCha20-IETF-Poly1305 none 或 plain 不推荐的加密方式:
AES-256-CFB AES-128-CFB ChaCha20 ChaCha20-IETF important&amp;ldquo;none&amp;rdquo; 不加密方式下，服务器端不会验证 &amp;ldquo;password&amp;rdquo; 中的密码。为确保安全性, 一般需要加上 TLS 并在传输层使用安全配置，例如 WebSocket 配置较长的 path
InboundConfigurationObject { &amp;#34;email&amp;#34;: &amp;#34;love@xray.com&amp;#34;, &amp;#34;method&amp;#34;: &amp;#34;aes-256-gcm&amp;#34;, &amp;#34;password&amp;#34;: &amp;#34;密码&amp;#34;, &amp;#34;level&amp;#34;: 0, &amp;#34;network&amp;#34;: &amp;#34;tcp&amp;#34; } email: string
邮件地址，可选，用于标识用户
method: string
必填。
推荐的加密方式： AES-256-GCM AES-128-GCM ChaCha20-Poly1305 或称 ChaCha20-IETF-Poly1305 none 或 plain password: string</description></item><item><title>Trojan</title><link>https://xtls.github.io/en/config/outbound-protocols/trojan/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/outbound-protocols/trojan/</guid><description>Trojan 协议
importantTrojan 被设计工作在正确配置的加密 TLS 隧道
OutboundConfigurationObject { &amp;#34;servers&amp;#34;: [ { &amp;#34;address&amp;#34;: &amp;#34;127.0.0.1&amp;#34;, &amp;#34;port&amp;#34;: 1234, &amp;#34;password&amp;#34;: &amp;#34;password&amp;#34;, &amp;#34;email&amp;#34;: &amp;#34;love@xray.com&amp;#34;, &amp;#34;flow&amp;#34;: &amp;#34;xtls-rprx-direct&amp;#34;, &amp;#34;level&amp;#34;: 0 } ] } servers: [ ServerObject ]
一个数组，其中每一项是一个 ServerObject。
ServerObject { &amp;#34;address&amp;#34;: &amp;#34;127.0.0.1&amp;#34;, &amp;#34;port&amp;#34;: 1234, &amp;#34;password&amp;#34;: &amp;#34;password&amp;#34;, &amp;#34;email&amp;#34;: &amp;#34;love@xray.com&amp;#34;, &amp;#34;flow&amp;#34;: &amp;#34;xtls-rprx-direct&amp;#34;, &amp;#34;level&amp;#34;: 0 } address: address
服务端地址，支持 IPv4、IPv6 和域名。必填。
port: number
服务端端口，通常与服务端监听的端口相同。
password: string
密码. 必填，任意字符串。
email: string</description></item><item><title>关于Xray</title><link>https://xtls.github.io/en/faq/about/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/faq/about/</guid><description>Q: XXX功能什么时候出来呀!康明宋
Q: 为什么会开发 Xray ?兴趣使然
Q: Xray收钱吗? 可以按我的要求定制吗?Xray 不沾钱,这是个兴趣使然的项目.
Xray 不接受定制, 只根据大家的需求进行兴趣使然的开发.
Q: XXX也是你们开发的吗?请明辨您获取资源的来源, 小心使用, 谨防蜜罐
我们的开发均托管在 github, 不在project X 仓库的, 都不属于 project X 开发.
当然也有很多大佬支持着 Xray 的开发和完善了生态圈, 请见这里.
我们也欢迎所有人一起来完善 Xray.
Q: Xray 和 v2ray 还有 v2fly 是什么关系啊?禁忌の歷史迷局
v2ray-core 项目是继Shadowsocks项目之后活跃的独立项目。
但在2019年，原作者Victoria Raymond突然从 GitHub 项目、社交网站等失联，开发一度陷入停滞。
v2fly项目组基于v2ray项目的技术基础，fork并成立了社区化项目v2fly。
后续于2020年9月与 GitHub 官方沟通确认后，取消了与原 v2ray 项目的fork关系，正式成为独立的社区项目组织。
随后，v2fly社区的贡献者之一 rprx，给v2fly项目带来了VLESS协议，回落分流，XTLS黑科技等一系列更新，v2fly项目进入了&amp;quot;腹泻式&amp;quot;更新时期。
v2fly社区一些成员在某些技术选择及社区理念方面与 rprx 产生分歧。
此后在一些其他外因的促使下，v2fly社区自 v4.33.0 版本起移除了其核心对 XTLS 的支持，但保留了 VLESS 协议支持。
最终 rprx 决定独立分支并成立 project X 社区进行维护。</description></item><item><title>【第9章】附录</title><link>https://xtls.github.io/en/documents/level-0/ch09-appendix/</link><pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/documents/level-0/ch09-appendix/</guid><description>1. 小小白白Linux基础命令索引 编号 命令名称 命令说明 出现篇章 cmd-01 apt update 查询软件更新 《远程登录篇》 cmd-02 apt upgrade 执行软件更新 《远程登录篇》 cmd-03 nano 文本编辑器 《安全防护篇》 cmd-04 systemctl restart 重启某个服务 《安全防护篇》 cmd-05 adduser 给系统新增用户 《安全防护篇》 cmd-06 apt install 安装某个软件 《安全防护篇》 cmd-07 visudo 修改sudo权限设置专用编辑器 《安全防护篇》 cmd-08 sudo 用root权限运行某个命令 《安全防护篇》 cmd-09 chmod 修改目标文件/文件夹的权限 《安全防护篇》 cmd-10 mkdir 新建文件夹 《网站建设篇》 cmd-11 systemctl reload 重新加载某个服务 《网站建设篇》 cmd-12 wget 访问（或下载）某个网页文件 《证书管理篇》 cmd-13 acme.</description></item><item><title>Shadowsocks</title><link>https://xtls.github.io/en/config/outbound-protocols/shadowsocks/</link><pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate><guid>https://xtls.github.io/en/config/outbound-protocols/shadowsocks/</guid><description>Shadowsocks 协议，兼容大部分其它版本的实现。
目前兼容性如下：
支持 TCP 和 UDP 数据包转发，其中 UDP 可选择性关闭；
推荐的加密方式：
AES-256-GCM AES-128-GCM ChaCha20-Poly1305 或称 ChaCha20-IETF-Poly1305 none 或 plain 不推荐的加密方式:
AES-256-CFB AES-128-CFB ChaCha20 ChaCha20-IETF important&amp;ldquo;none&amp;rdquo; 不加密方式下，服务器端不会验证 &amp;ldquo;password&amp;rdquo; 中的密码。为确保安全性, 一般需要加上 TLS 并在传输层使用安全配置，例如 WebSocket 配置较长的 path
OutboundConfigurationObject { &amp;#34;servers&amp;#34;: [ { &amp;#34;email&amp;#34;: &amp;#34;love@xray.com&amp;#34;, &amp;#34;address&amp;#34;: &amp;#34;127.0.0.1&amp;#34;, &amp;#34;port&amp;#34;: 1234, &amp;#34;method&amp;#34;: &amp;#34;加密方式&amp;#34;, &amp;#34;password&amp;#34;: &amp;#34;密码&amp;#34;, &amp;#34;level&amp;#34;: 0 } ] } servers: [ServerObject]
一个数组，代表一组 Shadowsocks 服务端设置, 其中每一项是一个 ServerObject。</description></item><item><title>Whoops! Page not found</title><link>https://xtls.github.io/en/404.html</link><pubDate>Tue, 08 Sep 2020 20:40:23 +0000</pubDate><guid>https://xtls.github.io/en/404.html</guid><description>That page can&amp;rsquo;t be found.
Our latest content is on the homepage.
Photo by Aron Visuals on Unsplash</description></item><item><title/><link>https://xtls.github.io/admin/config.yml</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xtls.github.io/admin/config.yml</guid><description>backend: name: &amp;ldquo;github&amp;rdquo; repo: &amp;ldquo;vjeantet/hugo-theme-docport&amp;rdquo; branch: &amp;ldquo;master&amp;rdquo; open_authoring: true
media_folder: &amp;ldquo;static/images/uploads&amp;rdquo; # Media files will be stored in the repo under images/uploads public_folder: &amp;ldquo;/images/uploads&amp;rdquo; # The src attribute for uploaded media will begin with /images/uploads publish_mode: editorial_workflow</description></item><item><title>Content Manager</title><link>https://xtls.github.io/admin/index.html/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xtls.github.io/admin/index.html/</guid><description/></item></channel></rss>